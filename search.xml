<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo问题解决</title>
      <link href="/2020/07/17/2020-07-17-Hexo%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/07/17/2020-07-17-Hexo%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>不知道什么原因，public文件夹里面没有了index.html。Nginx上会报 <code>403 Forbidden nginx/1.18.0</code>异常，本地 <code>hexo server</code>会报 <code>Cannot GET /</code>。</p><p>执行<code>npm audit fix</code>，查看是否少了什么组件，通过<code>npm install hexo-xxx-xxx</code> 安装即可。（我的hexo缺少了hexo-generator-index组件，因此执行npm install hexo-generator-index即可）</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Artitalk为hexo添加说说功能</title>
      <link href="/2020/07/11/%E4%BD%BF%E7%94%A8Artitalk%E4%B8%BAhexo%E6%B7%BB%E5%8A%A0%E8%AF%B4%E8%AF%B4%E5%8A%9F%E8%83%BD/"/>
      <url>/2020/07/11/%E4%BD%BF%E7%94%A8Artitalk%E4%B8%BAhexo%E6%B7%BB%E5%8A%A0%E8%AF%B4%E8%AF%B4%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="查看Artitalk官方使用文档"><a href="#查看Artitalk官方使用文档" class="headerlink" title="查看Artitalk官方使用文档"></a>查看<a href="https://artitalk.js.org/doc.html" target="_blank" rel="noopener">Artitalk</a>官方使用文档</h1><p><img src="/img/Artitalk01.png" alt="官方文档方法"></p><p>严格按照官方文档创建，我就是看漏了一步弄了好久。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artitalk </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis03</title>
      <link href="/2020/07/10/09_MYBATIS_DAY03/"/>
      <url>/2020/07/10/09_MYBATIS_DAY03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-通过查询时自定义别名的方式解决名称不一致而导致的无法封装数据的问题"><a href="#1-通过查询时自定义别名的方式解决名称不一致而导致的无法封装数据的问题" class="headerlink" title="1. 通过查询时自定义别名的方式解决名称不一致而导致的无法封装数据的问题"></a>1. 通过查询时自定义别名的方式解决名称不一致而导致的无法封装数据的问题</h2><p>假设，向用户组数据表(<code>t_group</code>)表中插入一些测试数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t_group (name) VALUES (&#39;超级管理员&#39;), (&#39;VIP用户&#39;), (&#39;普通用户&#39;);</span><br><span class="line">INSERT INTO t_group (name) VALUES (&#39;禁用用户&#39;);</span><br></pre></td></tr></table></figure><p>接下来，就应该在用户数据表(<code>t_user</code>)中添加新的字段，用于记录每个用户归属于哪个组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE t_user ADD COLUMN group_id int;</span><br></pre></td></tr></table></figure><p>然后，为现有的数据分配组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t_user SET group_id&#x3D;1 WHERE id IN (11);</span><br><span class="line">UPDATE t_user SET group_id&#x3D;2 WHERE id IN (9, 10);</span><br><span class="line">UPDATE t_user SET group_id&#x3D;3 WHERE id IN (2, 6, 13);</span><br></pre></td></tr></table></figure><p>当用户数据表添加了新的字段以后，在项目中的<code>User</code>类也应该添加新的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String phone;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"><span class="keyword">private</span> Integer groupId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Setters &amp; Getters</span></span><br><span class="line">    <span class="comment">// toString()</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当再次尝试查询数据时，会发现查询到的结果中，每条数据的<code>groupId</code>值均为<code>null</code>，其实这些数据在数据库中都是有值的，只是当前的查询功能并没有把它们查出来而已！</p><p><strong>MyBatis在处理查询时，会自动的将名称匹配的数据进行封装，其要求是查询结果的列名与封装结果的类的属性名相同</strong>（其实是要求属性的SET方法与之保持一致），如果名称不相同，则无法自动装配对应的数据！</p><blockquote><p>Field：字段，在设计数据表时定义的名称；</p><p>Column：列，在查询结果中，每个数据的名称就是列名；</p><p>Property：属性，在类中声明的全局变量；</p></blockquote><p>在查询时，默认情况下，列名就是字段名，但是，在查询的SQL语句中，可以自定义别名，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,username,password,age,phone,email,group_id groupId FROM t_user ORDER BY id</span><br></pre></td></tr></table></figure><p>则配置为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"cn.tedu.mybatis.User"</span>&gt;</span></span><br><span class="line">    SELECT </span><br><span class="line">        id, username, password, age, phone, email,</span><br><span class="line">        group_id AS groupId </span><br><span class="line">    FROM </span><br><span class="line">        t_user </span><br><span class="line">    ORDER </span><br><span class="line">        BY id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-使用resultMap节点解决名称不一致而导致的无法封装数据的问题"><a href="#2-使用resultMap节点解决名称不一致而导致的无法封装数据的问题" class="headerlink" title="2. 使用resultMap节点解决名称不一致而导致的无法封装数据的问题"></a>2. 使用resultMap节点解决名称不一致而导致的无法封装数据的问题</h2><p>在没有自定义别名的情况下，如果查询结果的列名与类的属性名不一致，还可以自定义<code>&lt;resultMap&gt;</code>节点进行配置，该节点的作用就是指导MyBatis封装查询到的数据！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- id：自定义的名称，将应用于select节点的resultMap属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- type：封装查询结果的数据类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserMap"</span> <span class="attr">type</span>=<span class="string">"cn.tedu.mybatis.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- result节点：将查询结果中column列对应的值封装到类的property属性中去 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">property</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"phone"</span> <span class="attr">property</span>=<span class="string">"phone"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"group_id"</span> <span class="attr">property</span>=<span class="string">"groupId"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">resultMap</span>=<span class="string">"UserMap"</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        *</span><br><span class="line">    FROM </span><br><span class="line">        t_user </span><br><span class="line">    WHERE </span><br><span class="line">        id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在以上配置中，需要注意：<code>&lt;resultMap&gt;</code>节点中的<code>id</code>属性值就是<code>&lt;select&gt;</code>节点的<code>resultMap</code>属性值！</p><p>如果需要执行的查询操作是单表数据查询，在配置<code>&lt;resultMap&gt;</code>时，对于那些列名与属性名一致的，可以不作配置！</p><p>在配置<code>&lt;resultMap&gt;</code>时，推荐在子级使用<code>&lt;id&gt;</code>节点配置主键，然后使用<code>&lt;result&gt;</code>节点配置其它的，便于实现缓存！MyBatis有2级缓存，其中，MyBatis的1级缓存是SqlSession缓存，开发人员无法干预，2级缓存是namespace缓存，一旦开启，默认情况下，将作用于整个XML文件，需要事先在当前XML文件中添加<code>&lt;cache&gt;&lt;/cache&gt;</code>节点，表示“启用缓存”，理启用缓存，需要封装查询结果的数据类型是实现了<code>Serializable</code>接口的，如果某个查询不需要使用缓存，还可以在<code>&lt;select&gt;</code>节点中配置<code>useCache=&quot;false&quot;</code>，然后，就不需要开发人员进行其它配置了，MyBatis会自动处理缓存的数据，并且，一旦当前namespace执行了增删改类型的操作，就会重建缓存！</p><p><strong>小结</strong>：在SQL中使用自定义别名，并在<code>&lt;select&gt;</code>中使用<code>resultType</code>指定封装结果的数据类型，或在SQL中使用星号表示字段列表，并配置<code>&lt;resultMap&gt;</code>节点后在<code>&lt;select&gt;</code>中使用<code>resultMap</code>，均可解决由于名称不一致导致无法封装查询结果的问题。</p><h2 id="3-一对一的关联查询"><a href="#3-一对一的关联查询" class="headerlink" title="3. 一对一的关联查询"></a>3. 一对一的关联查询</h2><p>假设存在需求：根据id查询某用户的数据，并且，要求查出该用户归属的用户组的名称。</p><p>如果要根据id查询某用户的数据，需要执行的SQL语句大致是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t_user WHERE id&#x3D;?</span><br></pre></td></tr></table></figure><p>如果还要查出该用户归属的组的名称，需要关联<code>t_group</code>数据表一起查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t_user LEFT JOIN t_group ON t_user.group_id&#x3D;t_group.id WHERE id&#x3D;?</span><br></pre></td></tr></table></figure><p>由于以上关联条件就是<code>t_user.group_id=t_group.id</code>，结合使用星号作为字段列表，所以，在查询结果中，一定存在<code>group_id</code>和其后的<code>id</code>字段值一模一样的问题！由于有2个字段的值一定完全相同，则应该明确的指定需要查询的字段列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">t_user.*,</span><br><span class="line">t_group.name </span><br><span class="line">FROM </span><br><span class="line">t_user </span><br><span class="line">LEFT JOIN </span><br><span class="line">t_group </span><br><span class="line">ON </span><br><span class="line">t_user.group_id&#x3D;t_group.id </span><br><span class="line">WHERE </span><br><span class="line">t_user.id&#x3D;?</span><br></pre></td></tr></table></figure><p>在使用MyBatis框架尝试实现功能时，目前并没有任何实体类可以封装以上查询的结果，因为实体类的属性设计是要求与数据表保持对应的，而此处需要执行的查询涉及2张表！则需要创建VO类（Value Object类）来封装此次查询的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer groupId;</span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Setters &amp; Getters</span></span><br><span class="line">    <span class="comment">// toString()</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实体类中的属性需要与数据表相对应；</p><p>VO类中的属性需要与查询结果相对应；</p><p>除此以外，这2种类的写法是一样的，只是定位不同。</p></blockquote><p>开发抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserVO <span class="title">findVOById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>配置SQL映射：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findVOById"</span> <span class="attr">resultType</span>=<span class="string">"cn.tedu.mybatis.UserVO"</span>&gt;</span></span><br><span class="line">    SELECT </span><br><span class="line">        t_user.id, username, password, age, phone, </span><br><span class="line">    email, group_id AS groupId,</span><br><span class="line">        t_group.name AS groupName</span><br><span class="line">    FROM </span><br><span class="line">        t_user </span><br><span class="line">    LEFT JOIN </span><br><span class="line">        t_group </span><br><span class="line">    ON </span><br><span class="line">        t_user.group_id=t_group.id </span><br><span class="line">    WHERE </span><br><span class="line">        t_user.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成后，测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findVOById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer id = <span class="number">10</span>;</span><br><span class="line">    UserVO user = userMapper.findVOById(id);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-一对多的关联查询"><a href="#4-一对多的关联查询" class="headerlink" title="4. 一对多的关联查询"></a>4. 一对多的关联查询</h2><p>假设存在需求：根据id查询某个用户组的信息，并且，还查出该组有哪些用户，最终，把这些用户的信息也显示出来！</p><p>需要执行的SQL语句大致是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">*</span><br><span class="line">FROM </span><br><span class="line">t_group</span><br><span class="line">LEFT JOIN</span><br><span class="line">t_user</span><br><span class="line">ON</span><br><span class="line">t_group.id&#x3D;t_user.group_id</span><br><span class="line">WHERE</span><br><span class="line">t_group.id&#x3D;1</span><br></pre></td></tr></table></figure><p>当查询后，需要使用一个新的VO类来封装此次的查询结果，则创建<code>GroupVO</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupVO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Setters &amp; Getters</span></span><br><span class="line">    <span class="comment">// toString()</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一对多的查询中，MyBatis根本就不知道怎么封装查询结果中的数据！当没有匹配的查询结果，或只有1条查询结果时，并不会报错，只是查询结果的数据不正确而已，如果查询结果有多条，则会出现如下错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 2</span><br></pre></td></tr></table></figure><p>为了保障能够正确的封装查询结果，<strong>必须</strong>使用<code>&lt;resultMap&gt;</code>来指导MyBatis封装！并且，在SQL语句中，还需要为某个<code>id</code>定义别名，以保证查询结果每一列的名称都不同，否则，MyBatis只会从相同的列名中排列靠前的那一列中取数据，甚至，如果在<code>&lt;resultMap&gt;</code>中使用<code>&lt;id&gt;</code>配置主键，当出现多条数据的最靠前的那一列id值相同时，重复id的数据将不会被封装！</p><p>具体配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.tedu.mybatis.GroupMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"GroupVOMap"</span> <span class="attr">type</span>=<span class="string">"cn.tedu.mybatis.GroupVO"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"gid"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- collection节点：用于配置1对多的属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ofType属性：集合元素类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"users"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ofType</span>=<span class="string">"cn.tedu.mybatis.User"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">property</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"phone"</span> <span class="attr">property</span>=<span class="string">"phone"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"group_id"</span> <span class="attr">property</span>=<span class="string">"groupId"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findVOById"</span> <span class="attr">resultMap</span>=<span class="string">"GroupVOMap"</span>&gt;</span></span><br><span class="line">SELECT</span><br><span class="line">t_group.id AS gid, name,</span><br><span class="line">t_user.*</span><br><span class="line">FROM </span><br><span class="line">t_group</span><br><span class="line">LEFT JOIN</span><br><span class="line">t_user</span><br><span class="line">ON</span><br><span class="line">t_group.id=t_user.group_id</span><br><span class="line">WHERE</span><br><span class="line">t_group.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：在配置一对多的查询时，在<code>&lt;resultMap&gt;</code>中，即使存在列名与属性名完全相同的数据，也必须通过<code>&lt;id&gt;</code>或<code>&lt;result&gt;</code>节点进行配置！</p><h2 id="5-MyBatis阶段小结"><a href="#5-MyBatis阶段小结" class="headerlink" title="5. MyBatis阶段小结"></a>5. MyBatis阶段小结</h2><ul><li><p>【理解】MyBatis框架的主要作用是简化持久层开发；</p></li><li><p>【了解】使用MyBatis时的必要配置：</p><ul><li>添加依赖：<code>mybatis</code> / <code>mybatis-spring</code> / <code>spring-context</code> / <code>spring-jdbc</code> / <code>mysql-connector-java</code>(也可以是其它数据库连接jar包，根据实际情况选取) / <code>druid</code>(也可以是其它数据库连接池)；</li><li>配置连接数据库的信息，例如url、driver-class-name等；</li><li>配置XML文件的位置（如果使用XML配置SQL语句）；</li><li>使用配置类，读取连接数据库的信息，用于配置<code>DataSource</code>；配置<code>SqlSessionFactoryBean</code>；在配置类的声明之前使用<code>@MapperScan</code>注解配置接口文件所在的包；</li></ul></li><li><p>【掌握】抽象方法的声明原则</p><ul><li>【返回值类型】如果需要执行的操作是<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>类型的操作，使用<code>Integer</code>作为返回值类型，表示“受影响的行数”，也可以使用<code>void</code>但不推荐；如果需要执行操作是<code>SELECT</code>类型，使用期望的数据类型作为返回值类型，只需要保证该类型能够封装查询结果即可；</li><li>【方法名称】自定义，但不允许重载；</li><li>【参数列表】根据需要执行的SQL语句中的参数来设计，可以将所需的参数逐一的添加到抽象方法的参数列表中，也可以使用封装的类型作为参数，当抽象方法的参数超过1个（例如2个或更多个），必须（应该）为每个参数添加<code>@Param</code>注解并配置参数名称。</li></ul></li><li><p>【掌握】配置抽象方法对应的SQL语句</p><ul><li>可以在抽象方法的声明之前使用<code>@Insert</code>、<code>@Delete</code>、<code>@Update</code>、<code>@Select</code>节点配置SQL语句，这种做法不推荐用于篇幅较长的SQL语句，或配置较多的功能；</li><li>配置SQL语句的XML文件必须在配置指定的文件夹中；</li><li>每个XML文件的根节点是<code>&lt;mapper&gt;</code>，其中的<code>namespace</code>属性是对应的接口的全名；</li><li>在XML文件的子级通过<code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code>节点配置SQL语句，每个节点都必须配置<code>id</code>属性，取值为抽象方法的名称；</li><li>如果插入数据后需要获取自动编号的id值，需要在<code>&lt;insert&gt;</code>节点配置<code>useGeneratedKeys</code>和<code>keyProperty</code>属性；</li><li>在<code>&lt;select&gt;</code>节点中，必须配置<code>resultType</code>以指定抽象方法的返回值类型，或配置<code>resultMap</code>用于指导MyBatis封装查询结果，这2个属性必须配置其中的1个；</li></ul></li><li><p>【理解】关于<code>#{}</code>和<code>${}</code>格式的占位符的使用情景和区别；</p></li><li><p>【掌握】动态SQL的<code>&lt;foreach&gt;</code>的使用；</p></li><li><p>【了解】动态SQL的<code>&lt;if&gt;</code>和<code>&lt;choose&gt;</code>系列节点的使用；</p></li><li><p>【掌握】解决因为名称不一致导致MyBatis无法自动封装查询结果的问题</p><ul><li>当自定义字段列表时，自定义别名，使得名称保持一致，并且，在<code>&lt;select&gt;</code>节点中使用<code>resultType</code>即可；</li><li>当使用星号表示字段列表时，配置<code>&lt;resultMap&gt;</code>以指导MyBatis封装，并且，在<code>&lt;select&gt;</code>节点中使用<code>resultMap</code>应用配置的<code>&lt;resultMap&gt;</code>。</li></ul></li><li><p>【理解】实体类与VO类的区别；</p></li><li><p>【掌握】一对多的关联查询及相关配置（例如<code>&lt;resultMap&gt;</code>中的<code>&lt;collection&gt;</code>子节点）；</p></li><li><p>【了解】缓存的基本概念；</p></li><li><p>【理解】什么情况下需要使用<code>&lt;resultMap&gt;</code>：</p><ul><li>查询时，存在名称不匹配的问题，且使用星号表示字段列表；</li><li>【必须】配置1对多的查询；</li></ul></li><li><p>【理解】什么情况下需要自定义别名：</p><ul><li>查询时，存在名称不匹配的问题，且不使用<code>resultMap</code>，则需要自定义别名；</li><li>【必须】关联查询时，存在多个名称相同的列，则需要自定义别名，使得这些列名不同。</li></ul></li></ul><h2 id="6-作业"><a href="#6-作业" class="headerlink" title="6. 作业"></a>6. 作业</h2><p>要求用户可以通过注册页面提交注册数据，最终，注册成功后，数据将写入到<code>t_user</code>表中。</p><ul><li><p>要求用户名必须唯一，如果尝试注册的用户名已经被占用，应该给出错误提示，在持久层，应该至少开发<code>Integer insert(User user)</code>和<code>User findByUsername(String username)</code>方法，在用户尝试注册时，应该先通过<code>findByUsername()</code>检查用户名是否已经被占用（如果找到数据，则表示已被占用，如果找不到数据，则表示未被占用），再决定执行<code>insert()</code>或直接报错。</p></li><li><p>关于控制器中调用持久层方法，大致代码如下：</p><ul><li><pre><code class="java"><span class="meta">@Controller</span><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>{    <span class="comment">// 如果使用IDEA，可能报错，配置为@Autowired(required=false)即可</span>    <span class="meta">@Autowired</span>    <span class="keyword">private</span> UserMapper userMapper;    <span class="meta">@RequestMapping</span>(<span class="string">"reg.do"</span>)    <span class="function"><span class="keyword">public</span> String <span class="title">reg</span><span class="params">(User user)</span> </span>{        <span class="comment">// 直接调用全局的userMapper即可访问持久层</span>    }}</code></pre></li></ul></li></ul><p>如果时间充裕，再做一个登录功能。</p><p>如果已经完成，复习SSM框架，复习JSON，复习Vue。</p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis02</title>
      <link href="/2020/07/08/09_MYBATIS_DAY02/"/>
      <url>/2020/07/08/09_MYBATIS_DAY02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-使用XML文件配置SQL语句"><a href="#1-使用XML文件配置SQL语句" class="headerlink" title="1. 使用XML文件配置SQL语句"></a>1. 使用XML文件配置SQL语句</h2><p>首先下载<code>http://doc.canglaoshi.org/config/Mapper.xml.zip</code>，解压得到<strong>SomeMapper.xml</strong>。</p><p>在项目的<strong>src/main/resources</strong>下创建<strong>mappers</strong>文件夹，并将<strong>SomeMapper.xml</strong>复制到该文件夹，并重命名为<strong>UserMapper.xml</strong>。</p><blockquote><p>此步骤中创建的文件夹的名称是自定义的，与后续的配置有关。</p><p>此步骤中XML文件的名称是自定义的，与其它任何配置都无关。</p></blockquote><p>以上添加的<strong>UserMapper.xml</strong>就是用于配置SQL语句的文件，通常称之为<strong>映射文件</strong>！该文件中的以下代码是固定的，且不可缺少的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该文件的根节点是<code>&lt;mapper&gt;</code>节点，必须配置<code>namespace</code>的属性，该属性的值是对应的MyBatis接口文件的全名，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.tedu.mybatis.UserMapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，根据需要执行的SQL语句的种类，选择使用<code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code>这4个节点中的某1个来配置SQL语句，这些节点都必须配置<code>id</code>属性，该属性的值就是接口中的抽象方法的名称，然后，在节点内部编写SQL语句即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- namespace属性：接口的全名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.tedu.mybatis.UserMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- id属性：抽象方法的名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span>&gt;</span></span><br><span class="line">INSERT INTO t_user (</span><br><span class="line">username, password, age, phone, email</span><br><span class="line">) VALUES (</span><br><span class="line">#&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;phone&#125;, #&#123;email&#125;</span><br><span class="line">)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前，MyBatis框架并不知道存在<strong>mappers</strong>文件夹，更加不知道哪个文件配置的SQL语句！可以将配置SQL语句的XML文件的位置配置在<strong>jdbc.properties</strong>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.mapper-locations&#x3D;classpath:mappers&#x2F;*.xml</span><br></pre></td></tr></table></figure><p>以上代码就用于表示“在<strong>src/main/resouces</strong>下的<strong>mappers</strong>文件夹中的所有XML文件都是用于配置SQL语句的”，在后续使用时，也必须保证不会在<strong>mappers</strong>文件夹中添加其它作用的XML文件！</p><p>接下来，还应该读取以上配置信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;mybatis.mapper-locations&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> Resource[] mapperLocations;</span><br></pre></td></tr></table></figure><p>并应用于<code>SqlSessionFactoryBean</code>对象的属性中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">    bean.setDataSource(dataSource);</span><br><span class="line">    bean.setMapperLocations(mapperLocations);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在运行或测试之前，还需要注意：每个抽象方法只能通过1种方式配置SQL语句，要么使用注解，要么使用XML文件，不可以同时使用！否则将报错，错误提示的关键信息例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for cn.tedu.mybatis.UserMapper.insert. please check file [D:\eclipse-workspace-202003\mybatis\target\classes\mappers\UserMapper.xml] and cn&#x2F;tedu&#x2F;mybatis&#x2F;UserMapper.java (best guess)</span><br></pre></td></tr></table></figure><p>以上提示中的<code>Mapped Statements collection already contains value for cn.tedu.mybatis.UserMapper.insert.</code>就表示“<code>cn.tedu.mybatis.UserMapper.insert</code>方法被映射了多个SQL语句的配置”，并且还推荐了检查<strong>UserMapper.xml</strong>和<strong>UserMapper.java</strong>文件！</p><p>如果配置的是<code>&lt;insert&gt;</code>节点，且需要获取自动编号的ID值，则在<code>&lt;insert&gt;</code>节点中继续配置属性即可，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    INSERT INTO t_user (</span><br><span class="line">        username, password, age, phone, email</span><br><span class="line">    ) VALUES (</span><br><span class="line">        #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;phone&#125;, #&#123;email&#125;</span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当需要实现的数据访问是查询类型的，在<code>&lt;select&gt;</code>节点中必须配置<code>resultType</code>或<code>resultMap</code>中的某1个属性（二选一），如果都没有指定，则会出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.ibatis.executor.ExecutorException: A query was run and no Result Maps were found for the Mapped Statement &#39;cn.tedu.mybatis.UserMapper.count&#39;.  It&#39;s likely that neither a Result Type nor a Result Map was specified.</span><br></pre></td></tr></table></figure><p>其中，<code>resultType</code>指的就是“封装查询结果的数据的类型”，也可以理解为“抽象方法的返回值的类型”，例如可以配置为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"count"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">SELECT COUNT(*) FROM t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果某个查询的抽象方法的返回值是<code>List</code>集合类型的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>在配置<code>&lt;select&gt;</code>的<code>resultType</code>属性时，该属性值必须是集合中的元素的类型，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"cn.tedu.mybatis.User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_user ORDER BY id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至于<code>resultMap</code>属性，后面专门介绍。</p><p>注意：使用了这种做法后，就需要对抽象方法名称的定义增加一个要求“不允许重载”！</p><h2 id="2-关于多参数的问题"><a href="#2-关于多参数的问题" class="headerlink" title="2. 关于多参数的问题"></a>2. 关于多参数的问题</h2><p>当抽象方法的参数列表中超过1个参数时，在配置SQL语句时直接使用<code>#{参数名称}</code>是无法访问到参数值的！</p><p>因为Java源文件在运行之前需要被编译成字节码文件（.class文件），编译时，会丢失所有局部的量的名称，所以，会导致运行时原有的“参数名称”无法使用的问题！</p><p>MyBatis允许使用<code>arg</code>作为前缀并添加从<code>0</code>开始编号的名称（例如<code>arg0</code>、<code>arg1</code>等等）表示第?个参数的名称，后续，在配置SQL语句时，就可以通过例如<code>#{arg0}</code>来表示抽象方法的第1个参数的值，使用<code>#{arg1}</code>表示抽象方法的第2个参数的值……以此类推！另外，还可以使用<code>param</code>作为前缀并添加从<code>1</code>开始编号的名称（例如<code>param1</code>、<code>param2</code>等等），在具体使用时，使用<code>arg</code>系列的名称和<code>param</code>系列的名称均可！</p><p>但是，使用<code>arg</code>和<code>param</code> 系列的名称不便于表示语义，并且，当抽象方法的参数列表发生变化时，这些名称中的序号也可能需要调整！</p><p>MyBatis提供了<code>@Param</code>注解，这个注解是添加在抽象方法的各参数之前的，可以在该注解中指定名称，后续，在配置SQL语句时，占位符中就使用注解中配置的名称！</p><h2 id="2-练习"><a href="#2-练习" class="headerlink" title="2. 练习"></a>2. 练习</h2><ul><li><p>在<code>tedu_ums</code>数据库中创建<code>t_group</code>表，用于存储“用户分组”的信息，该表需要有<code>id</code>和<code>name</code>这2个字段，分别表示“组id”和“组名称”；</p><ul><li><pre><code class="mysql">CREATE TABLE t_group (    id int AUTO_INCREMENT,    name VARCHAR(10) NOT NULL UNIQUE,    PRIMARY KEY (id)) DEFAULT CHARSET=utf8mb4;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在项目中，创建&#96;Group&#96;实体类，对应&#96;t_group&#96;表；</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    package cn.tedu.mybatis;</span><br><span class="line">    </span><br><span class="line">    public class Group &#123;</span><br><span class="line">    </span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">    return id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">    return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">    return &quot;Group [id&#x3D;&quot; + id + &quot;, name&#x3D;&quot; + name + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>通过MyBatis技术，实现：</p><ul><li>增加组；</li><li>根据id删除组；</li><li>根据id查询组；</li><li>查询所有组。</li></ul></li></ul><h2 id="3-动态SQL-–-foreach"><a href="#3-动态SQL-–-foreach" class="headerlink" title="3. 动态SQL – foreach"></a>3. 动态SQL – foreach</h2><p>假设存在需求：批量删除用户数据（一次性删除若干条用户数据）；</p><p>需要执行的SQL语句大致是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM t_user WHERE id&#x3D;? OR id&#x3D;? OR id&#x3D;?;</span><br><span class="line">DELETE FROM t_user WHERE id IN (?,?,?);</span><br></pre></td></tr></table></figure><p>作为开发人员，无法确定以上SQL语句中问号的数量，及问号对应的参数值！只能确定以上参数的数据类型及所表示的意义！</p><p>以上功能最终将由用户（软件的使用者）来决定需要删除的数据的数量（问号的数量），及删除的数据是哪几条（问号对应的参数值）！就会导致“当用户的操作不同时（选中需要删除的数据不同），最终需要执行的SQL语句是不同的”！MyBatis框架提供了“动态SQL”机制来解决这个问题！</p><p><strong>动态SQL</strong>：根据用户提供的参数值不同，最终需要执行的SQL语句可以不同！</p><p>当需要实现以上批量删除的需求时，可以将抽象方法设计为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">deleteByIds</span><span class="params">(List&lt;Integer&gt; ids)</span></span>;</span><br></pre></td></tr></table></figure><p>或者，也可以设计为（本次案例就使用这个）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">deleteByIds</span><span class="params">(Integer[] ids)</span></span>;</span><br></pre></td></tr></table></figure><p>甚至，还可以设计为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">deleteByIds</span><span class="params">(Integer... ids)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>可变参数在被处理时，本质上就是数据。</p></blockquote><p>在配置SQL语句时，需要通过<code>&lt;foreach&gt;</code>节点来配置SQL语句中需要通过循环生成的部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteByIds"</span>&gt;</span></span><br><span class="line">    DELETE FROM t_user WHERE id IN (</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"array"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于<code>&lt;foreach&gt;</code>节点的配置：</p><ul><li><p><code>collection</code>：需要被遍历的对象，当抽象方法的参数只有1个且没有添加<code>@Param</code>注解时，如果参数类型是<code>List</code>集合，则取值为<code>list</code>，如果参数类型是数组，则取值为<code>array</code>；当抽象方法的参数超过1个，就一定添加了<code>@Param</code>注解，则取值为<code>@Param</code>注解配置的参数值；</p></li><li><p><code>item</code>：遍历过程中的每一个元素数据，当前属性可以自定义值表示元素数据的名称，在<code>&lt;foreach&gt;</code>节点的子级，使用<code>#{}</code>占位符时，就可以使用这个名称来表示数据；</p></li><li><p><code>separator</code>：遍历生成的代码片段中，各元素数据之间的分隔符号；</p></li><li><p><code>open</code> / <code>close</code>：遍历生成的代码片段的最左侧字符串/最右侧字符串。</p></li></ul><p><strong>练习</strong>：根据若干个用户的id将这些用户的密码设置为某个值。</p><p>需要执行的SQL语句大致是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t_user SET password&#x3D;? WHERE id IN (?,?,?)</span><br></pre></td></tr></table></figure><p>可以将抽象方法设计为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">updatePasswordByIds</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @Param(<span class="string">"ids"</span>)</span> List&lt;Integer&gt; ids, </span></span><br><span class="line"><span class="function">    @<span class="title">Param</span><span class="params">(<span class="string">"password"</span>)</span> String password</span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><p>然后，配置SQL语句（配置映射）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updatePasswordByIds"</span>&gt;</span></span><br><span class="line">    UPDATE t_user SET password=#&#123;password&#125; WHERE id IN (</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">    #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-动态SQL-–-if"><a href="#4-动态SQL-–-if" class="headerlink" title="4. 动态SQL – if"></a>4. 动态SQL – if</h2><p>在配置SQL语句时，可以添加<code>&lt;if&gt;</code>节点用于判断参数值，从而决定最终执行的SQL语句中是否包括某个SQL语句片段。</p><p>例如存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">find</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @Param(<span class="string">"where"</span>)</span> String where,</span></span><br><span class="line"><span class="function">    @<span class="title">Param</span><span class="params">(<span class="string">"orderBy"</span>)</span> String orderBy, </span></span><br><span class="line"><span class="function">    @<span class="title">Param</span><span class="params">(<span class="string">"offset"</span>)</span> Integer offset, </span></span><br><span class="line"><span class="function">    @<span class="title">Param</span><span class="params">(<span class="string">"count"</span>)</span> Integer count</span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><p>则可以配置为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"find"</span> <span class="attr">resultType</span>=<span class="string">"cn.tedu.mybatis.User"</span>&gt;</span></span><br><span class="line">SELECT * FROM t_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"where != null"</span>&gt;</span></span><br><span class="line">    WHERE $&#123;where&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"orderBy != null"</span>&gt;</span></span><br><span class="line">    ORDER BY $&#123;orderBy&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"offset != null and count != null"</span>&gt;</span></span><br><span class="line">    LIMIT #&#123;offset&#125;, #&#123;count&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意：以上案例只是假想中的代码，在实际开发时，一定不要这样来使用！</p><p>需要注意：在动态SQL中，<code>&lt;if&gt;</code>节点并没有匹配的<code>else</code>部分！如果一定需要实现<code>if...else</code>的语法效果，可以写2个条件完全相反的<code>&lt;if&gt;</code>节点，或者，通过<code>&lt;choose&gt;</code>、<code>&lt;when&gt;</code>、<code>&lt;otherwise&gt;</code>节点进行配置，其基本格式是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        满足条件时的SQL语句片段</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        不满足条件时的SQL语句片段</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-关于-和-格式的占位符"><a href="#5-关于-和-格式的占位符" class="headerlink" title="5. 关于#{}和${}格式的占位符"></a>5. 关于#{}和${}格式的占位符</h2><p>MyBatis允许在配置SQL语句时使用<code>#{}</code>和<code>${}</code>这2种格式的占位符来表示参数值。</p><p><strong>简单原则</strong>：在原本使用JDBC技术编程时，编写SQL语句时可以写问号(<code>?</code>)的位置，都使用<code>#{}</code>格式的占位符，不可以写问号的位置，必须使用<code>${}</code>格式的占位符！</p><p>使用<code>#{}</code>格式的占位符，只能表示某个值！MyBatis在处理时，会通过预编译的方式进行处理，即：先使用问号对占位符表示的值进行占位，并将整个SQL语句交由MySQL进行编译相关的处理（包括词法分析、语义分析、编译），当编译完成后，再将值代入到编译成功的SQL语句中一并执行。简单来说，使用<code>#{}</code>格式的占位符时，最终处理机制是使用了预编译的！所以，使用这种格式的占位符时，在编写SQL时<strong>不需要关心值的数据类型的问题</strong>，并且，<strong>不存在SQL注入的风险</strong>！</p><p>使用<code>${}</code>格式的占位符，可以表示SQL语句中的任意片段！MyBatis在处理时，会先将<code>${}</code>格式占位符对应的值<strong>拼接</strong>到SQL语句中，然后再将SQL语句交由MySQL进行编译相关处理，也就是说，<code>${}</code>格式占位符的值在编译之前就已经代入到SQL语句中了！很显然，在处理<code>${}</code>格式的占位符时，没有（也不可能）使用预编译！所以，使用这种格式的占位符时，<strong>需要自行在SQL语句中考虑数据类型的问题</strong>，例如字符串类型的值需要使用一对单引号框住！另外，还<strong>存在SQL注入的风险</strong>！</p><hr><h2 id="【整合SSM框架】"><a href="#【整合SSM框架】" class="headerlink" title="【整合SSM框架】"></a>【整合SSM框架】</h2><p>在创建SpringMVC项目的基础之上，将<code>mybatis</code>案例中的<code>SpringConfig</code>类放进去，并作为项目初始化类的<code>getRootConfigClasses()</code>方法的返回值，并添加<strong>jdbc.properties</strong>配置文件及相关依赖即可。</p><p>注意：为了确保框架整合后可以正常使用，推荐在<code>SpringConfig</code>类的声明之前添加<code>@Configuration</code>注解。</p><p>提示：当在控制器中需要使用持久层对象时，直接声明出<code>private UserMapper userMapper;</code>属性并添加<code>@Autowired</code>注解，即可在控制器中调用持久层所开发的方法！</p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码</title>
      <link href="/2020/07/08/09_MYBATIS_DAY01_PLUS/"/>
      <url>/2020/07/08/09_MYBATIS_DAY01_PLUS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>计算机能够直接识别并处理的只有二进制数，这是由计算机的电子元器件的特性所导致的！</p><p>在二进制数中，每个0或每个1所占据的存储空间是1个二进制位（bit），由于1个二进制能够表达的信息含义只有2种，所以，1个二进制位不足以表达大量有意义的信息，通常使用字节（byte）来表示，每1个字节占8个二进制位，它是计算机中最基础的存储单位。</p><p>为了表示人类生活中使用到的字符（字母、数字、标点符号），早期就设计出了ASCII码表，它就记录了字符与二进制数的对应关系，例如<code>110 0001</code>就对应<code>a</code>，<code>110 0010</code>对应<code>b</code>……</p><p>由于ASCII码表记录都是1个字节能够表示的字符，除去最高位的符号位，只有7个二进制位，只能表示128种不同的意义，就无法表示中文！所以，就出现了其它的编码，例如GBK、GB2312等，当然，ASCII码表也不适用于其它不使用英语的国家和民族，例如日本、韩国等，也创建了对应的编码。</p><p>由于越来越多的国家和民族都普及了计算机，设计出来的编码的种类太多，为了统一支持统一使用，就出现了Unicode编码，这是一种全球化编码，记录了全世界各国家和民族所使用的各种字符！</p><p>使用Unicode编码时，大多情况下使用2个字节来描述1个字符，假设可以使用<code>1010 0011 1010 0101</code>可以表示“汉”（只是假设而已），可以使用<code>1011 1111 0000 1010</code>表示“字”，当需要将“汉字”这2个字符在网络传输，可能在网络上出现的二进制数据就是<code>1010 0011 1010 0101 1011 1111 0000 1010</code> ，但是，当接收方接收到这个二进制的序列时，就无法明确：这到底是2个汉字，还是4个英文，甚至是1汉字2英文，或2英文1汉字，或1英文1汉字1英文……</p><p>为了保障传输过程不会出现以上假设的问题，就产生了UTF系列的编码！</p><blockquote><p>UTF = Unicode Transformation Format，Unicode传输编码。</p></blockquote><p>以UTF-8为例，当需要传输2个字节才可以表示的1个字符时，会将二进制序列中的特定位置作为标记，并不用于表示编码的含义，凡是2个字节的数据，其格式都是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">110 xxxxx10 xxxxxx</span><br></pre></td></tr></table></figure><p>以上第1个字节的<code>110</code>中包括了2个<code>1</code>，就表示“从当前字节开始，一共有2个字节来描述同1个字符”！</p><p>当需要传输3个字节才可以表示的1个字符时，其格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1110 xxxx10 xxxxxx10 xxxxxx</span><br></pre></td></tr></table></figure><p>甚至还可以使用4个字节表示1个字符，其格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11110 xxx10 xxxxxx10 xxxxxx10 xxxxxx</span><br></pre></td></tr></table></figure><p>在UTF-8编码规则中，如果使用2个字节来表示1个字符，实际可用的编码位只有11个二进制位，只能表示2048种不同的意义，所以，使用UTF-8编码表示中文时，需要使用3个字节（3个字节可用的编码位有16位，可以表示65536种不同的意义）！</p><p>由于UTF-8编码使用3个字节就可以表示常规使用的所有字符，一般够用，也有一些罕见的字符并没有收录进来，所以就产生了“使用4个字节表示1个字符”的做法，由于非常罕见，一般并不需要使用，所以，UTF-8编码又被区分为utf8mb3和utf8mb4。</p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis01</title>
      <link href="/2020/07/08/09_MYBATIS_DAY01_1748/"/>
      <url>/2020/07/08/09_MYBATIS_DAY01_1748/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-MyBatis框架的作用"><a href="#1-MyBatis框架的作用" class="headerlink" title="1. MyBatis框架的作用"></a>1. MyBatis框架的作用</h2><p>MyBatis框架的主要作用是简化持久层开发。当使用MyBatis处理数据的增删改查时，只需要定义访问数据的抽象方法，并配置该抽象方法对应的SQL语句即可！</p><p>持久层：解决项目中数据持久化处理的组件。</p><p>数据持久化：将数据永久的保存下来，即将数据存储在硬盘等可以永久保存数据的存储介质中，如果要将数据保存在这些存储介质中，数据需要以文件的形式存在，通常，可以将数据存到文本文档、XML文档、数据库，通常，在没有明确的说明的情况下，讨论数据持久化指的就是使用数据库存取数据。</p><p>内存（RAM，具体表现通常是内存条）：是CPU与其它硬件交换数据的“桥梁”，正在执行的程序和数据都在内存中，一旦断电则数据全部丢失。</p><h2 id="2-创建MyBatis项目"><a href="#2-创建MyBatis项目" class="headerlink" title="2. 创建MyBatis项目"></a>2. 创建MyBatis项目</h2><p>创建Maven项目，Group Id为<code>cn.tedu</code>，Artifact Id为<code>mybatis</code>，Packaging保持为<code>jar</code>即可。</p><p>然后，在项目中添加相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- java version --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- dependency version --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.spring.version</span>&gt;</span>2.0.5<span class="tag">&lt;/<span class="name">mybatis.spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.12<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis：mybatis --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis整合Spring：mybatis-spring --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring：spring-context --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring JDBC：spring-jdbc --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MySQL：mysql-connector-java --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池：druid --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 单元测试：junit --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-连接数据库"><a href="#3-连接数据库" class="headerlink" title="3. 连接数据库"></a>3. 连接数据库</h2><p>首先，登录MySQL控制台，创建<code>tedu_ums</code>数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE tedu_ums;</span><br></pre></td></tr></table></figure><p>然后，在项目中，在<strong>src/main/resources</strong>下创建<strong>jdbc.properties</strong>文件，用于配置连接数据库的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;tedu_ums?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;root</span><br><span class="line">spring.datasource.initialSize&#x3D;2</span><br><span class="line">spring.datasource.maxActive&#x3D;10</span><br></pre></td></tr></table></figure><p>接下来，在项目的<strong>src/main/java</strong>下创建<code>cn.tedu.mybatis</code>包，并在这个包下创建<code>SpringConfig</code>类，在该类中声明属性以读取以上配置值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;spring.datasource.url&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;spring.datasource.driver-class-name&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;spring.datasource.username&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;spring.datasource.password&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;spring.datasource.initialSize&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer initialSize;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;spring.datasource.maxActive&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer maxActive;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，继续添加方法，将以上读取到的信息用于配置<code>DataSource</code>对象，并将该对象交给框架处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前项目添加依赖时</span></span><br><span class="line">    <span class="comment">// 数据库连接池使用的是druid</span></span><br><span class="line">    <span class="comment">// 所以，此处创建DruidDataSource的对象</span></span><br><span class="line">    <span class="comment">// 如果以后改用其它数据库连接池</span></span><br><span class="line">    <span class="comment">// 则创建其它数据库连接池中的对象即可</span></span><br><span class="line">    DruidDataSource ds = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    ds.setUrl(url);</span><br><span class="line">    ds.setDriverClassName(driverClassName);</span><br><span class="line">    ds.setUsername(username);</span><br><span class="line">    ds.setPassword(password);</span><br><span class="line">    ds.setInitialSize(initialSize);</span><br><span class="line">    ds.setMaxActive(maxActive);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用DataSource时，导包必须导javax.sql包中的接口。</p></blockquote><p>接下来，在<strong>src/test/java</strong>下创建<code>cn.tedu.mybatis</code>包，并在这个包中创建<code>Tests</code>测试类，在类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于4.x系列单元测试方法的声明：</span></span><br><span class="line"><span class="comment">// 1. 必须添加@Test注解；</span></span><br><span class="line"><span class="comment">// 2. 必须使用public权限；</span></span><br><span class="line"><span class="comment">// 3. 必须使用void作为返回值类型；</span></span><br><span class="line"><span class="comment">// 4. 必须保持空参数列表（不允许有参数）</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Tests.contextLoads()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext ac</span><br><span class="line">= <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">DataSource dataSource = ac.getBean(<span class="string">"dataSource"</span>, DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">Connection conn = dataSource.getConnection();</span><br><span class="line">System.out.println(conn);</span><br><span class="line"></span><br><span class="line">ac.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以上单元测试可以正常通过，则表示连接数据库的相关配置均正确，后续，框架就可以通过以上配置的对象自动连接到数据库。</p><h2 id="4-创建数据表"><a href="#4-创建数据表" class="headerlink" title="4. 创建数据表"></a>4. 创建数据表</h2><p>在<code>tedu_ums</code>数据库中创建<code>t_user</code>数据表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_user (</span><br><span class="line">id int AUTO_INCREMENT,</span><br><span class="line">    username varchar(20) NOT NULL UNIQUE,</span><br><span class="line">    password varchar(20) NOT NULL,</span><br><span class="line">    age int,</span><br><span class="line">    phone varchar(20),</span><br><span class="line">    email varchar(30),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) DEFAULT CHARSET&#x3D;utf8mb4;</span><br></pre></td></tr></table></figure><h2 id="5-插入数据"><a href="#5-插入数据" class="headerlink" title="5. 插入数据"></a>5. 插入数据</h2><h3 id="5-1-定义抽象方法"><a href="#5-1-定义抽象方法" class="headerlink" title="5.1. 定义抽象方法"></a>5.1. 定义抽象方法</h3><p>当使用MyBatis框架处理增删改查时，抽象方法必须定义在接口中，通常，接口的名称建议使用<code>Mapper</code>作为最后一个单词。</p><p>在<code>cn.tedu.mybatis</code>包中创建<code>UserMapper</code>接口，这个接口就专门用于声明访问“用户”数据表中的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>然后，在接口中声明“插入用户数据”的抽象方法，关于抽象方法的声明：</p><ul><li>【返回值】如果需要执行的数据操作是增、删、改类型的，则使用<code>Integer</code>作为返回值类型，表示受影响的行数，其实，也可以使用<code>void</code>作为返回值类型，表示“不关心受影响的行数”，但是，不建议这么做；如果需要执行的数据操作是查询，则设计为所期望的类型即可，当然，该类型需要能够将查询到的数据封装进去；</li><li>【方法名称】自定义；</li><li>【参数列表】根据需要执行的SQL语句中的参数来决定。</li></ul><p>当需要执行“插入用户数据”操作时，需要执行的SQL语句大致是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t_user (username, password, age, phone, email) VALUES (?,?,?,?,?)</span><br></pre></td></tr></table></figure><p>可以将以上SQL语句中的参数全部声明到抽象方法的参数列表中，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">insert</span><span class="params">(String username, String password, Integer age, String phone, String email)</span></span>;</span><br></pre></td></tr></table></figure><p>或者，也可以将SQL语句中的参数全部声明到某个实体类，然后使用实体类作为抽象方法的参数，例如在<code>cn.tedu.mybatis</code>包下创建<code>User</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String phone;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> phone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.phone = phone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [id="</span> + id + <span class="string">", username="</span> + username + <span class="string">", password="</span> + password + <span class="string">", age="</span> + age + <span class="string">", phone="</span></span><br><span class="line">+ phone + <span class="string">", email="</span> + email + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，设计抽象方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>目前，MyBatis框架并不知道接口文件的位置，就更加无法使用自定义的抽象方法，必须在配置类的声明之前添加<code>@MapperScan</code>注解，以指定接口文件所在的包！</p><h3 id="5-2-配置SQL语句"><a href="#5-2-配置SQL语句" class="headerlink" title="5.2. 配置SQL语句"></a>5.2. 配置SQL语句</h3><p>在接口的抽象方法的声明之前，根据需要执行的SQL语句的种类，选择使用<code>@Insert</code> / <code>@Delete</code> / <code>@Update</code> / <code>@Select</code>这4个当中的某个注解，当前已经添加的抽象方法<code>Integer insert(User user);</code>需要执行的是<code>INSERT</code>类型的SQL语句，则需要使用<code>@Insert</code>注解！</p><p>然后，在注解中，配置字符串类型的参数，该参数就是需要执行的SQL语句，在SQL语句中，所有的参数都使用<code>#{}</code>格式的占位符，在占位符的大括号内是参数<code>User</code>类的属性名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"INSERT INTO t_user (username, password, age, phone, email) VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;phone&#125;, #&#123;email&#125;)"</span>)</span><br><span class="line"><span class="function">Integer <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>最后，还需要在配置类中配置<code>SqlSessionFactoryBean</code>的对象，为该对象设置数据源，使得MyBatis框架能够自动获取数据库连接，并完成数据访问！所以，在<code>SpringConfig</code>类中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">    bean.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在<strong>src/test/java</strong>的<code>cn.tedu.mybatis</code>包下创建<code>UserMapperTests</code>测试类，并测试以上方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext ac</span><br><span class="line">= <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">UserMapper userMapper </span><br><span class="line">= ac.getBean(<span class="string">"userMapper"</span>, UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"spring"</span>);</span><br><span class="line">user.setPassword(<span class="string">"1234"</span>);</span><br><span class="line">user.setAge(<span class="number">26</span>);</span><br><span class="line">user.setPhone(<span class="string">"1380138000"</span>);</span><br><span class="line">user.setEmail(<span class="string">"root@baidu.com"</span>);</span><br><span class="line">Integer rows = userMapper.insert(user);</span><br><span class="line">System.out.println(<span class="string">"rows="</span> + rows);</span><br><span class="line"></span><br><span class="line">ac.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-获取自动编号的ID值"><a href="#5-3-获取自动编号的ID值" class="headerlink" title="5.3. 获取自动编号的ID值"></a>5.3. 获取自动编号的ID值</h3><p>在抽象方法的上方，补充添加<code>@Options</code>注解并进行配置，使得可以获取自动编号的ID值，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"INSERT INTO t_user (username, password, age, phone, email) VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;phone&#125;, #&#123;email&#125;)"</span>)</span><br><span class="line"><span class="meta">@Options</span>(useGeneratedKeys=<span class="keyword">true</span>, keyProperty=<span class="string">"id"</span>)</span><br><span class="line"><span class="function">Integer <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>以上在<code>@Options</code>注解中，配置的<code>useGeneratedKeys=true</code>表示“需要获取自动生成的值”，<code>keyProperty</code>表示将获取到的ID值放到参数对象的<code>id</code>属性中去！</p><h2 id="6-根据id删除用户数据"><a href="#6-根据id删除用户数据" class="headerlink" title="6. 根据id删除用户数据"></a>6. 根据id删除用户数据</h2><p>需要执行的SQL语句大致是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM t_user WHERE id&#x3D;?</span><br></pre></td></tr></table></figure><p>先在<code>UserMapper</code>接口中添加抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>然后，在抽象方法的声明之前添加<code>@Delete</code>注解来配置SQL语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Delete</span>(<span class="string">"DELETE FROM t_user WHERE id=#&#123;id&#125;"</span>)</span><br></pre></td></tr></table></figure><p>最后，编写并执行单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ac</span><br><span class="line">        = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    UserMapper userMapper </span><br><span class="line">        = ac.getBean(<span class="string">"userMapper"</span>, UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Integer id = <span class="number">1</span>;</span><br><span class="line">    Integer rows = userMapper.deleteById(id);</span><br><span class="line">    System.out.println(<span class="string">"rows="</span> + rows);</span><br><span class="line"></span><br><span class="line">    ac.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-将所有用户的密码全部改为某个值"><a href="#7-将所有用户的密码全部改为某个值" class="headerlink" title="7. 将所有用户的密码全部改为某个值"></a>7. 将所有用户的密码全部改为某个值</h2><p>需要执行的SQL语句大致是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t_user SET password&#x3D;?</span><br></pre></td></tr></table></figure><p>先在<code>UserMapper</code>接口中添加抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">updatePassword</span><span class="params">(String password)</span></span>;</span><br></pre></td></tr></table></figure><p>然后，在抽象方法的声明之前添加<code>@Update</code>注解来配置SQL语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update</span>(<span class="string">"UPDATE t_user SET password=#&#123;password&#125;"</span>)</span><br></pre></td></tr></table></figure><p>最后，编写并执行单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"><span class="keyword">private</span> AnnotationConfigApplicationContext ac;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    userMapper = ac.getBean(<span class="string">"userMapper"</span>, UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ac.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String password = <span class="string">"88888888"</span>;</span><br><span class="line">    Integer rows = userMapper.updatePassword(password);</span><br><span class="line">    System.out.println(<span class="string">"rows="</span> + rows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当单元测试经过以上调整后，每个测试方法中都不用再执行<code>doBefore()</code>和<code>doAfter()</code>方法中的代码了，在每次执行<code>@Test</code>注解的测试方法之前，都会自动调用<code>@Before</code>注解的方法，并且，在执行<code>@Test</code>注解的测试方法之后，还会自动调用<code>@After</code>注解的方法！</p><h2 id="8-统计当前用户表中用户的数量"><a href="#8-统计当前用户表中用户的数量" class="headerlink" title="8. 统计当前用户表中用户的数量"></a>8. 统计当前用户表中用户的数量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"SELECT COUNT(*) FROM t_user"</span>)</span><br><span class="line"><span class="function">Integer <span class="title">count</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="9-根据id查询某用户的详情"><a href="#9-根据id查询某用户的详情" class="headerlink" title="9. 根据id查询某用户的详情"></a>9. 根据id查询某用户的详情</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"SELECT * FROM t_user WHERE id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="function">User <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：当查询某1条数据，且没有匹配的查询结果时，将返回<code>null</code>。</p><h2 id="10-查询所有用户的信息"><a href="#10-查询所有用户的信息" class="headerlink" title="10. 查询所有用户的信息"></a>10. 查询所有用户的信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"SELECT * FROM t_user ORDER BY id"</span>)</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC03</title>
      <link href="/2020/07/06/08_SPRINGMVC_DAY03/"/>
      <url>/2020/07/06/08_SPRINGMVC_DAY03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-关于-RequestMapping注解"><a href="#1-关于-RequestMapping注解" class="headerlink" title="1. 关于@RequestMapping注解"></a>1. 关于@RequestMapping注解</h2><p>在控制器中，在处理请求的方法之前添加<code>@RequestMapping</code>注解，可以配置请求路径与处理请求的方法的映射关系！</p><p>在<code>@RequestMapping</code>注解的源代码中有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The primary mapping expressed by this annotation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is an alias for &#123;<span class="doctag">@link</span> #path&#125;. For example,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@RequestMapping</span>("/foo")&#125; is equivalent to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@RequestMapping</span>(path="/foo")&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Supported at the type level as well as at the method level!&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * When used at the type level, all method-level mappings inherit</span></span><br><span class="line"><span class="comment"> * this primary mapping, narrowing it for a specific handler method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: A handler method that is not mapped to any path</span></span><br><span class="line"><span class="comment"> * explicitly is effectively mapped to an empty path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>由于<code>value</code>是默认的属性，所以，平时所使用到的<code>@RequestMapping(&quot;reg.do&quot;)</code>其实配置的就是这个<code>value</code>属性的值！</p><p>它的数据类型是<code>String[]</code>，所以，在配置时，可以同时配置多个路径！例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【显示注册页面】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(&#123;<span class="string">"reg.do"</span>, <span class="string">"register.do"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.reg()"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"register"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则通过<code>reg.do</code>和<code>register.do</code>均可使得<code>reg()</code>方法被执行，而方法的代码是不变的，最终的效果就是这2个路径都可以打开同一个页面！</p><p>在源代码中，还有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The path mapping URIs (e.g. &#123;<span class="doctag">@code</span> "/profile"&#125;).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Ant-style path patterns are also supported (e.g. &#123;<span class="doctag">@code</span> "/profile/**"&#125;).</span></span><br><span class="line"><span class="comment"> * At the method level, relative paths (e.g. &#123;<span class="doctag">@code</span> "edit"&#125;) are supported</span></span><br><span class="line"><span class="comment"> * within the primary mapping expressed at the type level.</span></span><br><span class="line"><span class="comment"> * Path mapping URIs may contain placeholders (e.g. &lt;code&gt;"/$&#123;profile_path&#125;"&lt;/code&gt;).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Supported at the type level as well as at the method level!&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * When used at the type level, all method-level mappings inherit</span></span><br><span class="line"><span class="comment"> * this primary mapping, narrowing it for a specific handler method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: A handler method that is not mapped to any path</span></span><br><span class="line"><span class="comment"> * explicitly is effectively mapped to an empty path.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>结合以上2段源代码，可以看到<code>value</code>属性与<code>path</code>属性是完全相同的！如果需要显式的指定属性名称时，使用<code>path</code>可以更好的表现语义，该属性名称是从4.2版本加入的！</p><p>在源代码还有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The HTTP request methods to map to, narrowing the primary mapping:</span></span><br><span class="line"><span class="comment"> * GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Supported at the type level as well as at the method level!&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * When used at the type level, all method-level mappings inherit</span></span><br><span class="line"><span class="comment"> * this HTTP method restriction (i.e. the type-level restriction</span></span><br><span class="line"><span class="comment"> * gets checked before the handler method is even resolved).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>以上源代码说明在使用<code>@RequestMapping</code>时，可以配置名为<code>method</code>的属性，该属性的值的类型是<code>RequestMethod[]</code>类型，默认值是无。</p><p>该属性的作用是“配置所映射的HTTP请求方式”，如果没有配置该属性，表示“可以通过任何请求方式访问该路径”！如果显式的配置了该属性，则只有配置值对应的请求方式才是允许的，而没有被配置值的请求方式将不被允许！</p><p>例如，将请求方式限制为POST类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"handle_reg.do"</span>, method=RequestMethod.POST)</span><br></pre></td></tr></table></figure><p>如果仍尝试使用GET或其它不被允许的请求方式，将会出现405错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP Status 405 – Method Not Allowed</span><br></pre></td></tr></table></figure><p>并且，还伴随具体的提示信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request method &#39;GET&#39; not supported</span><br></pre></td></tr></table></figure><p>由于<code>method</code>属性的值类型是<code>RequestMethod[]</code>，所以，可以设置为允许多种请求方式，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"login.do"</span>, method=&#123;RequestMethod.GET, RequestMethod.POST&#125;)</span><br></pre></td></tr></table></figure><p>如果需要将请求方式限制为固定的某1种，还可以使用简化后的注解！例如使用<code>@PostMapping</code>注解，就可以将请求方式限制为<code>POST</code>类型，在使用时，只需要配置请求路径即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @RequestMapping(value="handle_reg.do", method=RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"handle_reg.do"</span>)</span><br></pre></td></tr></table></figure><p>在<code>@PostMapping</code>注解的源代码中，关于该注解的声明是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PostMapping &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该注解的声明之前添加了<code>@RequestMapping(method = RequestMethod.POST)</code>就表示当前<code>@PostMapping</code>注解具有<code>@RequestMapping</code>的作用特点且已经将请求方式限制为<code>POST</code>了！</p><p>除此以外，还有<code>@GetMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>、<code>@PatchMapping</code>，均对应某1种请求方式！</p><p><strong>小结：如果需要将请求方式限制为某1种，则应该使用以上这些简化的注解，如果需要同时允许多种不同的请求方式，应该使用<code>@RequestMapping</code>！</strong></p><p>关于<code>@RequestMapping</code>注解，除了添加在处理请求的方法之前，还可以添加在控制器类的声明之前！例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当控制器类的声明之前配置了<code>@RequestMapping(&quot;user&quot;)</code>后，当前类中映射的所有请求路径中都需要添加<code>user</code>这个层级，例如，在没有添加该配置之前时，访问路径是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;springmvc02&#x2F;reg.do</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;springmvc02&#x2F;login.do</span><br></pre></td></tr></table></figure><p>添加了配置之后，访问路径是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;springmvc02&#x2F;user&#x2F;reg.do</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;springmvc02&#x2F;user&#x2F;login.do</span><br></pre></td></tr></table></figure><p><strong>通常，推荐为每一个控制器类的声明之前都添加该注解的配置！</strong></p><p>可以看到 ，SpringMVC框架在处理配置的路径时，会把类之前的<code>@RequestMapping</code>配置值与方法之前的配置值拼接起来作为完整的访问路径，但是，开发人员并不需要考虑配置值的左右两侧的<code>/</code>符号，例如以下配置是等效的：</p><table><thead><tr><th>在控制器类之前的配置</th><th>在方法之前的配置</th></tr></thead><tbody><tr><td><strong>user</strong></td><td><strong>reg.do</strong></td></tr><tr><td>user</td><td>/reg.do</td></tr><tr><td>user/</td><td>reg.do</td></tr><tr><td>user/</td><td>/reg.do</td></tr><tr><td>/user</td><td>reg.do</td></tr><tr><td>/user</td><td>/reg.do</td></tr><tr><td>/user/</td><td>reg.do</td></tr><tr><td>/user/</td><td>/reg.do</td></tr></tbody></table><p>在实际使用时，推荐使用第1种即可！如果使用其它的配置风格也是可以的，但是，在同一个项目中，应该只使用1种风格的配置！</p><h2 id="2-拦截器"><a href="#2-拦截器" class="headerlink" title="2. 拦截器"></a>2. 拦截器</h2><p>拦截器（<code>Interceptor</code>）在SpringMVC框架中可以作用于若干个不同的请求，且经过拦截器的处理后，可以选择对这些请求进行阻止（不允许继续向后续的流程中执行），或选择放行！</p><blockquote><p>注意：拦截器的作用并不一定是”拦“下来就不允许执行了，可能某些拦截器的做法就是”拦“下来后全部放行！</p></blockquote><p>当需要要使用拦截器时，首先，需要自定义类，实现<code>HandlerInterceptor</code>接口，并在重写的方法中添加输出语句，以便于观察方法的执行时间点及执行的先后顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"LoginInterceptor.preHandle()"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"LoginInterceptor.postHandle()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"LoginInterceptor.afterCompletion()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，还需要对拦截器进行配置，关于该配置的写法要求：</p><ul><li>相关的配置需要写在某个类中，这个类需要实现<code>WebMvcConfigurer</code>接口，且在类的声明之前必须添加<code>@Configuration</code>和<code>@EnableWebMvc</code>这2个注解，且这个类的对象必须是初始化类的<code>getServletConfigClasses()</code>方法的返回值；</li><li>在以上类中重写<code>addInterceptors()</code>方法，以配置拦截器。</li></ul><p>例如使用原本存在的<code>SpringMvcConfig</code>为作配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cn.tedu.spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String characterEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">HandlerInterceptor interceptor = <span class="keyword">new</span> LoginInterceptor();</span><br><span class="line"><span class="comment">// 注意：表示拦截器处理的路径时，各路径必须使用 / 作为第1个字符</span></span><br><span class="line">registry.addInterceptor(interceptor).addPathPatterns(<span class="string">"/index.do"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个项目中，允许同时存在若干个拦截器，配置的先后顺序决定了执行顺序，如果某个请求会经过多个拦截器，只有这些拦截器全部都放行，才可以继续向后执行，只要其中任何一个拦截器的处理结果是阻止运行，该请求就不可以向后执行了！</p><p>通过运行效果可以观察到：</p><ul><li>当拦截器中的<code>preHandle()</code>方法返回<code>true</code>时，会行执行拦截器中的<code>preHandle()</code>方法，再执行需要请求的控制器中的方法，再执行拦截器中的<code>postHandle()</code>和<code>afterCompletion()</code>方法；</li><li>当拦截器中的<code>preHandle()</code>方法返回<code>false</code>时，只会执行拦截器中的<code>preHandle()</code>方法，且客户端的浏览器窗口将显示一片空白。</li><li>只有拦截器中的<code>preHandle()</code>方法才是真正意义上的”拦截“方法！</li></ul><p>回到<code>LoginInterceptor</code>类中，重写<code>preHandle()</code>方法以判断阻止或放行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"LoginInterceptor.preHandle()"</span>);</span><br><span class="line">    <span class="comment">// 如果已经登录，则放行，如果未登录，则阻止且重定向到登录界面</span></span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line">    <span class="keyword">if</span> (session.getAttribute(<span class="string">"username"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        String contextPath = request.getContextPath();</span><br><span class="line">        response.sendRedirect(contextPath + <span class="string">"/user/login.do"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于拦截器的配置，首先，每个拦截器都可以配置若干个拦截的路径！关于配置拦截路径时调用的<code>addPathPatterns()</code>方法，其源代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add URL patterns to which the registered interceptor should apply to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InterceptorRegistration <span class="title">addPathPatterns</span><span class="params">(String... patterns)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addPathPatterns(Arrays.asList(patterns));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List-based variant of &#123;<span class="doctag">@link</span> #addPathPatterns(String...)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InterceptorRegistration <span class="title">addPathPatterns</span><span class="params">(List&lt;String&gt; patterns)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.includePatterns.addAll(patterns);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际使用时，可以写成例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry.addInterceptor(interceptor).addPathPatterns(<span class="string">"/index.do"</span>, <span class="string">"/user/password.do"</span>);</span><br></pre></td></tr></table></figure><p>或者写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; pathPatterns = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">pathPatterns.add(<span class="string">"/index.do"</span>);</span><br><span class="line">pathPatterns.add(<span class="string">"/user/password.do"</span>);</span><br><span class="line">registry.addInterceptor(interceptor).addPathPatterns(pathPatterns);</span><br></pre></td></tr></table></figure><p>在配置路径时，还可以使用星号(<code>*</code>)作为通配符，例如，可以将<code>/blog/*</code>配置到拦截路径中，则<code>/blog/delete.do</code>、<code>/blog/edit.do</code>等路径都可以被匹配！</p><p>但是，需要注意的是：1个星号(<code>*</code>)只能表示某层级下的资源，不可以匹配到若干个层级！例如配置为<code>/blog/*</code>时，就无法匹配到<code>/blog/2020/list.do</code>！如果一定匹配若干个层级，必须使用2个连续的星号(<code>**</code>)，例如配置为<code>/blog/**</code>，则可以匹配到<code>/blog/list.do</code>、<code>/blog/2020/list.do</code>、<code>/blog/2020/07/list.do</code>……</p><p>在注册拦截器之后，还可以调用<code>excludePathPatterns()</code>方法添加”排除“的路径，被”排除“的路径将不会被拦截器处理！所以，也可以理解为”例外“或”白名单“，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; pathPatterns = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">pathPatterns.add(<span class="string">"/user/reg.do"</span>);</span><br><span class="line">pathPatterns.add(<span class="string">"/user/handle_reg.do"</span>);</span><br><span class="line">pathPatterns.add(<span class="string">"/user/login.do"</span>);</span><br><span class="line">pathPatterns.add(<span class="string">"/user/handle_login.do"</span>);</span><br><span class="line">registry.addInterceptor(interceptor)</span><br><span class="line">    .addPathPatterns(<span class="string">"/user/**"</span>)</span><br><span class="line">    .excludePathPatterns(pathPatterns);</span><br></pre></td></tr></table></figure><p>注意：在调用方法时，必须先调用<code>addPathPatterns()</code>方法然后再调用<code>excludePathPatterns()</code>方法！</p><h2 id="3-拦截器与过滤器的区别"><a href="#3-拦截器与过滤器的区别" class="headerlink" title="3. 拦截器与过滤器的区别"></a>3. 拦截器与过滤器的区别</h2><p><strong>【相同/相似】</strong></p><p>拦截器与过滤器都是可以作用于若干个不同的请求的，在处理请求之前将执行拦截器或过滤器中的代码，并且，都能够实现放行或阻止的效果，并且，都有”链“的概念，在同一个项目中允许存在若干个拦截器或过滤器，同一个请求需要经历多个拦截器或过滤器，只有这些拦截器或过滤器全部放行，才能向后执行！</p><p><strong>【区别】</strong></p><ul><li>过滤器Filter是Java EE中的组件，则任何Java EE项目都可以使用过滤器，而拦截器Interceptor是SpringMVC框架中的组件，只有使用了SpringMVC框架的Java EE项目才可以使用拦截器，并且，只有被SpringMVC框架处理的请求才可能被拦截器处理，例如将SpringMVC框架处理的路径设置为<code>*.do</code>时，直接访问HTML页面、图片等资源将不会被拦截器处理；</li><li>过滤器Filter是执行在所有Servlet组件之前的，而拦截器Interceptor的第1次执行是在<code>DispatcherServlet</code>之后，且在Controller组件之前的（当然，使用过滤器时，也许是通过Servlet来处理请求的，使用拦截器时，是通过Controller来处理请求的，所以，这2者都是在处理请求之前执行，所以，一般情况下，差异并不明显）；</li><li>过滤器Filter只能配置过滤路径（黑名单），而拦截器Interceptor既可以配置拦截路径（黑名单），又可以配置排除路径（例外，白名单），后者的配置更加灵活！</li></ul><p><strong>【小结】</strong></p><p>通过分析以上区别，可以发现：通过过滤器Filter实现的效果，改为使用拦截器Interceptor基本上都可以实现！同时，拦截器还具备”配置更加灵活“的特点，所以，在绝大部分情况下，应该优先使用拦截器！</p><p>当然，过滤器也具有拦截器无法取代的特点，就是”执行时间点“非常早，它是执行在所有Servlet组件之前的，所以，如果某个需要被”拦“下来执行的任务是非常早期就要执行，则必须使用过滤器！</p><p>例如，SpringMVC框架默认使用的编码是<code>ISO-8859-1</code>，是不支持中文的，所以，使用<code>POST</code>提交的请求参数中，只要存在非ASCII码字符，就会出现乱码，如果需要自定义编码，需要在项目的初始化类中重写<code>getServletFilters()</code>方法，并在该方法中返回SpringMVC框架自带的字符编码过滤器，且设置编码，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Filter[] &#123; <span class="keyword">new</span> CharacterEncodingFilter(<span class="string">"UTF-8"</span>) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-SpringMVC阶段小结"><a href="#4-SpringMVC阶段小结" class="headerlink" title="4. SpringMVC阶段小结"></a>4. SpringMVC阶段小结</h2><ul><li>【理解】SpringMVC框架的作用：解决V-C交互的问题；</li><li>【理解】SpringMVC框架的核心执行流程图；</li><li>【掌握】通过SpringMVC框架接收并处理客户端的请求：<ul><li>SpringMVC项目的搭建：添加<code>spring-webmvc</code>依赖，配置不使用<strong>web.xml</strong>，添加Tomcat环境，创建SpringMVC的配置类，创建初始化项目的类并加载SpringMVC的配置类、设置SpringMVC框架所处理的请求路径；</li><li>创建控制器类：自定义名称，必须放在组件扫描的包或其子孙包中，必须添加<code>@Controller</code>注解；</li><li>创建处理请求的方法：使用<code>@RequestMapping</code>系列注解配置请求路径，使用<code>public</code>访问权限，暂定使用<code>String</code>作为返回值类型，方法名称可以自定义，方法的参数列表可以按需设计。</li></ul></li><li>【掌握】通过SpringMVC框架接收客户端提交的请求参数：<ul><li>将请求参数逐一声明为处理请求的方法的参数；</li><li>将多个请求参数封装到自定义对象中，并将自定义的数据类型声明为处理请求的方法的参数。</li></ul></li><li>【掌握】使用SpringMVC封装转发的数据到视图组件，并且在视图组件显示转发的数据；</li><li>【理解】转发与重定向的区别；</li><li>【掌握】Session的使用原则与使用方式；</li><li>【掌握】拦截器的使用与配置；</li><li>【理解】拦截器与过滤器的区别；</li><li>【掌握】解决POST请求中文乱码的问题；</li><li>【掌握】阅读简单的注解源代码，例如<code>@RequestMapping</code>、<code>@RequestParam</code>等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat中配置去掉项目名</title>
      <link href="/2020/07/06/tomcat%E5%8E%BB%E6%8E%89%E9%A1%B9%E7%9B%AE%E5%90%8D/"/>
      <url>/2020/07/06/tomcat%E5%8E%BB%E6%8E%89%E9%A1%B9%E7%9B%AE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>负载均衡中war放在tomcat中时，访问会带有包名。</p><h5 id="打开tomcat-conf-server-xml-把"><a href="#打开tomcat-conf-server-xml-把" class="headerlink" title="打开tomcat/conf/server.xml,把"></a>打开tomcat/conf/server.xml,把</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context path&#x3D;&quot;&#x2F;&quot; docBase&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;tomcat-8102&#x2F;webapps&#x2F;blog&#x2F;&quot; reloadable&#x3D;&quot;true&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>添加到<code>&lt;Host&gt;&lt;/Host&gt;</code>标签中。</p><p>路径最后一定要加<code>/</code>,刚开始没加居然也可以，但后面又不行，又直接访问到🐱页面去了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC01</title>
      <link href="/2020/07/04/08_SPRINGMVC_DAY01/"/>
      <url>/2020/07/04/08_SPRINGMVC_DAY01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-SpringMVC框架的作用"><a href="#1-SpringMVC框架的作用" class="headerlink" title="1. SpringMVC框架的作用"></a>1. SpringMVC框架的作用</h2><p><strong>MVC</strong> = <strong>M</strong>odel（数据模型） + <strong>V</strong>iew（视图） + <strong>C</strong>ontroller（控制器）</p><p>SpringMVC框架主要解决了接收请求与处理响应的问题，也可以认为是解决了V-C交互的问题，与M其实没有关系。</p><p>在传统的Java EE的开发模式下，可能存在<code>Servlet</code>组件数量太多的问题，会导致项目的管理难度太大，且运行时，会有大量的<code>Servlet</code>对象长期占用内存的问题！</p><p>另外，传统的Java EE开发模式下，数据的处理过程中代码量相对较大，而SpringMVC非常大极度的简化了开发量！</p><h2 id="2-SpringMVC-HelloWorld"><a href="#2-SpringMVC-HelloWorld" class="headerlink" title="2. SpringMVC HelloWorld"></a>2. SpringMVC HelloWorld</h2><h4 id="2-1-案例目标"><a href="#2-1-案例目标" class="headerlink" title="2.1. 案例目标"></a>2.1. 案例目标</h4><p>最终程序运行后，打开浏览器，输入<code>http://localhost:8080/项目名/hello.do</code>即可看到自定义输出的内容。</p><h4 id="2-2-在Eclipse中添加Server"><a href="#2-2-在Eclipse中添加Server" class="headerlink" title="2.2. 在Eclipse中添加Server"></a>2.2. 在Eclipse中添加Server</h4><p>打开Eclipse的<strong>Servers</strong>面板，添加Tomcat，当添加成功后，在Eclipse的项目列表中，会出现<strong>Servers</strong>项目，在需要使用Tomcat时，必须保证该项目是存在且打开的状态。</p><h4 id="2-3-创建项目"><a href="#2-3-创建项目" class="headerlink" title="2.3. 创建项目"></a>2.3. 创建项目</h4><p>创建<strong>Maven Project</strong>，<strong>Group Id</strong>为<code>cn.tedu</code>，<strong>Artifact Id</strong>为<code>springmvc01</code>，<strong>Packaing</strong>必须选择<code>war</code>。</p><p>当项目创建出来后，对项目名称点右键，在项目属性的<strong>Targeted Runtimes</strong>中勾选Tomcat。</p><p>刚刚创建好的项目的<strong>pom.xml</strong>会报错，因为缺少<strong>web.xml</strong>文件，并且<code>&lt;failOnMissingWebXml&gt;</code>节点默认为<code>true</code>，结合指定Java版本的代码，在<strong>pom.xml</strong>中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">failOnMissingWebXml</span>&gt;</span>false<span class="tag">&lt;/<span class="name">failOnMissingWebXml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，还需要在<strong>pom.xml</strong>中添加<code>spring-webmvc</code>的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-创建初始化类"><a href="#2-4-创建初始化类" class="headerlink" title="2.4. 创建初始化类"></a>2.4. 创建初始化类</h4><p>创建<code>cn.tedu.spring</code>包，在这个包中创建<code>SpringMvcConfig</code>配置类，并在这个类上配置组件扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringMvc的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cn.tedu.spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个包中创建<code>SpringMvcInitializer</code>类，作为整个项目的初始化类，该类需要继承自<code>AbstractAnnotationConfigDispatcherServletInitializer</code>类，并重写该类中的抽象方法，在重写的<code>getServletConfigClasses()</code>方法中，返回以上<code>SpringMvcConfig</code>类，在重写的<code>getServletMappings()</code>方法中，返回的字符串数组中配置<code>&quot;*.do&quot;</code>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 项目的初始化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcInitializer</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line"><span class="comment">// 当项目初始化时，会加载当前方法的返回值</span></span><br><span class="line"><span class="comment">// 类似于创建了AnnotationConfigApplicationContext的对象，并且把当前方法的返回值作为构造方法参数</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Class[] &#123; SpringMvcConfig<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line"><span class="comment">// 所有以 .do 为后缀的请求都由SpringMVC框架处理</span></span><br><span class="line"><span class="comment">// 之所以使用 .do 是因为它不是一个正常的扩展名</span></span><br><span class="line"><span class="comment">// 可以与访问普通的文件区分开来</span></span><br><span class="line"><span class="comment">// 也可以换成其它后缀，例如 .action</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"*.do"</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上2个类都可以不必放在<code>cn.tedu.spring</code>包中，但是，应该为这2个类确定一个合理的包名。</p></blockquote><h4 id="2-5-使用控制器接收并处理请求"><a href="#2-5-使用控制器接收并处理请求" class="headerlink" title="2.5. 使用控制器接收并处理请求"></a>2.5. 使用控制器接收并处理请求</h4><p>在组件扫描的<code>cn.tedu.spring</code>包中创建<code>HelloController</code>类，并在类的声明之前添加<code>@Controller</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制器类，SpringMVC框架中的控制器的名称是自定义的，并且，不需要继承自某个类，也不需要实现某个接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在这个中添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @RequestMapping用于配置请求路径</span></span><br><span class="line"><span class="comment">// 后续，当项目运行时，按照这个路径来访问</span></span><br><span class="line"><span class="comment">// 就会导致接下来的方法被执行</span></span><br><span class="line"><span class="comment">// 接下来的方法就相当于Servlet中的service()方法</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello.do"</span>)</span><br><span class="line"><span class="comment">// @ResponseBody表示响应正文</span></span><br><span class="line"><span class="comment">// 会导致接下来的方法的返回值会直接响应到客户端去</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：不要返回中文或中文的标点符号，默认不支持</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, SpringMVC!!!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-SpringMVC框架的核心组件"><a href="#3-SpringMVC框架的核心组件" class="headerlink" title="3. SpringMVC框架的核心组件"></a>3. SpringMVC框架的核心组件</h2><ul><li><code>DispatcherServlet</code>：前端控制器，负责接收所配置的所有请求（假设配置为<code>*.do</code>，则它将接收所有以<code>.do</code>为后缀的请求），并负责分发这些请求；</li><li><code>HandlerMapping</code>：记录了请求路径与处理请求的<code>Controller</code>或其方法的对应关系，</li><li><code>Controller</code>：控制器，负责处理具体的请求，每个项目中可能有若干个<code>Controller</code>组件，每个<code>Controller</code>组件中可以有若干个处理请求的方法；</li><li><code>ModelAndView</code>：控制器处理完请求后得到的结果，该结果可以包含数据与视图名称；</li><li><code>ViewResovler</code>：视图解析器，可以根据视图名称来确定具体的视图组件。</li></ul><h2 id="4-显示html模版页面"><a href="#4-显示html模版页面" class="headerlink" title="4. 显示html模版页面"></a>4. 显示html模版页面</h2><p>先在<strong>src/main/resources</strong>下创建<strong>templates</strong>文件夹，然后，在该文件夹创建<strong>register.html</strong>页面，页面的内容可以自行设计。</p><p>然后，在控制器中，将处理请求的方法之前的<code>@ResponseBody</code>注解去掉，并将方法的返回值改为<code>register</code>（HTML文件的名称），例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【显示注册页面】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"reg.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"register"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在<strong>pom.xml</strong>中添加<code>thymeleaf</code>和<code>thymeleaf-spring4</code>/<code>thymeleaf-spring5</code>的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并在<code>SpringMvcConfig</code>中添加关于<code>ViewResolver</code>的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String characterEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoaderTemplateResolver templateResolver = <span class="keyword">new</span> ClassLoaderTemplateResolver();</span><br><span class="line">    templateResolver.setCharacterEncoding(characterEncoding);</span><br><span class="line">    templateResolver.setCacheable(<span class="keyword">false</span>);</span><br><span class="line">    templateResolver.setTemplateMode(<span class="string">"HTML"</span>);</span><br><span class="line">    templateResolver.setPrefix(<span class="string">"/templates/"</span>); <span class="comment">// 前缀</span></span><br><span class="line">    templateResolver.setSuffix(<span class="string">".html"</span>); <span class="comment">// 后缀</span></span><br><span class="line"></span><br><span class="line">    SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">    templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line"></span><br><span class="line">    ThymeleafViewResolver viewResolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">    viewResolver.setCharacterEncoding(characterEncoding);</span><br><span class="line">    viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上配置中，需要关注的就是配置“前缀”和“后缀”的2条配置！SpringMVC框架在使用以上视图解析器时，会将“前缀”、“控制器方法返回的视图名称”、“后缀”拼接起来，得到具体用于显示的视图组件，以上代码中，拼接起来的值就是<code>/templates/register.html</code>，能够指向所设计的网页文件！当然，也可以采取其它的组件方式，例如“前缀”和“后缀”都配置为空字符串，而方法的返回值直接返回<code>&quot;/templates/register.html&quot;</code>也是可以的！</p><p>另外，以上代码中使用到了<code>ClassLoaderTemplateResolver</code>模版解析器，该模版解析器在工作时，默认会在项目的<strong>src/main/resources</strong>下查找视图组件，所以，视图文件（HTML）文件必须放在这个位置！还可以使用<code>ServletContextTemplateResolver</code>模版解析器，其查找视图组件的位置是在<strong>webapp</strong>下。</p><h2 id="5-接收客户端提交的请求参数"><a href="#5-接收客户端提交的请求参数" class="headerlink" title="5. 接收客户端提交的请求参数"></a>5. 接收客户端提交的请求参数</h2><p>在SpringMVC框架中，将“客户端提交的请求参数”直接声明为“处理请求的方法的参数”即可，甚至，还可以将参数直接声明为所期望的类型，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【处理注册请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_reg.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleReg</span><span class="params">(String username, String password, Integer age, String phone, String email)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleReg()"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"username="</span> + username);</span><br><span class="line">    System.out.println(<span class="string">"password="</span> + password);</span><br><span class="line">    System.out.println(<span class="string">"age="</span> + age);</span><br><span class="line">    System.out.println(<span class="string">"phone="</span> + phone);</span><br><span class="line">    System.out.println(<span class="string">"email="</span> + email);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Over"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-SpringMVC执行流程图"><a href="#6-SpringMVC执行流程图" class="headerlink" title="6.SpringMVC执行流程图"></a>6.SpringMVC执行流程图</h2><p><img src="/img/SpringMVC.png" alt="SpringMVC执行流程图"></p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC02</title>
      <link href="/2020/07/04/08_SPRINGMVC_DAY02/"/>
      <url>/2020/07/04/08_SPRINGMVC_DAY02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-接收客户端提交的请求参数"><a href="#1-接收客户端提交的请求参数" class="headerlink" title="1. 接收客户端提交的请求参数"></a>1. 接收客户端提交的请求参数</h2><h3 id="1-1-使用HttpServletRequest接收请求参数"><a href="#1-1-使用HttpServletRequest接收请求参数" class="headerlink" title="1.1. 使用HttpServletRequest接收请求参数"></a>1.1. 使用HttpServletRequest接收请求参数</h3><p>在处理请求的方法的参数列表中，添加<code>HttpServletRequest</code>类型的参数，在处理请求的过程中，调用该参数对象的<code>getParameter()</code>方法即可获取请求参数；</p><h3 id="1-2-将请求参数设计为方法的参数"><a href="#1-2-将请求参数设计为方法的参数" class="headerlink" title="1.2. 将请求参数设计为方法的参数"></a>1.2. 将请求参数设计为方法的参数</h3><p>可以将客户端提交的请求参数直接声明为处理请求的方法的参数，并且，可以直接将参数声明为期望的数据类型，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【处理注册请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_reg.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleReg</span><span class="params">(String username, String password, Integer age, String phone, String email)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleReg()"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"username="</span> + username);</span><br><span class="line">    System.out.println(<span class="string">"password="</span> + password);</span><br><span class="line">    System.out.println(<span class="string">"age="</span> + age);</span><br><span class="line">    System.out.println(<span class="string">"phone="</span> + phone);</span><br><span class="line">    System.out.println(<span class="string">"email="</span> + email);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Over"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种做法时，必须保证客户端提交的请求参数与服务器端处理请求的方法的参数的名称是一致的！如果名称不一致，默认情况下，则服务器端处理请求的方法中，对应的参数将是<code>null</code>！</p><p>如果服务器端决定不使用方法的参数名作为客户端应该提交的请求参数名称，还可以在方法的参数之前添加<code>@RequestParam</code>注解，以指定参数名，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleReg</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String aaaaa, String password)</span></span><br></pre></td></tr></table></figure><p>按照以上代码中的注解，则客户端必须按照<code>username</code>和<code>password</code>这2个名称来提交请求参数！</p><h2 id="1-3-使用封装的类型接收请求参数"><a href="#1-3-使用封装的类型接收请求参数" class="headerlink" title="1.3. 使用封装的类型接收请求参数"></a>1.3. 使用封装的类型接收请求参数</h2><p>可以事先自定义类，将需要接收的请求参数都声明为这个类的属性，同时，为这些属性生成Set / Get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String phone;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> phone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.phone = phone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [username="</span> + username + <span class="string">", password="</span> + password + <span class="string">", age="</span> + age + <span class="string">", phone="</span> + phone</span><br><span class="line">+ <span class="string">", email="</span> + email + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将自定义的数据类型声明为处理请求的方法的参数即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【处理注册请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_reg.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleReg</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleReg()"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Over"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种做法，应该保证客户端提交的请求参数名称与以上<code>User</code>类中的属性名称相同，且<code>User</code>类中的各属性都有规范名称的Set / Get方法！</p><h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4. 小结"></a>1.4. 小结</h2><p>以上3种方式中，<code>1.1</code>是在任何情况下都不推荐使用的！</p><p>通常，当参数数量较少且固定（数量或意义）时，优先使用<code>1.2</code>的做法；</p><p>当参数数量较多或不固定时，优先使用<code>1.3</code>的做法。</p><p>以上各做法可以综合在一起同时使用！</p><h2 id="2-控制器向模版页面转发数据"><a href="#2-控制器向模版页面转发数据" class="headerlink" title="2. 控制器向模版页面转发数据"></a>2. 控制器向模版页面转发数据</h2><h3 id="2-1-通过HttpServletRequest转发数据"><a href="#2-1-通过HttpServletRequest转发数据" class="headerlink" title="2.1. 通过HttpServletRequest转发数据"></a>2.1. 通过HttpServletRequest转发数据</h3><p>在处理请求的方法的参数列表中添加<code>HttpServletRequest</code>类型的参数，当需要将某些数据显示到页面中时，调用该参数对象的<code>setAttribute(String name, Object value)</code>方法将数据封装到<code>HttpServletRequest</code>请求对象中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【处理登录请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_login.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleLogin</span><span class="params">(String username, String password, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleLogin()"</span>);</span><br><span class="line">    System.out.println(<span class="string">"username="</span> + username);</span><br><span class="line">    System.out.println(<span class="string">"password="</span> + password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设root/1234是正确的用户名/密码</span></span><br><span class="line">    <span class="comment">// 判断用户名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"root"</span>.equals(username)) &#123;</span><br><span class="line">        <span class="comment">// 用户名正确，需要判断密码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"1234"</span>.equals(password)) &#123;</span><br><span class="line">            <span class="comment">// 密码也正确，登录成功</span></span><br><span class="line">            <span class="comment">// 暂不考虑登录成功后的处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录失败，密码错误</span></span><br><span class="line">            String errorMessage = <span class="string">"登录失败，密码错误！"</span>;</span><br><span class="line">            request.setAttribute(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 登录失败，用户名错误</span></span><br><span class="line">        String errorMessage = <span class="string">"登录失败，用户名不存在！"</span>;</span><br><span class="line">        request.setAttribute(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Over."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于当前使用的是<code>Thymeleaf</code>框架，在HTML模版页面中，可以通过<code>Thymeleaf</code>表达式取出在控制器中封装到<code>HttpServletRequest</code>中的参数，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>操作失败！<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-通过ModelMap转发数据"><a href="#2-2-通过ModelMap转发数据" class="headerlink" title="2.2. 通过ModelMap转发数据"></a>2.2. 通过ModelMap转发数据</h2><p>使用<code>ModelMap</code>转发数据的做法与使用<code>HttpServletRequest</code>转发数据几乎相同！例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【处理登录请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_login.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleLogin</span><span class="params">(String username, String password, ModelMap modelMap)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleLogin()"</span>);</span><br><span class="line">    System.out.println(<span class="string">"username="</span> + username);</span><br><span class="line">    System.out.println(<span class="string">"password="</span> + password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设root/1234是正确的用户名/密码</span></span><br><span class="line">    <span class="comment">// 判断用户名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"root"</span>.equals(username)) &#123;</span><br><span class="line">        <span class="comment">// 用户名正确，需要判断密码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"1234"</span>.equals(password)) &#123;</span><br><span class="line">            <span class="comment">// 密码也正确，登录成功</span></span><br><span class="line">            <span class="comment">// 暂不考虑登录成功后的处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录失败，密码错误</span></span><br><span class="line">            String errorMessage = <span class="string">"登录失败，密码错误！！"</span>;</span><br><span class="line">            modelMap.addAttribute(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 登录失败，用户名错误</span></span><br><span class="line">        String errorMessage = <span class="string">"登录失败，用户名不存在！！"</span>;</span><br><span class="line">        modelMap.addAttribute(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Over."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-使用ModelAndView转发数据"><a href="#2-3-使用ModelAndView转发数据" class="headerlink" title="2.3. 使用ModelAndView转发数据"></a>2.3. 使用ModelAndView转发数据</h2><p>将处理请求的方法的返回值类型声明为<code>ModelAndView</code>类型，在方法返回<code>ModelAndView</code>对象之前，必须向该对象中封装视图名称与数据，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【处理登录请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_login.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleLogin</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleLogin()"</span>);</span><br><span class="line">    System.out.println(<span class="string">"username="</span> + username);</span><br><span class="line">    System.out.println(<span class="string">"password="</span> + password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设root/1234是正确的用户名/密码</span></span><br><span class="line">    <span class="comment">// 判断用户名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"root"</span>.equals(username)) &#123;</span><br><span class="line">        <span class="comment">// 用户名正确，需要判断密码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"1234"</span>.equals(password)) &#123;</span><br><span class="line">            <span class="comment">// 密码也正确，登录成功</span></span><br><span class="line">            <span class="comment">// 暂不考虑登录成功后的处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录失败，密码错误</span></span><br><span class="line">            String errorMessage = <span class="string">"MAV:登录失败，密码错误！！"</span>;</span><br><span class="line">            Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            model.put(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">            ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model);</span><br><span class="line">            <span class="keyword">return</span> mav;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 登录失败，用户名错误</span></span><br><span class="line">        String errorMessage = <span class="string">"MAV:登录失败，用户名不存在！！"</span>;</span><br><span class="line">        Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        model.put(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3. 重定向"></a>3. 重定向</h2><p>当处理请求的方法的返回值类型是<code>String</code>类型时，返回<code>&quot;redirect:目标路径&quot;</code>即可实现重定向！</p><blockquote><p>当处理请求的方法的返回值类型是<code>String</code>类型时，如果希望执行转发，可以使用<code>&quot;forward:视图名称&quot;</code>的格式，由于转发是默认的行为，所以直接返回<code>&quot;视图名称&quot;</code>即可，不需要显式的添加<code>forward:</code>前缀。</p></blockquote><p><strong>关于转发与重定向的区别</strong></p><ul><li>转发是服务器内部的行为，具体表现为“控制器将请求转发给视图组件（可以有数据，也可以没有数据）”，对于客户端来说，只发出过1次请求，并且，只知道这1次请求的路径，在客户端的浏览器中，地址栏显示的URL也不会发生变化！同时，由于这是服务器内部的行为，所以，控制器可以向视图组件传递任意数据！从编写代码的角度来看，转发时，需要指定的是视图名称！</li><li>重定向的本质是客户端向服务器第1次发出请求后，服务器响应了302响应码，及目标路径，客户端收到这次响应后，由于响应码是<code>302</code>，会自动发出第2次请求，请求路径（目标）就是第1次请求时服务器端响应的目标路径！所以，总的来说，重定向至少发生了2次请求与响应的交互过程，由于是多次请求，并且，后续的请求目标路径对于客户端来说是已知的，所以，在客户端的浏览器中，地址栏显示的URL会发生变化！同时，由于整个过程是多次请求，由服务器端多个不同的控制器类（同一个控制器，但处理请求的方法不同）进行处理的，会导致在默认情况下，多次处理请求的过程中产生的数据无法共享使用或不便于传递！从编写代码的角度来看，重定向时，需要指定的是目标路径！</li></ul><h2 id="4-使用Session"><a href="#4-使用Session" class="headerlink" title="4. 使用Session"></a>4. 使用Session</h2><p>在处理请求的方法的参数列表中，可以直接添加<code>HttpSession</code>类型的参数，用于访问Session中的数据，添加参数后，在当前方法体中，就可以向Session中存入数据，也可以取出Session的数据，当然，只要存入了数据，在Session的有效期内，视图组件也可以直接获取Session中的数据！</p><p><strong>关于Session的消失：</strong></p><ul><li>服务器关机或重启；</li><li>超时；</li><li>关闭浏览器。</li></ul><p><strong>关于存入到Session中的数据：</strong></p><ul><li>用户身份的唯一标识，例如用户的id、用户名等；</li><li>高频率访问的数据，例如用户名、头像等；</li><li>不便于使用其它技术进行传递或共享的数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring03</title>
      <link href="/2020/07/03/07_SPRING_DAY03/"/>
      <url>/2020/07/03/07_SPRING_DAY03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-通过Environment读取-properties配置文件"><a href="#1-通过Environment读取-properties配置文件" class="headerlink" title="1. 通过Environment读取.properties配置文件"></a>1. 通过Environment读取.properties配置文件</h2><p>假设在<strong>src/main/resources</strong>下存在<strong>jdbc.properties</strong>文件，并且，在该文件中存在若干条配置信息，如果需要读取该文件中的配置信息，可以先创建某个类，在类中声明<code>Environment</code>接口类型的对象，通过自动装配的方式为该类型对象注入值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Environment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.environment = environment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续，需要读取配置文件中的值时，从以上类中获取<code>Environment</code>类型的对象，然后，调用该对象的<code>getProperty()</code>方法即可获取对应的值，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext ac</span><br><span class="line">= <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">JdbcConfig jdbcConfig = ac.getBean(<span class="string">"jdbcConfig"</span>, JdbcConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">Environment environment = jdbcConfig.getEnvironment();</span><br><span class="line">System.out.println(environment.getProperty(<span class="string">"db.url"</span>));</span><br><span class="line">System.out.println(environment.getProperty(<span class="string">"db.driver"</span>));</span><br><span class="line">System.out.println(environment.getProperty(<span class="string">"db.username"</span>));</span><br><span class="line">System.out.println(environment.getProperty(<span class="string">"db.password"</span>));</span><br><span class="line"></span><br><span class="line">ac.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring阶段小结"><a href="#Spring阶段小结" class="headerlink" title="Spring阶段小结"></a>Spring阶段小结</h2><ul><li><p>【理解】Spring框架的主要作用：创建对象，管理对象；</p></li><li><p>【理解】Spring框架深层的作用：解耦；</p></li><li><p>【掌握】通过Spring框架创建对象：</p><ul><li>在某个类中自定义方法，方法的返回值类型就是需要Spring框架创建对象的类型，在方法体中自行返回所需要创建的对象，并且为方法添加<code>@Bean</code>注解，后续，只要Spring框架加载这个类，就会自动调用被添加了<code>@Bean</code>注解的方法，并管理方法所返回的对象。通常，当需要管理的对象所归属的类不是自定义的，必须使用这种做法；</li><li>使得Spring框架执行组件扫描，保证相关的类在组件扫描的包或其子孙包中，并且，类还需要添加<code>@Component</code> / <code>@Controller</code> / <code>@Service</code> / <code>@Repository</code>注解中的某1个。通常，当需要管理的对象所归属的类是自定义的，优先使用这种做法。</li></ul></li><li><p>【掌握】关于组件扫描：可以将组件扫描的包的名称作为字符串参数直接应用于<code>AnnotationConfigApplicationContext</code>类的构造方法中，但是，并不推荐使用这种做法，在实际项目开发时，<code>AnnotationConfigApplicationContext</code>类通常不是开发人员自行创建的，也就没有办法在构造方法中添加包的名称！推荐使用自定义的类作为配置类，并结合<code>@ComponentScan</code>注解来配置组件扫描；</p></li><li><p>【理解】被Spring管理的对象默认是单例的（注意：Spring框架不是设计模式中的单例模式，只是管理对象的方法是这样的），并且，不是懒加载的模式（相当于单例模式中的饿汉式单例的效果）；</p></li><li><p>【了解】使用<code>@Scope</code>和<code>@Lazy</code>调整被Spring管理的对象的作用域；</p></li><li><p>【理解】被Spring管理的对象的生命周期；</p></li><li><p>【了解】配置对象的生命周期：</p><ul><li>如果使用的是添加了<code>@Bean</code>注解的自定义方法返回对象的做法，在<code>@Bean</code>注解中配置<code>initMethod</code>和<code>destroyMethod</code>属性，就可以将类中的方法分别指定为初始化方法和销毁方法；</li><li>如果使用的是组件扫描和组件注解的做法，在类中的初始化方法之前添加<code>@PostConstruct</code>注解，在销毁方法之前添加<code>@PreDestroy</code>方法。</li></ul></li><li><p>【理解】关于Spring框架的DI与IoC：</p><ul><li>DI：Dependency Injection，依赖注入，具体的表现就是“为当前类对象所依赖的某个属性注入值”；</li><li>IoC：Inversion of Control：控制反转，在传统模式下，是由开发人员自行创建对象（例如<code>User user = new User();</code>）且管理对象（例如<code>user.setName(&quot;Jack&quot;);</code>），可以理解为开发人员具有对象的控制权，当使用了Spring框架后，创建对象和管理对象的权力就交给了框架。</li><li>在Spring框架中，DI是一种做法，IoC是最终实现的效果，也就是“Spring框架通过DI这种做法实现了IoC的效果”。</li></ul></li><li><p>【理解】Spring框架自动装配机制的2种装配模式：</p><ul><li><code>byName</code>：根据名称实现自动装配，在这种模式下，要求被装配的属性名称，与被Spring管理的对象的名称（调用<code>getBean()</code>方法给出的参数名）必须相同；</li><li><code>byType</code>：根据类型实现自动装配，在这种模式，要求被装配的属性的类型，在Spring容器中存在匹配类型的对象，当应用这种机制时，必须在Spring容器中保证匹配类型的对象只有1个，否则，将会出现<code>NoUniqueBeanDefinitionException</code>异常；</li></ul></li><li><p>【理解】使用<code>@Autowired</code>和<code>@Resource</code>这2个注解实现自动装配时的区别：</p><ul><li>使用<code>@Autowired</code>尝试自动装配时，Spring框架会先根据<code>byType</code>模式找出所有匹配类型的对象，如果匹配类型的对象的数量为0，也就是没有匹配类型的对象，默认情况下会直接报错（如果明确的配置为<code>@Autowired(required=false)</code>时不会因为装配失败而出错）；如果匹配类型的对象的数量为1，则直接装配；如果匹配类型的对象的数量超过1个（有2个甚至更多个），会尝试<code>byName</code>来装配，如果存在名称匹配的对象，则成功装配，如果名称均不匹配，则装配失败。</li><li>使用<code>@Resource</code>注解尝试自动装配时，其工作原理是先尝试<code>byName</code>装配，如果存在名称匹配的对象，则直接装配，如果没有名称匹配的对象，则尝试<code>byType</code>装配。</li></ul></li><li><p>【掌握】通过Spring框架读取<strong>.properties</strong>配置文件中的信息：</p><ul><li>在组件类的声明之前添加<code>@PropertySource</code>注解，以配置需要读取的<strong>.properties</strong>文件的位置，然后，通过<code>@Value</code>注解将读取到的属性值一一注入到类的属性中，在声明类的属性时，只要该属性的类型是常规类型（例如基本数据类型、<code>String</code>等）或Spring框架自定义的类型，都可以将类的属性直接声明为所期望的类型；</li><li>在组件类的声明之前添加<code>@PropertySource</code>注解，以配置需要读取的<strong>.properties</strong>文件的位置，然后，在类中自定义<code>Environment</code>接口类型的对象，通过<code>@Autowired</code>为该对象自动装配值，后续，调用该对象的<code>getProperty()</code>方法即可获取在<strong>.properties</strong>文件中配置的属性值。</li></ul></li><li><p>【说明】关于Spring AOP会在项目后期再讲。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntellijIDEA快捷使用</title>
      <link href="/2020/07/02/IntellijIDEA%E5%BF%AB%E6%8D%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/02/IntellijIDEA%E5%BF%AB%E6%8D%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Intellij-IDEA快捷使用"><a href="#Intellij-IDEA快捷使用" class="headerlink" title="Intellij IDEA快捷使用"></a>Intellij IDEA快捷使用</h1><h2 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="1. 快捷键"></a>1. 快捷键</h2><h3 id="1-1-按键说明"><a href="#1-1-按键说明" class="headerlink" title="1.1. 按键说明"></a>1.1. 按键说明</h3><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>需要同时按下加号左右两侧的键</td></tr><tr><td>,</td><td>按下逗号左侧的键后，松开，然后按下逗号右侧的键</td></tr><tr><td>Ctrl</td><td>控制键，键盘上标记了<code>Ctrl</code>的键，在Mac键盘上标记为<code>control</code></td></tr><tr><td>Shift</td><td>上档键，键盘上标记了<code>Shift</code>的键</td></tr><tr><td>Alt</td><td>切换键，键盘上标记了<code>Alt</code>的键，在Mac键盘上与<code>Option</code>是同一个键</td></tr><tr><td>Command</td><td>命令键，<strong>Mac键盘独有</strong>，标记了<code>Command</code>的键</td></tr><tr><td>Enter</td><td>回车键，键盘上标记了<code>Enter</code>的键，在Mac键盘上与<code>return</code>是同一个键</td></tr><tr><td>Space</td><td>空格键，键盘上最下方、最大的按键</td></tr><tr><td>Up / Down</td><td>方向上/方向下，通常在键盘上标记了向上/向下的箭头</td></tr></tbody></table><p>某些快捷键可能与操作系统或其它软件的全局快捷键是冲突的，则按下会无效或执行其它命令，可以在Intellij IDEA的设置的<strong>Keymap</strong>中修改为其它按键。</p><p>以下快捷键是Intellij IDEA的默认风格快捷键，如果改成了Eclipse风格或其它风格，请参考所更改的设置。</p><p>标记了<code>[!]</code>是可能存在冲突的快捷键。</p><p>全部快捷键可在Intellij IDEA的设置的<strong>Keymap</strong>中查看，或者查看官方文档：<a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf?_ga=2.5349558.422550521.1580708138-1891300040.1568641704" target="_blank" rel="noopener">https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf?_ga=2.5349558.422550521.1580708138-1891300040.1568641704</a></p><p>在各种编辑软件中都会使用到的快捷键可能不会被列举到以下各表中，例如<code>Ctrl</code> + <code>C</code>表示<strong>复制</strong>，在各种编辑软件中都是这样设计的，就不重复列举了。</p><h3 id="1-2-推荐快捷键"><a href="#1-2-推荐快捷键" class="headerlink" title="1.2. 推荐快捷键"></a>1.2. 推荐快捷键</h3><table><thead><tr><th>Windows / Linux</th><th>Mac OS</th><th>说明</th></tr></thead><tbody><tr><td><strong>[!]</strong> Ctrl + Space</td><td>Ctrl + Space</td><td>基本代码提示</td></tr><tr><td>Ctrl + Shift + Space</td><td>Ctrl + Shift + Space</td><td>智能代码提示</td></tr><tr><td>Shift, Shift</td><td>Shift, Shift</td><td>全局查找</td></tr><tr><td>Alt + Enter</td><td>Option + Enter</td><td>代码错误解决方案</td></tr><tr><td>Alt + Insert</td><td>Command + N 或 Ctrl + Enter</td><td>自动生成Bean方法</td></tr><tr><td>Ctrl + P</td><td>Command + P</td><td>在调用方法时，将光标定位在方法的括号中，提示方法的参数列表</td></tr><tr><td>Shift + F6</td><td>Shift + F6</td><td>重命名，适用于：在文件列表中对文件重命名，在文件内部对类名、属性名、方法名等重命名</td></tr></tbody></table><h3 id="1-3-常规"><a href="#1-3-常规" class="headerlink" title="1.3. 常规"></a>1.3. 常规</h3><table><thead><tr><th>Windows / Linux</th><th>Mac OS</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl + Shift + A</td><td>Command + Shift + A</td><td>查找命令（IDE中可执行的命令，例如运行、调试、重命名等）</td></tr></tbody></table><h3 id="1-4-查找与替换"><a href="#1-4-查找与替换" class="headerlink" title="1.4. 查找与替换"></a>1.4. 查找与替换</h3><table><thead><tr><th>Windows / Linux</th><th>Mac OS</th><th>说明</th></tr></thead><tbody><tr><td>Shift, Shift</td><td>Shift, Shift</td><td>全局查找</td></tr><tr><td>Ctrl + F</td><td>Command + F</td><td>在当前源代码中查找</td></tr><tr><td>Ctrl + R</td><td>Command + R</td><td>在当前源代码中替换</td></tr><tr><td>Ctrl + Shift + F</td><td>Command + Shift + F</td><td>在指定路径（例如整个项目）中查找</td></tr><tr><td>Ctrl + Shift + R</td><td>Command + Shift + R</td><td>在指定路径（例如整个项目）中替换</td></tr></tbody></table><h3 id="1-5-代码编辑"><a href="#1-5-代码编辑" class="headerlink" title="1.5. 代码编辑"></a>1.5. 代码编辑</h3><table><thead><tr><th>Windows / Linux</th><th>Mac OS</th><th>说明</th></tr></thead><tbody><tr><td>[!] Ctrl + Space</td><td>Ctrl + Space</td><td>基本代码提示</td></tr><tr><td>Ctrl + Shift + Space</td><td>Ctrl + Shift + Space</td><td>智能代码提示</td></tr><tr><td>Ctrl + P</td><td>Command + P</td><td>在调用方法时，将光标定位在方法的括号中，提示方法的参数列表</td></tr><tr><td>Alt + Insert</td><td>Command + N 或 Ctrl + Enter</td><td>自动生成Bean方法</td></tr><tr><td>Ctrl + O</td><td>Ctrl + O</td><td>重写方法</td></tr><tr><td>Ctrl + Alt + T</td><td>Command + Option +  T</td><td>使用if/try…catch等代码块包裹当前选中代码</td></tr><tr><td>Ctrl + /</td><td>Command + /</td><td>添加/移除行注释</td></tr><tr><td>Ctrl + Alt + L</td><td>Command + Option + L</td><td>格式化源代码</td></tr><tr><td>Ctrl + Alt + O</td><td>[!] Ctrl + Option + O</td><td>整理import语句</td></tr><tr><td>Ctrl + D</td><td>Command + D</td><td>向下复制代码行</td></tr><tr><td>Ctrl + Y</td><td>Command + Delete</td><td>删除代码行</td></tr><tr><td>Shift + Enter</td><td>Shift + Enter</td><td>新增下一行代码，并将光标定位到下一行代码</td></tr><tr><td>Ctrl + Enter</td><td>Command + Enter</td><td>新增下一行代码，光标在原有位置不变</td></tr><tr><td>Ctrl + +/-</td><td>Command + +/-</td><td>展开或收起类的某个成员，例如方法、内部类等</td></tr><tr><td>Ctrl + Shift + +/-</td><td>Command + Shift + +/-</td><td>展开或收起当前类的所有成员</td></tr><tr><td></td><td>Option + Shift + 上/下</td><td>向上/下移动代码</td></tr><tr><td></td><td>Command + Option + V</td><td>将光标所在位置的常量声明为局部变量</td></tr><tr><td>Ctrl + Shift + V</td><td>Command + Shift + V</td><td>从最近复制过的多项中选择某项来粘贴</td></tr></tbody></table><blockquote><p>也有很多开发者使用<code>Ctrl</code> + <code>X</code>作为<strong>删除代码行</strong>的快捷键，其本质是<strong>剪切</strong>了代码，当然，只要不粘贴，其效果也是相同的。</p></blockquote><h3 id="1-6-管理与导航"><a href="#1-6-管理与导航" class="headerlink" title="1.6. 管理与导航"></a>1.6. 管理与导航</h3><table><thead><tr><th>Windows</th><th>Mac OS</th><th>说明</th></tr></thead><tbody><tr><td>Shift + F6</td><td>Shift + F6</td><td>重命名，适用于：在文件列表中对文件重命名，在文件内部对类名、属性名、方法名等重命名</td></tr><tr><td></td><td>Shift + 单击</td><td>在选项卡处单击以关闭文件</td></tr><tr><td>Ctrl  + F12</td><td>Command + F12</td><td>显示当前文档结构</td></tr><tr><td>Ctrl + U</td><td>Command + U</td><td>打开父类方法，打开父类，需先装光标定位到类名，不适用于打开Object类</td></tr><tr><td>F4 / Ctrl + Enter</td><td>Command + 下 / Ctrl + 单击</td><td>打开光标所在位置的类、属性、方法的声明</td></tr></tbody></table><h2 id="2-快捷输入"><a href="#2-快捷输入" class="headerlink" title="2. 快捷输入"></a>2. 快捷输入</h2><h3 id="2-1-操作方式"><a href="#2-1-操作方式" class="headerlink" title="2.1. 操作方式"></a>2.1. 操作方式</h3><p>可以通过快捷输入简单的内容后按下Enter键，快速完成特定的代码内容，这些内容可以在设置的Editor &gt; Live Templates中查看或调整。</p><h3 id="2-2-常规"><a href="#2-2-常规" class="headerlink" title="2.2. 常规"></a>2.2. 常规</h3><table><thead><tr><th>输入内容</th><th>等效代码</th></tr></thead><tbody><tr><td><code>psvm</code></td><td><code>public static void main(String[] args) {}</code></td></tr><tr><td><code>sout</code></td><td><code>System.out.println();</code></td></tr><tr><td><code>serr</code></td><td><code>System.err.println();</code></td></tr><tr><td><code>soutm</code></td><td><code>System.out.println(&quot;类名.方法名&quot;);</code></td></tr><tr><td><code>soutp</code></td><td><code>System.out.println(&quot;参数1 = [值1], 参数2 = [值2], ... , 参数N = [值N]&quot;);</code></td></tr><tr><td><code>soutv</code></td><td><code>System.out.println(&quot;参数名 = 值&quot;);</code></td></tr></tbody></table><h3 id="2-3-声明静态常量"><a href="#2-3-声明静态常量" class="headerlink" title="2.3. 声明静态常量"></a>2.3. 声明静态常量</h3><table><thead><tr><th>输入内容</th><th>等效代码</th></tr></thead><tbody><tr><td><code>psf</code></td><td><code>public static final</code></td></tr><tr><td><code>prsf</code></td><td><code>private static final</code></td></tr><tr><td><code>psfi</code></td><td><code>public static final int</code></td></tr><tr><td><code>psfs</code></td><td><code>public static final String</code></td></tr></tbody></table><h3 id="2-4-判断"><a href="#2-4-判断" class="headerlink" title="2.4. 判断"></a>2.4. 判断</h3><table><thead><tr><th>输入内容</th><th>等效代码</th></tr></thead><tbody><tr><td><code>ifn</code></td><td><code>if (变量 == null) {}</code></td></tr><tr><td><code>inn</code></td><td><code>if (变量 != null) {}</code></td></tr><tr><td><code>inst</code></td><td><code>if (变量 instanceof 类) {}</code></td></tr></tbody></table><h3 id="2-5-循环与遍历"><a href="#2-5-循环与遍历" class="headerlink" title="2.5. 循环与遍历"></a>2.5. 循环与遍历</h3><table><thead><tr><th>输入内容</th><th>等效代码</th></tr></thead><tbody><tr><td><code>fori</code></td><td><code>for (int 循环变量 = 0; 循环变量 &lt; ; i++) {}</code></td></tr><tr><td><code>itar</code></td><td><code>for (int 循环变量 = 0; 循环变量 &lt; 数组.length(); i++) { 类型 数组元素变量名 = 数组[i]}</code></td></tr><tr><td><code>iter</code></td><td><code>for (元素类型 变量名 : 被遍历对象) {}</code></td></tr><tr><td><code>itli</code></td><td><code>for (int 循环变量 = 0; 循环变量 &lt; 集合.size(); i++) { 类型 集合元素变量名 = 集合.get(循环变量); }</code></td></tr></tbody></table><h2 id="3-快捷输入–高级"><a href="#3-快捷输入–高级" class="headerlink" title="3. 快捷输入–高级"></a>3. 快捷输入–高级</h2><h3 id="3-1-遍历数组或集合对象"><a href="#3-1-遍历数组或集合对象" class="headerlink" title="3.1. 遍历数组或集合对象"></a>3.1. 遍历数组或集合对象</h3><p>假设存在名为<code>numbers</code>的<code>int</code>数组或集合，输入<code>numbers.for</code>即可生成增强for循环代码，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> number : numbers) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-为值声明变量"><a href="#3-2-为值声明变量" class="headerlink" title="3.2. 为值声明变量"></a>3.2. 为值声明变量</h3><p>假设需要声明<code>int</code>类型的变量，其值为<code>1</code>，输入<code>1.var</code>即可生成对应的声明语句，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>整型数字默认生成的变量名是<code>i</code>，代码生成后，可以自行调整。</p><p>同理，假设需要声明<code>String</code>类型的变量，其值为<code>&quot;Java&quot;</code>，输入<code>&quot;Java&quot;.var</code>即可，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String java = <span class="string">"Java"</span>;</span><br></pre></td></tr></table></figure><p>字符串类型默认生成的变量名有多种情况，例如字符串内容是简单字母时，默认变量名就是字母，如果字母首字母是大写的，也会自动使用首字母小写作为默认变量名，字符串类型是汉字时，默认变量名就是汉字，字符串中包含不允许组成变量名的字符时，会使用<code>s</code>或<code>s1</code>、<code>s2</code>等作为默认变量名，当然，在代码生成后，都可以自行调整。</p><p>其它数据类型的值也可以使用同样的方法声明出变量，例如输入<code>new Date().var</code>时，就可以生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure><h3 id="3-3-判断对象是否为空"><a href="#3-3-判断对象是否为空" class="headerlink" title="3.3. 判断对象是否为空"></a>3.3. 判断对象是否为空</h3><p>假设存在名为<code>x</code>的变量，需要判断是否为空，输入<code>x.null</code>然后在提示菜单中选择<code>null</code>一栏回车，即可生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要判断是否非空，则输入<code>x.no</code>后选择<code>notnull</code>一栏并回车，即可生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>未完，某天再续……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring02</title>
      <link href="/2020/07/01/07_SPRING_DAY02/"/>
      <url>/2020/07/01/07_SPRING_DAY02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-组件扫描"><a href="#1-组件扫描" class="headerlink" title="1. 组件扫描"></a>1. 组件扫描</h2><p>首先，必须让Spring扫描组件所在的包，并且，组件类的声明之前必须添加<code>@Component</code>注解！</p><p>其实，除了<code>@Component</code>注解以外，还可以使用以下注解实现同样的效果：</p><ul><li><code>@Controller</code>:推荐添加在<strong>控制器类</strong>之前;</li><li><code>@Service</code>:推荐添加在<strong>业务类</strong>之前;</li><li><code>@Repository</code>:推荐添加在<strong>处理持久层的类</strong>之前.</li></ul><p>以上4个注解在Spring框架的作用领域中，效果是完全相同的，用法也完全相同，只是<strong>语义</strong>不同。</p><p>在使用组件扫描时，还可以自定义某个类，作为配置类，在这个类的声明之前使用<code>@ComponentScan</code>注解来配置组件扫描的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cn.tedu.spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续,程序运行时,就需要加载这个配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ac </span><br><span class="line">    = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>关于组件扫描的包，严格来说，是配置需要被扫描的“<strong>根包</strong>（base package）”，也就是说，在执行扫描时，会扫描所设置的包及其所有子孙包中的所有组件类！当设置为扫描<code>cn.tedu</code>包时，会把<code>cn.tedu.spring</code>甚至<code>cn.tedu.spring.dao</code>这些包中的组件类都扫描到！</p><h2 id="2-关于注解的使用"><a href="#2-关于注解的使用" class="headerlink" title="2. 关于注解的使用"></a>2. 关于注解的使用</h2><p>以<code>@Bean</code>注解为例，其声明是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，注解都是通过<code>@interface</code>声明的！</p><p>在注解的声明之前，还添加了一系列的注解，例如以上的<code>@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})</code>、<code>@Retention(RetentionPolicy.RUNTIME)</code>、<code>@Documented</code>，则表示当前<code>@Bean</code>注解同时具有以上3个注解的特性。也就是说，<code>@Bean</code>注解相当于以上3个注解的同时，还具有自身的特性！</p><p>在<code>@Bean</code>注解内部，还有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Alias for &#123;<span class="doctag">@link</span> #name&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Intended to be used when no other attributes are needed, for example:</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>("customBeanName")&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.3.3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>以上<code>String[] value() default {};</code>有点像接口中的抽象方法，但是，在注解中，这是声明的注解属性！<code>value</code>是属性名称，所以，在使用当前注解时，可以配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=???)</span><br></pre></td></tr></table></figure><p>以上源代码中的<code>String[]</code>看似是抽象方法的返回值，实则是<code>value</code>属性的值的数值类型！所以，可以配置为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;)</span><br></pre></td></tr></table></figure><p>以上源代码中的<code>default {}</code>表示该属性的默认值，所以，以下2段配置是完全等效的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=&#123;&#125;)</span><br></pre></td></tr></table></figure><p>在配置注解属性时，如果属性名称是<code>value</code>，它是默认的属性，在配置时，可以不用显式的写出<code>value=</code>部分，也就是说，以下2段配置是完全等效的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;)</span><br></pre></td></tr></table></figure><p>在配置注解属性时，如果属性的值的类型是数组类型，但是，当前只需要配置1个值时，可以不用写成数组格式，只需要写成数组元素的格式即可！也就是说，以下2段配置是完全等效的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(&#123;<span class="string">"a"</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"a"</span>)</span><br></pre></td></tr></table></figure><p>所以，总的来说，关于<code>@Bean</code>注解的<code>value</code>属性，如果需要配置的值是<code>&quot;user&quot;</code>，则以下4段代码都是完全等效的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"user"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(&#123;<span class="string">"user"</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=<span class="string">"user"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=&#123;<span class="string">"user"</span>&#125;)</span><br></pre></td></tr></table></figure><p>在以上源代码中，注释中还标明了<code>@since 4.3.3</code>，表示该属性从Spring框架4.3.3版本开始才加入的，如果当前使用的环境改为4.3.3以下的版本，将导致该属性不可用，因为在更低的版本中，根本就没有这个属性，甚至可能连个注解本身都不存在！</p><p>在以上源代码中，在<code>value</code>属性的声明之前还添加了<code>@AliasFor(&quot;name&quot;)</code>注解，表示当前<code>value</code>属性另有<strong>别名</strong>为<code>name</code>，所以，在<code>@Bean</code>注解的源代码中，还有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The name of this bean, or if several names, a primary bean name plus aliases.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If left unspecified, the name of the bean is the name of the annotated method.</span></span><br><span class="line"><span class="comment"> * If specified, the method name is ignored.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The bean name and aliases may also be configured via the &#123;<span class="doctag">@link</span> #value&#125;</span></span><br><span class="line"><span class="comment"> * attribute if no other attributes are declared.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>则在<code>@Bean</code>注解中，<code>name</code>和<code>value</code>这2个注解是完全等效的！</p><p>之所以存在2个完全等效的属性，是因为：</p><ul><li><code>value</code>属性是默认的，在配置时可以不必显式的写出<code>value=</code>部分，配置时更加简单；</li><li><code>name</code>属性表现的语义更好，更易于根据源代码读懂程序的意思，在其它注解中，也可能存在与<code>value</code> 等效的属性。</li></ul><p>需要注意的是：在配置注解中的属性时，如果需要配置的是<code>value</code>属性的值，可以不用显式的写出<code>value=</code>部分，<strong>前提是当前注解只配置<code>value</code>这1个属性</strong>！如果需要配置多个属性，则必须写出每一个属性名，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=<span class="string">"user"</span>, initMethod=<span class="string">"init"</span>)</span><br></pre></td></tr></table></figure><p>而不能写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"user"</span>, initMethod=<span class="string">"init"</span>)<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h2 id="3-使用组件扫描后配置作用域与生命周期"><a href="#3-使用组件扫描后配置作用域与生命周期" class="headerlink" title="3. 使用组件扫描后配置作用域与生命周期"></a>3. 使用组件扫描后配置作用域与生命周期</h2><p>在类的声明之前，添加<code>@Scope(&quot;prototype&quot;)</code>即可将当前类配置为“非单例”的对象！例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单例的情况下，在类的声明之前添加<code>@Lazy</code>注解，就可以将对象配置为“懒加载”的模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要配置当前类中的生命周期的处理，首先，还是需要在类中自定义2个方法，分别表示“初始化方法”和“销毁方法”，然后，在初始化方法之前添加<code>@PostConstruct</code>注解，在销毁方法之前添加<code>@PreDestroy</code>注解，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"User.User()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"User.init()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"User.destroy()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：以上2个注解并不是Spring的注解，如果JRE环境版本太低，将无法识别以上2个注解，需要调整当前项目的JRE环境！</p><h2 id="4-关于Spring管理对象的小结"><a href="#4-关于Spring管理对象的小结" class="headerlink" title="4. 关于Spring管理对象的小结"></a>4. 关于Spring管理对象的小结</h2><p>如果需要Spring管理某个类的对象，可以：</p><ul><li>自定义方法，将方法的返回值类型设置为期望管理的类型，并在方法中返回匹配类型的对象，最后，在方法的声明之前添加<code>@Bean</code>注解；</li><li>设置组件扫描的包，并在类的声明之前添加<code>@Component</code> / <code>@Controller</code> / <code>@Service</code> / <code>@Repository</code>这4个注解中的某1个。</li></ul><p>在实际使用时，大多采取第2种做法，但是，如果需要Spring管理的类并<strong>不是自定义的类</strong>，就只能采取第1种做法！</p><h2 id="5-关于Spring的解耦"><a href="#5-关于Spring的解耦" class="headerlink" title="5. 关于Spring的解耦"></a>5. 关于Spring的解耦</h2><p>在没有使用Spring框架的情况下，在项目中，各组件之间是存在依赖关系的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理用户登录请求的Servlet组件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserJdbcDao userDao = <span class="keyword">new</span> UserJdbcDao();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理用户数据增删改查的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserJdbcDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过JDBC技术实现数据查询，判断用户名与密码是否正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就体现了类与类之前的<strong>依赖</strong>关系，具体表现就是<code>UserLoginServlet</code>是依赖于<code>UserJdbcDao</code>的！</p><p>如果直接依赖于某个类，将会导致<strong>耦合度过高</strong>的问题！</p><p>假设在<code>UserJdbcDao</code>中，是通过原生的JDBC技术实现数据访问的，后续，需要改为使用MyBatis框架技术来实现，则可能创建<code>UserMybatisDao</code>类，用于取代<code>UserJdbcDao</code>类！</p><p>如果需要替换，则项目中原有的以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UserJdbcDao userDao = <span class="keyword">new</span> UserJdbcDao();</span><br></pre></td></tr></table></figure><p>全部需要替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UserMybatisDao userDao = <span class="keyword">new</span> UserMybatisDao();</span><br></pre></td></tr></table></figure><p>这种<strong>替换时需要调整大量原有代码</strong>的问题，就是<strong>高耦合</strong>的问题，我们希望的目标是<strong>低耦合</strong>，将原有<strong>高耦合</strong>的项目调整为<strong>低耦合</strong>的状态，就是<strong>解耦</strong>的做法！</p><p>可以将处理用户数据增删改查的相关操作声明在接口中，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，各个处理用户数据增删改查的类都去实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserJdbcDao</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过JDBC实现处理用户登录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMybatisDao</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过MyBatis框架技术实现处理用户登录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续，在各个Servlet组件中，就可以声明为接口类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserMybatisDao();</span><br></pre></td></tr></table></figure><p>通过以上代码调整，就可以使得Servlet组件<strong>依赖于接口</strong>，而不再是<strong>依赖于类</strong>，从而实现了解耦！</p><p>另外，还可以通过设计模式中的工厂模式来生产对象，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserMybatisDao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有了以上工厂后，原本在Servlet组件中声明持久层对象的代码就可以再调整为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao = UserDaoFactory.newInstance();</span><br></pre></td></tr></table></figure><p>至此，在项目中到底是使用<code>UserJdbcDao</code>还是使用<code>UserMybatisDao</code>，在以上代码都不会体现出来了，也就意味着当需要切换/替换时，以上代码是不需要修改的，而是修改<code>UserDaoFactory</code>工厂类的方法的返回值这1处即可！</p><p>所以，通过定义接口和创建工厂类就可以实现解耦，但是，在实际项目开发时，不可能为每一个组件都创建专门的工厂类，而Spring框架就可以当作是一个庞大的工厂，开发人员可以通过Spring框架的使用约定，将某些类的对象交给Spring框架进行管理，后续，在具体使用过程中，就不必自行创建对象，而是<strong>获取</strong>对象即可！</p><h2 id="6-自动装配"><a href="#6-自动装配" class="headerlink" title="6. 自动装配"></a>6. 自动装配</h2><p>在Spring框架的应用中，可以为需要被Spring自动赋值的属性添加<code>@Autowired</code>，则Spring框架会从Spring容器中找出匹配的值，并自动完成赋值！这就是Spring框架的自动装配机制！</p><p>当Spring尝试为某个属性实现自动装配时，采取的模式主要有：</p><ul><li><code>byName</code>：根据名称实现自动装配，在这种模式下，要求被装配的属性名称，与被Spring管理的对象的名称（调用<code>getBean()</code>方法给出的参数名）必须相同；</li><li><code>byType</code>：根据类型实现自动装配，在这种模式，要求被装配的属性的类型，在Spring容器中存在匹配类型的对象，当应用这种机制时，必须在Spring容器中保证匹配类型的对象只有1个，否则，将会出现<code>NoUniqueBeanDefinitionException</code>异常；</li></ul><p>当使用<code>@Autowired</code>尝试自动装配时，Spring框架会先根据<code>byType</code>模式找出所有匹配类型的对象，如果匹配类型的对象的数量为0，也就是没有匹配类型的对象，默认情况下会直接报错，提示信息例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;cn.tedu.spring.UserDao&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required&#x3D;true)&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果使用<code>@Autowired</code>时明确的配置为<code>@Autowired(required=false)</code>，当没有匹配类型的对象时，也不会因为装配失败而报错！</p></blockquote><p>如果匹配类型的对象的数量为1，则直接装配；</p><p>如果匹配类型的对象的数量超过1个（有2个甚至更多个），会尝试<code>byName</code>来装配，如果存在名称匹配的对象，则成功装配，如果名称均不匹配，则装配失败，会提示如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;cn.tedu.spring.UserDao&#39; available: expected single matching bean but found 2: userJdbcDao,userMybatisDao</span><br></pre></td></tr></table></figure><p>当需要自动装配时，除了使用<code>@Autowired</code>注解以外，还可以使用<code>@Resource</code>注解！</p><p>当使用<code>@Resource</code>注解尝试自动装配时，其工作原理是先尝试<code>byName</code>装配，如果存在名称匹配的对象，则直接装配，如果没有名称匹配的对象，则尝试<code>byType</code>装配。</p><p>另外，如果某个方法是被Spring调用的，还可以将需要装配的对象设置为方法的参数（不需要添加注解即可正常使用），Spring也可以实现方法参数的自动装配！例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(UserDao userDao)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="7-通过Spring框架读取-properties文件"><a href="#7-通过Spring框架读取-properties文件" class="headerlink" title="7. 通过Spring框架读取.properties文件"></a>7. 通过Spring框架读取.properties文件</h2><p>首先，在案例的<strong>src/main/resources</strong>下创建<strong>jdbc.properties</strong>文件，并且，在文件中，添加一些自定义的配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db_name</span><br><span class="line">driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">username&#x3D;root</span><br><span class="line">password&#x3D;1234</span><br></pre></td></tr></table></figure><blockquote><p>本次案例的目标是读取以上文件的信息，并不用于真实的连接某个数据库，所以，各属性的值可以不是真正使用的值！</p></blockquote><p>如果要读取以上信息，可以将这些信息都读取到某个类的各个属性中去，则先创建一个类，并在类中声明4个属性（与以上<strong>jdbc.properties</strong>文件中的配置信息的数量保持一致）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="keyword">private</span> String driver;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在类的声明之前，通过<code>@PropertySource</code>配置需要读取的配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br></pre></td></tr></table></figure><p>然后，在各个属性的声明之前，通过<code>@Value</code>注解读取配置信息中的值，并注入到属性中，其基本格式是<code>@Value(&quot;${配置文件中的属性名称}&quot;)</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;url&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;driver&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String driver;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;username&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;password&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"JdbcConfig [url="</span> + url + <span class="string">", driver="</span> + driver + <span class="string">", username="</span> + username + <span class="string">", password="</span> + password</span><br><span class="line">+ <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于期望的是由Spring读取配置文件，并为以上类的各个属性赋值，所以，以上<code>JdbcConfig</code>应该是被Spring管理的！所以，先使用一个类来配置组件扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cn.tedu.spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在<code>JdbcConfig</code>类的声明之前添加<code>@Component</code>注解即可！</p><p><strong>注意：在Windows操作系统中，如果配置文件中的属性名是<code>username</code>，则最终注入属性的值将不是配置文件中的值，而是当前登录Windows操作系统的用户名，为了避免出现此类问题，建议在配置文件中，每个属性的名称之前都添加一些自定义的前缀。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring01</title>
      <link href="/2020/07/01/07_SPRING_DAY01/"/>
      <url>/2020/07/01/07_SPRING_DAY01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="2-Spring框架的作用"><a href="#2-Spring框架的作用" class="headerlink" title="2. Spring框架的作用"></a>2. Spring框架的作用</h2><p>Spring框架的主要作用是创建对象和管理对象。</p><p>创建对象：类似于<code>User user = new User();</code></p><p>管理对象：随时可以通过Spring框架获取对象，甚至Spring框架还能够帮我们为对象的属性进行赋值等。</p><h2 id="3-通过Spring框架创建对象，并获取对象"><a href="#3-通过Spring框架创建对象，并获取对象" class="headerlink" title="3. 通过Spring框架创建对象，并获取对象"></a>3. 通过Spring框架创建对象，并获取对象</h2><p>在Eclipse中创建<strong>Maven Project</strong>，在创建过程中勾上<strong>Create a simple project</strong>，<strong>Group Id</strong>填为<code>cn.tedu</code>，<strong>Artifact Id</strong>填为<code>spring01</code>。</p><blockquote><p>如果某个项目不会被其它项目所使用，只需要保证自身能独立运行，其实<strong>Group Id</strong>和<strong>Artifact Id</strong>的值是多少，并不重要。</p></blockquote><p>创建成功后，先在<strong>pom.xml</strong>中添加以上配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，对项目名称点击鼠标右键，选择<strong>Maven</strong> &gt; <strong>Update Project</strong>以更新Maven，则当前环境会使用Java 1.8。</p><p>接下来，需要在<strong>pom.xml</strong>中添加Spring框架所需的<code>spring-context</code>依赖的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要Spring管理某个类的对象，可以通过自定义的类进行配置！</p><p>例如存在需求：使得Spring框架管理<code>Date</code>类的对象！</p><p>先在项目的<code>cn.tedu.spring</code>包中创建<code>Beans</code>类，并且，在这个类中自定义方法，方法的返回值类型必须是<code>Date</code>，然后，自行在方法体中创建出<code>Date</code>对象并返回即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beans</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">aaa</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上使用的包名是自定义，并不是强制要求。</p><p>以上使用的类名是自定义，并不是强制要求。</p></blockquote><p>关于以上自定义的方法：</p><ul><li>应该使用<code>public</code>权限；</li><li>返回值类型是需要Spring管理的对象所归属的类型；</li><li>方法名称可以自定义；</li><li>参数列表暂时为空；</li><li>必须添加<code>@Bean</code>注解。</li></ul><p>然后，就可以创建一个用于运行的类，加载以上类，并获取对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1. 加载配置类，获取Spring容器</span></span><br><span class="line">AnnotationConfigApplicationContext ac</span><br><span class="line">= <span class="keyword">new</span> AnnotationConfigApplicationContext(Beans<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从Spring容器中获取对象</span></span><br><span class="line">Date date = (Date) ac.getBean(<span class="string">"aaa"</span>); <span class="comment">// getBean()方法的参数，就是配置对象的方法的名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 测试</span></span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 关闭</span></span><br><span class="line">ac.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，就可以看到输出的对象！</p><p>在以上<code>Beans</code>类中，配置对象的方法名是<code>aaa</code>，在运行的<code>Demo</code>类中，调用<code>getBean()</code>方法的参数也必须是<code>&quot;aaa&quot;</code>，名称必须保持一致！</p><p>通过，获取某个值的方法的名称都应该是<code>getXxx</code>，所以，以上<code>Beans</code>类中的方法应该改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，一旦将方法名改成了<code>getDate</code>，运行时，调用的<code>getBean()</code>方法的参数也应该改成<code>getDate</code>，例如改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = (Date) ac.getBean(<span class="string">"getDate"</span>);</span><br></pre></td></tr></table></figure><p>很显然，这个<code>getDate</code>表示的是一个<strong>名称</strong>，而名称应该使用名词，而不应该使用动词作为前缀！</p><p>如果要解决这个问题，可以在<code>@Bean</code>注解中配置参数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"date"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续，在运行时，调用<code>getBean()</code>方法的参数就是<code>@Bean</code>注解中配置的值，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = (Date) ac.getBean(<span class="string">"date"</span>);</span><br></pre></td></tr></table></figure><p><strong>小结：在运行时，调用的<code>getBean()</code>方法的参数值，默认情况下，是配置对象的方法的名称，如果配置对象的方法的<code>@Bean</code>注解添加了参数，则<code>getBean()</code>方法的参数就是<code>@Bean</code>注解中的参数！</strong></p><p><strong>其实，Spring推荐直接使用名词作为以上配置对象的方法名称，即推荐使用<code>date</code>作为方法名，而不是<code>getDate</code>作为方法名！该名词将用于<code>getBean()</code>方法的参数，毕竟这个方法定义好了以后，是由Spring框架去调用了，开发人员不需要自行调用该方法，为了简化代码的同时还保证<code>getBean()</code>代码的语义，推荐使用名词作为方法名称！</strong></p><h2 id="4-由Spring管理的对象的作用域"><a href="#4-由Spring管理的对象的作用域" class="headerlink" title="4. 由Spring管理的对象的作用域"></a>4. 由Spring管理的对象的作用域</h2><p>由Spring管理的对象，在默认情况下，都是单例的！如果在配置对象的方法之前，补充添加<code>@Scope</code>注解，且注解参数配置为<code>prototype</code>时，就不是单例的了！例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：Spring与单例模式是两个不同的概念！</p><p>当需要同时使用多个注解时，各注解不区分先后顺序。</p></blockquote><p>由Spring管理的对象，在单例的情况下，默认是饿汉式的！如果希望调整为懒汉式的，则在配置对象方法的方法之前补充添加<code>@Lazy</code>注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-由Spring管理的对象的生命周期"><a href="#5-由Spring管理的对象的生命周期" class="headerlink" title="5. 由Spring管理的对象的生命周期"></a>5. 由Spring管理的对象的生命周期</h2><p>生命周期：某个对象从创建到最终销毁会经历的历程！</p><p>通常，需要讨论生命周期时，对应的数据类型的对象都不是由开发人员自行维护的！</p><p>被容器维护的对象，都是由容器创建对象，并在适当的时候调用其中的某些方法的！而开发人员需要做的就是“确定满足某条件的时候应该执行什么任务”！也就是说，“容器决定什么时候执行，开发人员决定执行时做什么”。</p><p>学习生命周期的意义就是“知道在什么时候需要做什么事情”！</p><p>以<code>Servlet</code>为例，其生命周期中会有几个特殊的方法，在特定的情况下会被调用，这些就称之为生命周期方法：</p><ul><li><code>init()</code>：当<code>Servlet</code>被创建对象后，立即执行，且只执行1次，该方法适合编写一些初始化相关的代码；</li><li><code>service()</code>：当接收到匹配的请求后会被调用，接收到多少次请求，就执行多少次该方法；</li><li><code>destroy()</code>：当<code>Servlet</code>对象即将被销毁之前执行，且只执行1次，该方法适合编写一些与结束相关的代码，例如关闭等等。</li></ul><p>当使用Spring框架后，某些类的对象交给Spring框架来管理了，那么，这些对象在什么时候被创建、什么时候被销毁，及创建过程和销毁过程中需要执行某些代码，对于开发人员来说，一定程度上是不可控的！</p><p>Spring框架允许用户在类中自定义最多2个方法，分别表示“初始化方法”和“销毁方法”，并且，Spring框架会在创建对象之后自动调用初始化方法，会在销毁对象之前调用销毁方法！关于方法的定义：</p><ul><li>访问权限：应该使用<code>public</code>权限；</li><li>返回值类型：使用<code>void</code>；</li><li>方法名称：自定义；</li><li>参数列表：空。</li></ul><p>例如，在<code>User</code>类中自定义2个生命周期方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"User.init()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"User.destroy()"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在配置对象的方法之前的<code>@Bean</code>注解中配置这2个方法作为生命周期方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>, destroyMethod=<span class="string">"destroy"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-通过组件扫描使得Spring管理类的对象"><a href="#6-通过组件扫描使得Spring管理类的对象" class="headerlink" title="6. 通过组件扫描使得Spring管理类的对象"></a>6. 通过组件扫描使得Spring管理类的对象</h2><p>假设存在<code>User</code>类，需要被Spring框架创建并管理对象，则，必须先明确<code>User</code>类所在的包，然后，在用于运行的类<code>Demo</code>中，在<code>AnnotationConfigApplicationContext</code>的构造方法中，将包名作为构造方法的参数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ac </span><br><span class="line">    = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"cn.tedu.spring"</span>);</span><br></pre></td></tr></table></figure><p>以上代码则表示“<strong>组件扫描</strong>”，当执行时，Spring框架会扫描指定的包中所有的内容，并且，自动创建各<strong>组件</strong>的对象并进行管理！</p><p>当然，并不是所有的类都是“<strong>组件</strong>”，如果要标识某个类是“组件”，必须在类的声明之前添加<code>@Component</code>注解！例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续，从Spring容器中获取对象时，默认情况下，将类名的首字母改为小写，作为Bean的名称，用于调用<code>getBean()</code>方法的参数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = ac.getBean(<span class="string">"user"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>关于Bean的名称，如果类名<strong>首字母是大写，且第2个字母是小写</strong>，例如<code>User</code>或<code>Student</code>，则Bean的名称就是将首字母改为小写即可，也就是<code>user</code>或<code>student</code>！如果不满足该条件，例如类名是<code>teacher</code>或<code>IUserDao</code>，则Bean的名称就是类的名称！</p></blockquote><p>当然，Spring框架也允许自定义Bean的名称，只要将自定义的名称配置在<code>@Component</code>注解参数中即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"stu"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则以上类的对象被Spring管理时，Bean的名称就是<code>&quot;stu&quot;</code>，后续，调用<code>getBean()</code>方法获取对象时，也必须使用这个名称来获取对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu = ac.getBean(<span class="string">"stu"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="【附】1-单例模式"><a href="#【附】1-单例模式" class="headerlink" title="【附】1. 单例模式"></a>【附】1. 单例模式</h2><p>单例模式，是设计模式中的一种。</p><p>单例模式，其特点是：被设计为单例的类型，在同一时间内，该类型的对象只会存在1个！</p><p>假设存在<code>King</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>作为一个普通的类，是可以在类的外部随意创建对象的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">King k1 = <span class="keyword">new</span> King();</span><br><span class="line">King k2 = <span class="keyword">new</span> King();</span><br><span class="line">King k3 = <span class="keyword">new</span> King();</span><br></pre></td></tr></table></figure><p>因为在<code>King</code>类中，没有声明构造方法，则编译器会自动的添加默认构造方法，也就是公有的、无参数的构造方法，所以，在类的外部才可以随意创建对象！以上代码中就创建了3个<code>King</code>类型的对象！</p><p>如果要实现单例，首先，就不能允许随意创建对象，可以显式的添加构造方法，并将其私有化，避免外部随意访问，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦显式的添加了构造方法，编译器就不会再自动添加构造方法了，则在类的外部，将不可以再执行<code>King k1 = new King();</code>这类的代码了！</p><p>使用了私有的构造方法，并不影响在类的内部使用该构造方法，为了保证在类的外部依然可以获取类的对象，则可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> King();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，为了保证“多次获取时，获取到的都是同一个对象”，则不能反复在方法中<strong>创建</strong>对象，而是改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> King king = <span class="keyword">new</span> King();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为这样以后，无论执行多少次<code>getInstance()</code>方法，该方法返回的都是同一个<code>king</code>变量，而该变量的值只是在类被加载时赋值了1次而已，就实现了单例的效果！</p><p>当然，以上代码是矛盾的！因为，如果要调用<code>getInstance()</code>方法，必须先有<code>King</code>类型的对象，而得到<code>King</code>类型对象的唯一途径就是调用<code>getInstance()</code>方法！也就是说：不调用<code>getInstance()</code>方法就无法得到对象，但是，调用方法之前又必须有对象！</p><p>为了解决这个问题，可以为<code>getInstance()</code>方法添加<code>static</code>修饰符，则通过<code>类名.方法名()</code>的格式就可以调用方法了，不需要事先获取对象！同时，基于“被<code>static</code>修饰的成员不可以直接访问没被<code>static</code>修饰的成员”的原则，所以，全局的<code>private King king = new King();</code>也需要添加<code>static</code>修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king = <span class="keyword">new</span> King();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，简单的单例模式代码就完成了，后续，需要获取<code>King</code>类型的对象时，只能通过<code>King.getInstance()</code>得到对象，而该方法每次返回的都是同一个对象！</p><p>严格来说，以上单例模式的设计是“饿汉式”的，可以看到，在类被加载时，就直接创建了<code>King</code>类的对象，此时，也许并不需要获取对象，但是，也创建好了 ，后续，当需要对象时，直接获取即可！另外，还有“懒汉式”的单例模式，其特点就是“不到逼不得已，不创建对象”！其基础代码例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123;</span><br><span class="line">            king = <span class="keyword">new</span> King();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是多线程不安全的！为了解决这个问题，可以将以上代码块添加互斥锁，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="string">"java"</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123;</span><br><span class="line">                king = <span class="keyword">new</span> King();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦添加了锁，就会导致每次调用<code>getInstance()</code>方法时都会先锁定代码再执行，效率偏低，为了解决该问题，还可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123; <span class="comment">// 判断是否有必须加锁，如果没有该判断，则效率可能偏低</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="string">"java"</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123; <span class="comment">// 判断是否有必须创建对象，如果没有该判断，则可能创建多个对象</span></span><br><span class="line">                    king = <span class="keyword">new</span> King();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，就是完整的懒汉式的单例模式！</p><p><strong>小结：单例模式的特点就是“单一实例”，表现为“同一时间内，某个类的对象只有1个”！单例模式分为“饿汉式”和“懒汉式”这2种，前者是“早早的创建出对象，随时可以获取”，后者是“不到逼不得已不会创建对象”！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客项目</title>
      <link href="/2020/06/29/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/"/>
      <url>/2020/06/29/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="博客项目"><a href="#博客项目" class="headerlink" title="博客项目"></a>博客项目</h1><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ol><li><p>Nginx反向代理、动静分离</p></li><li><p>部署在服务器上并添加SSL证书</p></li><li><p>使用手机号登录注册</p></li><li><p>使用QQ号登录注册</p></li><li><p>发布博客支持emoji表情包</p></li><li><p>支持发送图片（仅单张）</p></li><li><p>发布的文字支持MarkDown语法</p></li><li><p>发送的图片支持点击放大预览</p></li><li><p>实时获取微博热搜话题显示在主页</p></li><li><p>获取用户是用什么设备发送的博客，例如android，iPhone</p></li><li><p>根据设置的出生日期计算年龄</p></li><li><p>点赞功能</p></li><li><p>搜索功能</p></li><li><p>置顶功能</p></li><li><p>更换头像</p></li></ol><h2 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a>技术框架</h2><p>SpringBoot  核心框架  </p><p>Appache Shiro  安全框架  </p><p>Mybatis  ORM框架  </p><p>Redis  缓存数据库</p><p>Nginx web服务器</p><p>BootStrap 前端框架</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a><a href="https://blog.igali.xyz" target="_blank" rel="noopener">项目地址</a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis命令</title>
      <link href="/2020/06/24/redis%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/24/redis%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>开启redis命令</strong></p><p>systemctl start pedis.service</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux防火墙常用命令</title>
      <link href="/2020/06/24/linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/24/linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h5 id="开启防火墙端口"><a href="#开启防火墙端口" class="headerlink" title="开启防火墙端口"></a>开启防火墙端口</h5><p>​    firewall-cmd –zone=public –add-port=80/tcp –permanent</p><h5 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h5><p>systemctl restart firewalld.service</p><h5 id="查看已经开放的端口"><a href="#查看已经开放的端口" class="headerlink" title="查看已经开放的端口"></a><strong>查看已经开放的端口</strong></h5><p>firewall-cmd –list-ports</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题笔记</title>
      <link href="/2020/04/08/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/08/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="JVM的工作原理"><a href="#JVM的工作原理" class="headerlink" title="JVM的工作原理"></a>JVM的工作原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM是JRE的一部分，Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。(怎么跨平台的：jvm它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一、JVM内存分为堆、方法区、虚拟机栈、本地方法栈、程序计数器五个部分。</span><br><span class="line"></span><br><span class="line">二、堆和方法区是线程共享的，虚拟机栈、本地方法栈和程序计数器是线程隔离的。</span><br><span class="line"></span><br><span class="line">三、1.堆主要是存放对象实例的也包括数组，是垃圾管理的主要作用区。</span><br></pre></td></tr></table></figure><h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a><strong>JVM的生命周期</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）JVM实例的诞生：当启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点。 </span><br><span class="line">（2）JVM实例的运行 main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程。 </span><br><span class="line">（3）JVM实例的消亡：当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。</span><br></pre></td></tr></table></figure><h3 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">栈是运行时的单位，而堆是存储的单位。</span><br><span class="line">栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</span><br><span class="line">在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。</span><br><span class="line">堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。</span><br><span class="line">堆和栈中，栈是程序运行最根本的东西。程序运行可以没有堆，但是不能没有栈。</span><br></pre></td></tr></table></figure><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="SpringMVC的流程"><a href="#SpringMVC的流程" class="headerlink" title="SpringMVC的流程"></a>SpringMVC的流程</h3><pre><code>发送请求-接收请求-记录请求与控制器的对应关系-委托请求到控制器-处理后得到的数据及视图名称-根据视图名称确定具体的视图组件-产生响应</code></pre><h3 id="SpringMVC能否从请求url中截取参数？"><a href="#SpringMVC能否从请求url中截取参数？" class="headerlink" title="SpringMVC能否从请求url中截取参数？"></a>SpringMVC能否从请求url中截取参数？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以利用@PathVariable实现。在Controller方法上添加的&#96;@RequestMapping&#96;注解中，使用&#96;&#123;变量名&#125;&#96;的方式，将url中指定位置的值作为变量。在对应方法的参数中，声明一个接收该变量值的参数，前面使用&#96;@PathVariable(&quot;变量名&quot;)&#96;标注。</span><br></pre></td></tr></table></figure><h3 id="SpringMVC框架的核心组件"><a href="#SpringMVC框架的核心组件" class="headerlink" title="SpringMVC框架的核心组件"></a>SpringMVC框架的核心组件</h3><p>-<code>DispatcherServlet</code>：前端控制器，用于接收所有请求，并组织分发；</p><p>-<code>HandlerMapping</code>：记录请求路径与控制器的对应关系；</p><p>-<code>Controller</code>：自定义的处理请求的控制器组件；</p><p>-<code>ModelAndView</code>：控制器组件处理完请求之后得到的结果，包含数据与视图名称；</p><p>-<code>ViewResolver</code>：视图解析器，可以根据视图名称，确定具体的视图组件。</p><h3 id="1-关于-RequestMapping注解"><a href="#1-关于-RequestMapping注解" class="headerlink" title="1. 关于@RequestMapping注解"></a>1. 关于@RequestMapping注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在处理请求的方法之前添加&#96;@RequestMapping&#96;注解，可以配置请求路径与处理请求的方法的映射关系！</span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 什么是索引：索引是数据库中提高查询效率的技术，数据量越大索引效果越明显，索引类似于目录</span><br><span class="line"></span><br><span class="line">- 为什么使用索引：数据会零散的保存在磁盘中的每个磁盘块中，如果不使用索引，查找数据只能挨个遍历每一个磁盘块进行查找，如果使用了索引后，磁盘块会以树桩结构进行保存，查找数据时大大降低了磁盘块的访问量，从而达到了提高查询效率的目的</span><br></pre></td></tr></table></figure><h2 id="转发与重定向的区别"><a href="#转发与重定向的区别" class="headerlink" title="转发与重定向的区别"></a>转发与重定向的区别</h2><h3 id="能否共享request对象"><a href="#能否共享request对象" class="headerlink" title="能否共享request对象?"></a>能否共享request对象?</h3><pre><code>转发可以，而重定向不行。注：    因为request和response这两个对象的生存时间是在一次请求与响应期间存在。    转发是一次请求，重定向是两次请求。转发是服务器内部的行为，具体表现为</code></pre><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>1.什么是散列表?</p><pre><code>依据关键码值(key)直接获取表中对应纪录的一种数据结构。其中，将关键码值映射到表中的位置的函数叫散列函数(hash函数),存放记录的数组称之为散列表。</code></pre><p>2.散列表的工作原理:<br>    首先我们使用散列函数将给定键转化为一个“数组的索引”，(key如果相同就是碰撞)<br>    得到了索引后，我们就可以像访问数组一样，通过这个索引访问到相应的键值对。<br>3.散列表常见的一些实现类。</p><pre><code>Hashtable: 线程安全，但是性能低,不建议使用。HashMap:线程不安全，性能高。    注：        可以调用Collections.synchronizedMap来将hashMap    转换成一个线程安全的map。ConcurrentHashMap: 线程安全，并且性能良好。</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>(1)什么是事务?事务(Transaction)：是数据库领域中，一种能保证多项增删改操作能够全部执行成功，或全部执行失败的机制！(2)事务的特点(ACID)    A.原子性（atomicity):            事务所涉及的各个操作要么全部成功，要么全部失败。    C.一致性（consistency):            事务完成之后，不允许非法的数据保存到数据库。一个事务在执行之前和执行之后，数据的完整性都必须处于一致性状态。    I.隔离性（isolation）：            多个事务可以同时执行，彼此不所影响。            事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。    D.持久性（durability）：            事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</code></pre><h2 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h2><p><strong>什么是业务：业务(Service)，对于普通用户来说，就是一个“功能”，但是，它可能是由多项数据操作组成的，例如“用户注册”就是一个业务，它至少由“根据用户名查询数据”和“插入数据”组成，在编写代码时，业务层主要完成业务流程和业务逻辑的控制，业务流程指的是先做什么、后做什么，业务逻辑指的是什么情况下能做什么、不能做什么，最终，业务层的目标是保障数据的完整性、安全性。</strong></p><p>####POJO<br>POJO是各种实体类的统称，常用的实体类包括DO/DTO/BO/VO。</p><ol><li>DO：与数据库表相对应的实体类，属性与表中字段相对应</li><li>DTO：业务层传输数据时使用的实体类</li><li>BO：业务层对外提供远程调用时使用的实体类</li><li>VO：供视图层使用的实体类</li></ol><ul><li><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>什么是Spring：<br>  简单来说，<strong>Spring是一个轻量级的控制反转（IoC)和面向切面（AOP)的容器框架。</strong></p></li></ul><h2 id="Spring框架的好处，为什么要用Spring"><a href="#Spring框架的好处，为什么要用Spring" class="headerlink" title="Spring框架的好处，为什么要用Spring?"></a>Spring框架的好处，为什么要用Spring?</h2><p>1.方便解耦，便于开发（Spring就是一个大工厂，可以将所有对象的创建和依赖关系维护都交给spring管理）</p><p>2.spring支持aop编程（spring提供面向切面编程，可以很方便的实现对程序进行权限拦截和运行监控等功能）</p><p>3.声明式事务的支持（通过配置就完成对事务的支持，不需要手动编程）</p><p>4.方便程序的测试，spring 对junit4支持，可以通过注解方便的测试spring 程序</p><p>5.方便集成各种优秀的框架（）</p><p>6.降低javaEE API的使用难度（Spring 对javaEE开发中非常难用的一些API 例如JDBC,javaMail,远程调用等，都提供了封装，是这些API应用难度大大降低）</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>什么是AOP：<br>    简单地说，<strong>就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低 模块间的耦合度，并有利于未来的可操作性和可维护性。</strong><br>    核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横 切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。<br>    Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king = <span class="keyword">new</span> King();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是饿汉式单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123; <span class="comment">// 判断是否有必须加锁，如果没有该判断，则效率可能偏低</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="string">"java"</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123; <span class="comment">// 判断是否有必须创建对象，如果没有该判断，则可能创建多个对象</span></span><br><span class="line">                    king = <span class="keyword">new</span> King();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，就是完整的懒汉式的单例模式！</p><p><strong>小结：单例模式的特点就是“单一实例”，表现为“同一时间内，某个类的对象只有1个”！单例模式分为“饿汉式”和“懒汉式”这2种，前者是“早早的创建出对象，随时可以获取”，后者是“不到逼不得已不会创建对象”！</strong></p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p><code>byName</code>：要求被装配的属性名称，与被Spring管理的对象的名称（调用<code>getBean()</code>方法给出的参数名）必须相同；</p><p><code>byType</code>：要求被装配的属性的类型，在Spring容器中存在匹配类型的对象，当应用这种机制时，必须在Spring容器中保证匹配类型的对象只有1个，否则，将会出现<code>NoUniqueBeanDefinitionException</code>异常；</p><hr><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><pre><code>索引是数据库中提高查询效率的技术，数据量越大索引效果越明显，索引类似于目录索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，</code></pre><h3 id="为什么使用索引："><a href="#为什么使用索引：" class="headerlink" title="为什么使用索引："></a>为什么使用索引：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据会零散的保存在磁盘中的每个磁盘块中，如果不使用索引，查找数据只能挨个遍历每一个磁盘块进行查找，如果使用了索引后，磁盘块会以树桩结构进行保存，查找数据时大大降低了磁盘块的访问量，从而达到了提高查询效率的目的</span><br></pre></td></tr></table></figure><h3 id="mysql-索引是怎么实现的？"><a href="#mysql-索引是怎么实现的？" class="headerlink" title="mysql 索引是怎么实现的？"></a>mysql 索引是怎么实现的？</h3><pre><code>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</code></pre><h2 id="什么是Serializable接口"><a href="#什么是Serializable接口" class="headerlink" title="什么是Serializable接口"></a>什么是Serializable接口</h2><pre><code>一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才能被序列化。</code></pre><h3 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h3><pre><code>序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</code></pre><h3 id="为什么要序列化对象"><a href="#为什么要序列化对象" class="headerlink" title="为什么要序列化对象"></a>为什么要序列化对象</h3><pre><code>把对象转换为字节序列的过程称为对象的序列化把字节序列恢复为对象的过程称为对象的反序列化</code></pre><h3 id="什么情况下需要序列化？"><a href="#什么情况下需要序列化？" class="headerlink" title="什么情况下需要序列化？"></a>什么情况下需要序列化？</h3><pre><code>当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，以便将来使用时都需要把对象进行序列化</code></pre><h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h2><p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。</p><h3 id="3-关于Session"><a href="#3-关于Session" class="headerlink" title="3. 关于Session"></a>3. 关于Session</h3><p>因为HTTP协议是无状态协议，所以，同一个客户端的多次请求，服务器是无法区分这是来自同一个客户端的，如果需要保存用户的某些数据或状态，就需要使用Session。</p><h3 id="4-拦截器-Interceptor"><a href="#4-拦截器-Interceptor" class="headerlink" title="4. 拦截器(Interceptor)"></a>4. 拦截器(Interceptor)</h3><p>拦截器：是一种可以使得若干种请求都会自动的执行其中的代码组件！该组件对所处理的请求可以选择放行，或选择阻止继续执行！</p><p>在SpringMVC项目中，如果需要使用拦截器，首先，需要自定义类，实现<code>HandlerInterceptor</code>拦截器接口：</p><h3 id="附1：关于拦截器-Interceptor-和过滤器-Filter"><a href="#附1：关于拦截器-Interceptor-和过滤器-Filter" class="headerlink" title="附1：关于拦截器(Interceptor)和过滤器(Filter)"></a>附1：关于拦截器(Interceptor)和过滤器(Filter)</h3><p>过滤器(Filter)是Java EE中的组件，而拦截器(Interceptor)是SpringMVC中的组件！</p><p>过滤器(Filter)是执行在所有的<code>Servlet</code>之前的组件，而SpringMVC中的拦截器的第1次执行是在<code>DispatcherServlet</code>之后，且在<code>Controller</code>之前执行的！(对应SpringMVC核心执行流程图，过滤器是1号位置执行，而拦截器第1次执行是在4号位置)</p><h2 id="MyBatis框架的作用"><a href="#MyBatis框架的作用" class="headerlink" title="MyBatis框架的作用"></a>MyBatis框架的作用</h2><p>MyBatis框架最直接的作用就是简化持久层开发！</p><blockquote><p>持久层：处理数据持久化的组件；</p></blockquote><blockquote><p>持久化：将数据永久的存储下来；</p></blockquote><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Set-无序-唯一"><a href="#Set-无序-唯一" class="headerlink" title="Set 无序,唯一"></a>Set 无序,唯一</h3><p>HashSet如何保证元素的唯一性</p><p><strong>依赖两个方法：hashCode()和equals()</strong></p><p>TreeSet底层数据结构是红黑树</p><ol><li><p>如何保证元素排序的呢?</p><p>自然排序、比较器排序</p></li><li><p>如何保证元素唯一性的呢?<br>根据比较的返回值是否是0来决定</p></li></ol><h3 id="List-有序-可重复"><a href="#List-有序-可重复" class="headerlink" title="List 有序,可重复"></a>List 有序,可重复</h3><p>ArrayList和Vector底层数据结构是数组</p><p>linkedList底层数据结构是链表</p><p>只有Vector是线程安全的</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>TreeMap是有序的，HashMap和HashTable是无序的。</li><li>Hashtable的方法是同步的，HashMap的方法不是同步的。这是两者最主要的区别。</li><li>Hashtable是线程安全的，HashMap不是线程安全的。</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="StringBuffer和StringBuilder的区别"><a href="#StringBuffer和StringBuilder的区别" class="headerlink" title="StringBuffer和StringBuilder的区别"></a>StringBuffer和StringBuilder的区别</h3><p>在改变字符串时，都不会创建新的对象。</p><p>不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>在Object类中主要包括clone()、finalize()、equals()、toString()等方法，其中常用的两个方法为equals()和toString()方法。</p><p><strong>Object类中的getClass()、notify()、notifyAll()、wait()等方法不能被重写，因为这些方法被定义为final类型。</strong></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Error-和-Exception的区别"><a href="#Error-和-Exception的区别" class="headerlink" title="Error 和 Exception的区别"></a>Error 和 Exception的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。</span><br><span class="line"></span><br><span class="line">Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。</span><br></pre></td></tr></table></figure><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中的Exception又分为检查性异常和非检查性异常。两个根本的区别在于，检查性异常 必须在编写代码时，使用try catch捕获（比如：IOException异常）。非检查性异常 在代码编写使，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。</span><br></pre></td></tr></table></figure><p><strong>它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。</strong></p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示系统级的错误和程序不必处理的异常，如：OutOfMemoryError、NoClassDefFoundError等。</span><br></pre></td></tr></table></figure><h3 id="受检异常和非受检异常"><a href="#受检异常和非受检异常" class="headerlink" title="受检异常和非受检异常"></a>受检异常和非受检异常</h3><p><strong>非受检异常指的是java.lang.RuntimeException和java.lang.Error类及其子类，所有其他的异常类都称为受检异常。</strong></p><p>以下是RuntimeException 非受检异常</p><p><code>Java.lang.ClassCastException</code></p><p><code>Java.lang.IllegalArgumentException</code></p><p><code>Java.lang.IndexOutOfBoundsException</code></p><p><code>Java.lang.ArrayIndexOutOfBoundsException</code></p><p><code>Java.lang.NullPointerException</code></p><h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><p>1、throw代表动作，表示抛出一个异常的动作；throws代表一种状态，代表方法可能有异常抛出<br>2、throw用在方法实现中，而throws用在方法声明中<br>3、throw只能用于抛出一种异常，而throws可以抛出多个异常</p><h2 id="什么是Java-EE"><a href="#什么是Java-EE" class="headerlink" title="什么是Java EE"></a>什么是Java EE</h2><p>Java 平台企业版</p><h3 id="JavaEE-与-JavaSE-的区别与联系"><a href="#JavaEE-与-JavaSE-的区别与联系" class="headerlink" title="JavaEE 与 JavaSE 的区别与联系"></a>JavaEE 与 JavaSE 的区别与联系</h3><p>JavaEE 是在 JavaSE 的基础上构建的，是对 JavaSE 的扩展，增加了一些更加便捷的应用框架。</p><h2 id="JavaEE主要技术"><a href="#JavaEE主要技术" class="headerlink" title="JavaEE主要技术"></a>JavaEE主要技术</h2><p><strong>JDBC</strong>  <strong>Servlet</strong>  <strong>jsp</strong>  <strong>XML</strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
