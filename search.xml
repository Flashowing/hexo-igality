<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring03</title>
    <url>/2020/07/03/07_SPRING_DAY03/</url>
    <content><![CDATA[<h2 id="1-通过Environment读取-properties配置文件"><a href="#1-通过Environment读取-properties配置文件" class="headerlink" title="1. 通过Environment读取.properties配置文件"></a>1. 通过Environment读取.properties配置文件</h2><p>假设在<strong>src/main/resources</strong>下存在<strong>jdbc.properties</strong>文件，并且，在该文件中存在若干条配置信息，如果需要读取该文件中的配置信息，可以先创建某个类，在类中声明<code>Environment</code>接口类型的对象，通过自动装配的方式为该类型对象注入值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Environment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> environment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.environment = environment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续，需要读取配置文件中的值时，从以上类中获取<code>Environment</code>类型的对象，然后，调用该对象的<code>getProperty()</code>方法即可获取对应的值，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext ac</span><br><span class="line">			= <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		</span><br><span class="line">		JdbcConfig jdbcConfig = ac.getBean(<span class="string">"jdbcConfig"</span>, JdbcConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		</span><br><span class="line">		Environment environment = jdbcConfig.getEnvironment();</span><br><span class="line">		System.out.println(environment.getProperty(<span class="string">"db.url"</span>));</span><br><span class="line">		System.out.println(environment.getProperty(<span class="string">"db.driver"</span>));</span><br><span class="line">		System.out.println(environment.getProperty(<span class="string">"db.username"</span>));</span><br><span class="line">		System.out.println(environment.getProperty(<span class="string">"db.password"</span>));</span><br><span class="line">		</span><br><span class="line">		ac.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring阶段小结"><a href="#Spring阶段小结" class="headerlink" title="Spring阶段小结"></a>Spring阶段小结</h2><ul>
<li><p>【理解】Spring框架的主要作用：创建对象，管理对象；</p>
</li>
<li><p>【理解】Spring框架深层的作用：解耦；</p>
</li>
<li><p>【掌握】通过Spring框架创建对象：</p>
<ul>
<li>在某个类中自定义方法，方法的返回值类型就是需要Spring框架创建对象的类型，在方法体中自行返回所需要创建的对象，并且为方法添加<code>@Bean</code>注解，后续，只要Spring框架加载这个类，就会自动调用被添加了<code>@Bean</code>注解的方法，并管理方法所返回的对象。通常，当需要管理的对象所归属的类不是自定义的，必须使用这种做法；</li>
<li>使得Spring框架执行组件扫描，保证相关的类在组件扫描的包或其子孙包中，并且，类还需要添加<code>@Component</code> / <code>@Controller</code> / <code>@Service</code> / <code>@Repository</code>注解中的某1个。通常，当需要管理的对象所归属的类是自定义的，优先使用这种做法。</li>
</ul>
</li>
<li><p>【掌握】关于组件扫描：可以将组件扫描的包的名称作为字符串参数直接应用于<code>AnnotationConfigApplicationContext</code>类的构造方法中，但是，并不推荐使用这种做法，在实际项目开发时，<code>AnnotationConfigApplicationContext</code>类通常不是开发人员自行创建的，也就没有办法在构造方法中添加包的名称！推荐使用自定义的类作为配置类，并结合<code>@ComponentScan</code>注解来配置组件扫描；</p>
</li>
<li><p>【理解】被Spring管理的对象默认是单例的（注意：Spring框架不是设计模式中的单例模式，只是管理对象的方法是这样的），并且，不是懒加载的模式（相当于单例模式中的饿汉式单例的效果）；</p>
</li>
<li><p>【了解】使用<code>@Scope</code>和<code>@Lazy</code>调整被Spring管理的对象的作用域；</p>
</li>
<li><p>【理解】被Spring管理的对象的生命周期；</p>
</li>
<li><p>【了解】配置对象的生命周期：</p>
<ul>
<li>如果使用的是添加了<code>@Bean</code>注解的自定义方法返回对象的做法，在<code>@Bean</code>注解中配置<code>initMethod</code>和<code>destroyMethod</code>属性，就可以将类中的方法分别指定为初始化方法和销毁方法；</li>
<li>如果使用的是组件扫描和组件注解的做法，在类中的初始化方法之前添加<code>@PostConstruct</code>注解，在销毁方法之前添加<code>@PreDestroy</code>方法。</li>
</ul>
</li>
<li><p>【理解】关于Spring框架的DI与IoC：</p>
<ul>
<li>DI：Dependency Injection，依赖注入，具体的表现就是“为当前类对象所依赖的某个属性注入值”；</li>
<li>IoC：Inversion of Control：控制反转，在传统模式下，是由开发人员自行创建对象（例如<code>User user = new User();</code>）且管理对象（例如<code>user.setName(&quot;Jack&quot;);</code>），可以理解为开发人员具有对象的控制权，当使用了Spring框架后，创建对象和管理对象的权力就交给了框架。</li>
<li>在Spring框架中，DI是一种做法，IoC是最终实现的效果，也就是“Spring框架通过DI这种做法实现了IoC的效果”。</li>
</ul>
</li>
<li><p>【理解】Spring框架自动装配机制的2种装配模式：</p>
<ul>
<li><code>byName</code>：根据名称实现自动装配，在这种模式下，要求被装配的属性名称，与被Spring管理的对象的名称（调用<code>getBean()</code>方法给出的参数名）必须相同；</li>
<li><code>byType</code>：根据类型实现自动装配，在这种模式，要求被装配的属性的类型，在Spring容器中存在匹配类型的对象，当应用这种机制时，必须在Spring容器中保证匹配类型的对象只有1个，否则，将会出现<code>NoUniqueBeanDefinitionException</code>异常；</li>
</ul>
</li>
<li><p>【理解】使用<code>@Autowired</code>和<code>@Resource</code>这2个注解实现自动装配时的区别：</p>
<ul>
<li>使用<code>@Autowired</code>尝试自动装配时，Spring框架会先根据<code>byType</code>模式找出所有匹配类型的对象，如果匹配类型的对象的数量为0，也就是没有匹配类型的对象，默认情况下会直接报错（如果明确的配置为<code>@Autowired(required=false)</code>时不会因为装配失败而出错）；如果匹配类型的对象的数量为1，则直接装配；如果匹配类型的对象的数量超过1个（有2个甚至更多个），会尝试<code>byName</code>来装配，如果存在名称匹配的对象，则成功装配，如果名称均不匹配，则装配失败。</li>
<li>使用<code>@Resource</code>注解尝试自动装配时，其工作原理是先尝试<code>byName</code>装配，如果存在名称匹配的对象，则直接装配，如果没有名称匹配的对象，则尝试<code>byType</code>装配。</li>
</ul>
</li>
<li><p>【掌握】通过Spring框架读取<strong>.properties</strong>配置文件中的信息：</p>
<ul>
<li>在组件类的声明之前添加<code>@PropertySource</code>注解，以配置需要读取的<strong>.properties</strong>文件的位置，然后，通过<code>@Value</code>注解将读取到的属性值一一注入到类的属性中，在声明类的属性时，只要该属性的类型是常规类型（例如基本数据类型、<code>String</code>等）或Spring框架自定义的类型，都可以将类的属性直接声明为所期望的类型；</li>
<li>在组件类的声明之前添加<code>@PropertySource</code>注解，以配置需要读取的<strong>.properties</strong>文件的位置，然后，在类中自定义<code>Environment</code>接口类型的对象，通过<code>@Autowired</code>为该对象自动装配值，后续，调用该对象的<code>getProperty()</code>方法即可获取在<strong>.properties</strong>文件中配置的属性值。</li>
</ul>
</li>
<li><p>【说明】关于Spring AOP会在项目后期再讲。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>达内笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring01</title>
    <url>/2020/07/01/07_SPRING_DAY01/</url>
    <content><![CDATA[<h2 id="2-Spring框架的作用"><a href="#2-Spring框架的作用" class="headerlink" title="2. Spring框架的作用"></a>2. Spring框架的作用</h2><p>Spring框架的主要作用是创建对象和管理对象。</p>
<p>创建对象：类似于<code>User user = new User();</code></p>
<p>管理对象：随时可以通过Spring框架获取对象，甚至Spring框架还能够帮我们为对象的属性进行赋值等。</p>
<h2 id="3-通过Spring框架创建对象，并获取对象"><a href="#3-通过Spring框架创建对象，并获取对象" class="headerlink" title="3. 通过Spring框架创建对象，并获取对象"></a>3. 通过Spring框架创建对象，并获取对象</h2><p>在Eclipse中创建<strong>Maven Project</strong>，在创建过程中勾上<strong>Create a simple project</strong>，<strong>Group Id</strong>填为<code>cn.tedu</code>，<strong>Artifact Id</strong>填为<code>spring01</code>。</p>
<blockquote>
<p>如果某个项目不会被其它项目所使用，只需要保证自身能独立运行，其实<strong>Group Id</strong>和<strong>Artifact Id</strong>的值是多少，并不重要。</p>
</blockquote>
<p>创建成功后，先在<strong>pom.xml</strong>中添加以上配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，对项目名称点击鼠标右键，选择<strong>Maven</strong> &gt; <strong>Update Project</strong>以更新Maven，则当前环境会使用Java 1.8。</p>
<p>接下来，需要在<strong>pom.xml</strong>中添加Spring框架所需的<code>spring-context</code>依赖的代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果需要Spring管理某个类的对象，可以通过自定义的类进行配置！</p>
<p>例如存在需求：使得Spring框架管理<code>Date</code>类的对象！</p>
<p>先在项目的<code>cn.tedu.spring</code>包中创建<code>Beans</code>类，并且，在这个类中自定义方法，方法的返回值类型必须是<code>Date</code>，然后，自行在方法体中创建出<code>Date</code>对象并返回即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beans</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">aaa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上使用的包名是自定义，并不是强制要求。</p>
<p>以上使用的类名是自定义，并不是强制要求。</p>
</blockquote>
<p>关于以上自定义的方法：</p>
<ul>
<li>应该使用<code>public</code>权限；</li>
<li>返回值类型是需要Spring管理的对象所归属的类型；</li>
<li>方法名称可以自定义；</li>
<li>参数列表暂时为空；</li>
<li>必须添加<code>@Bean</code>注解。</li>
</ul>
<p>然后，就可以创建一个用于运行的类，加载以上类，并获取对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1. 加载配置类，获取Spring容器</span></span><br><span class="line">		AnnotationConfigApplicationContext ac</span><br><span class="line">			= <span class="keyword">new</span> AnnotationConfigApplicationContext(Beans<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2. 从Spring容器中获取对象</span></span><br><span class="line">		Date date = (Date) ac.getBean(<span class="string">"aaa"</span>); <span class="comment">// getBean()方法的参数，就是配置对象的方法的名称</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3. 测试</span></span><br><span class="line">		System.out.println(date);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 4. 关闭</span></span><br><span class="line">		ac.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上代码，就可以看到输出的对象！</p>
<p>在以上<code>Beans</code>类中，配置对象的方法名是<code>aaa</code>，在运行的<code>Demo</code>类中，调用<code>getBean()</code>方法的参数也必须是<code>&quot;aaa&quot;</code>，名称必须保持一致！</p>
<p>通过，获取某个值的方法的名称都应该是<code>getXxx</code>，所以，以上<code>Beans</code>类中的方法应该改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，一旦将方法名改成了<code>getDate</code>，运行时，调用的<code>getBean()</code>方法的参数也应该改成<code>getDate</code>，例如改成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = (Date) ac.getBean(<span class="string">"getDate"</span>);</span><br></pre></td></tr></table></figure>

<p>很显然，这个<code>getDate</code>表示的是一个<strong>名称</strong>，而名称应该使用名词，而不应该使用动词作为前缀！</p>
<p>如果要解决这个问题，可以在<code>@Bean</code>注解中配置参数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"date"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续，在运行时，调用<code>getBean()</code>方法的参数就是<code>@Bean</code>注解中配置的值，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = (Date) ac.getBean(<span class="string">"date"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>小结：在运行时，调用的<code>getBean()</code>方法的参数值，默认情况下，是配置对象的方法的名称，如果配置对象的方法的<code>@Bean</code>注解添加了参数，则<code>getBean()</code>方法的参数就是<code>@Bean</code>注解中的参数！</strong></p>
<p><strong>其实，Spring推荐直接使用名词作为以上配置对象的方法名称，即推荐使用<code>date</code>作为方法名，而不是<code>getDate</code>作为方法名！该名词将用于<code>getBean()</code>方法的参数，毕竟这个方法定义好了以后，是由Spring框架去调用了，开发人员不需要自行调用该方法，为了简化代码的同时还保证<code>getBean()</code>代码的语义，推荐使用名词作为方法名称！</strong></p>
<h2 id="4-由Spring管理的对象的作用域"><a href="#4-由Spring管理的对象的作用域" class="headerlink" title="4. 由Spring管理的对象的作用域"></a>4. 由Spring管理的对象的作用域</h2><p>由Spring管理的对象，在默认情况下，都是单例的！如果在配置对象的方法之前，补充添加<code>@Scope</code>注解，且注解参数配置为<code>prototype</code>时，就不是单例的了！例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Spring与单例模式是两个不同的概念！</p>
<p>当需要同时使用多个注解时，各注解不区分先后顺序。</p>
</blockquote>
<p>由Spring管理的对象，在单例的情况下，默认是饿汉式的！如果希望调整为懒汉式的，则在配置对象方法的方法之前补充添加<code>@Lazy</code>注解即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-由Spring管理的对象的生命周期"><a href="#5-由Spring管理的对象的生命周期" class="headerlink" title="5. 由Spring管理的对象的生命周期"></a>5. 由Spring管理的对象的生命周期</h2><p>生命周期：某个对象从创建到最终销毁会经历的历程！</p>
<p>通常，需要讨论生命周期时，对应的数据类型的对象都不是由开发人员自行维护的！</p>
<p>被容器维护的对象，都是由容器创建对象，并在适当的时候调用其中的某些方法的！而开发人员需要做的就是“确定满足某条件的时候应该执行什么任务”！也就是说，“容器决定什么时候执行，开发人员决定执行时做什么”。</p>
<p>学习生命周期的意义就是“知道在什么时候需要做什么事情”！</p>
<p>以<code>Servlet</code>为例，其生命周期中会有几个特殊的方法，在特定的情况下会被调用，这些就称之为生命周期方法：</p>
<ul>
<li><code>init()</code>：当<code>Servlet</code>被创建对象后，立即执行，且只执行1次，该方法适合编写一些初始化相关的代码；</li>
<li><code>service()</code>：当接收到匹配的请求后会被调用，接收到多少次请求，就执行多少次该方法；</li>
<li><code>destroy()</code>：当<code>Servlet</code>对象即将被销毁之前执行，且只执行1次，该方法适合编写一些与结束相关的代码，例如关闭等等。</li>
</ul>
<p>当使用Spring框架后，某些类的对象交给Spring框架来管理了，那么，这些对象在什么时候被创建、什么时候被销毁，及创建过程和销毁过程中需要执行某些代码，对于开发人员来说，一定程度上是不可控的！</p>
<p>Spring框架允许用户在类中自定义最多2个方法，分别表示“初始化方法”和“销毁方法”，并且，Spring框架会在创建对象之后自动调用初始化方法，会在销毁对象之前调用销毁方法！关于方法的定义：</p>
<ul>
<li>访问权限：应该使用<code>public</code>权限；</li>
<li>返回值类型：使用<code>void</code>；</li>
<li>方法名称：自定义；</li>
<li>参数列表：空。</li>
</ul>
<p>例如，在<code>User</code>类中自定义2个生命周期方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"User.init()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"User.destroy()"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在配置对象的方法之前的<code>@Bean</code>注解中配置这2个方法作为生命周期方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>, destroyMethod=<span class="string">"destroy"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-通过组件扫描使得Spring管理类的对象"><a href="#6-通过组件扫描使得Spring管理类的对象" class="headerlink" title="6. 通过组件扫描使得Spring管理类的对象"></a>6. 通过组件扫描使得Spring管理类的对象</h2><p>假设存在<code>User</code>类，需要被Spring框架创建并管理对象，则，必须先明确<code>User</code>类所在的包，然后，在用于运行的类<code>Demo</code>中，在<code>AnnotationConfigApplicationContext</code>的构造方法中，将包名作为构造方法的参数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ac </span><br><span class="line">    = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"cn.tedu.spring"</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码则表示“<strong>组件扫描</strong>”，当执行时，Spring框架会扫描指定的包中所有的内容，并且，自动创建各<strong>组件</strong>的对象并进行管理！</p>
<p>当然，并不是所有的类都是“<strong>组件</strong>”，如果要标识某个类是“组件”，必须在类的声明之前添加<code>@Component</code>注解！例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续，从Spring容器中获取对象时，默认情况下，将类名的首字母改为小写，作为Bean的名称，用于调用<code>getBean()</code>方法的参数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = ac.getBean(<span class="string">"user"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于Bean的名称，如果类名<strong>首字母是大写，且第2个字母是小写</strong>，例如<code>User</code>或<code>Student</code>，则Bean的名称就是将首字母改为小写即可，也就是<code>user</code>或<code>student</code>！如果不满足该条件，例如类名是<code>teacher</code>或<code>IUserDao</code>，则Bean的名称就是类的名称！</p>
</blockquote>
<p>当然，Spring框架也允许自定义Bean的名称，只要将自定义的名称配置在<code>@Component</code>注解参数中即可，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"stu"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则以上类的对象被Spring管理时，Bean的名称就是<code>&quot;stu&quot;</code>，后续，调用<code>getBean()</code>方法获取对象时，也必须使用这个名称来获取对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student stu = ac.getBean(<span class="string">"stu"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>























<hr>
<h2 id="【附】1-单例模式"><a href="#【附】1-单例模式" class="headerlink" title="【附】1. 单例模式"></a>【附】1. 单例模式</h2><p>单例模式，是设计模式中的一种。</p>
<p>单例模式，其特点是：被设计为单例的类型，在同一时间内，该类型的对象只会存在1个！</p>
<p>假设存在<code>King</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>作为一个普通的类，是可以在类的外部随意创建对象的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">King k1 = <span class="keyword">new</span> King();</span><br><span class="line">King k2 = <span class="keyword">new</span> King();</span><br><span class="line">King k3 = <span class="keyword">new</span> King();</span><br></pre></td></tr></table></figure>

<p>因为在<code>King</code>类中，没有声明构造方法，则编译器会自动的添加默认构造方法，也就是公有的、无参数的构造方法，所以，在类的外部才可以随意创建对象！以上代码中就创建了3个<code>King</code>类型的对象！</p>
<p>如果要实现单例，首先，就不能允许随意创建对象，可以显式的添加构造方法，并将其私有化，避免外部随意访问，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦显式的添加了构造方法，编译器就不会再自动添加构造方法了，则在类的外部，将不可以再执行<code>King k1 = new King();</code>这类的代码了！</p>
<p>使用了私有的构造方法，并不影响在类的内部使用该构造方法，为了保证在类的外部依然可以获取类的对象，则可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> King();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，为了保证“多次获取时，获取到的都是同一个对象”，则不能反复在方法中<strong>创建</strong>对象，而是改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> King king = <span class="keyword">new</span> King();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为这样以后，无论执行多少次<code>getInstance()</code>方法，该方法返回的都是同一个<code>king</code>变量，而该变量的值只是在类被加载时赋值了1次而已，就实现了单例的效果！</p>
<p>当然，以上代码是矛盾的！因为，如果要调用<code>getInstance()</code>方法，必须先有<code>King</code>类型的对象，而得到<code>King</code>类型对象的唯一途径就是调用<code>getInstance()</code>方法！也就是说：不调用<code>getInstance()</code>方法就无法得到对象，但是，调用方法之前又必须有对象！</p>
<p>为了解决这个问题，可以为<code>getInstance()</code>方法添加<code>static</code>修饰符，则通过<code>类名.方法名()</code>的格式就可以调用方法了，不需要事先获取对象！同时，基于“被<code>static</code>修饰的成员不可以直接访问没被<code>static</code>修饰的成员”的原则，所以，全局的<code>private King king = new King();</code>也需要添加<code>static</code>修饰符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king = <span class="keyword">new</span> King();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，简单的单例模式代码就完成了，后续，需要获取<code>King</code>类型的对象时，只能通过<code>King.getInstance()</code>得到对象，而该方法每次返回的都是同一个对象！</p>
<p>严格来说，以上单例模式的设计是“饿汉式”的，可以看到，在类被加载时，就直接创建了<code>King</code>类的对象，此时，也许并不需要获取对象，但是，也创建好了 ，后续，当需要对象时，直接获取即可！另外，还有“懒汉式”的单例模式，其特点就是“不到逼不得已，不创建对象”！其基础代码例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123;</span><br><span class="line">            king = <span class="keyword">new</span> King();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是多线程不安全的！为了解决这个问题，可以将以上代码块添加互斥锁，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="string">"java"</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123;</span><br><span class="line">                king = <span class="keyword">new</span> King();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦添加了锁，就会导致每次调用<code>getInstance()</code>方法时都会先锁定代码再执行，效率偏低，为了解决该问题，还可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123; <span class="comment">// 判断是否有必须加锁，如果没有该判断，则效率可能偏低</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="string">"java"</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123; <span class="comment">// 判断是否有必须创建对象，如果没有该判断，则可能创建多个对象</span></span><br><span class="line">                    king = <span class="keyword">new</span> King();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，就是完整的懒汉式的单例模式！</p>
<p><strong>小结：单例模式的特点就是“单一实例”，表现为“同一时间内，某个类的对象只有1个”！单例模式分为“饿汉式”和“懒汉式”这2种，前者是“早早的创建出对象，随时可以获取”，后者是“不到逼不得已不会创建对象”！</strong></p>
]]></content>
      <categories>
        <category>达内笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC02</title>
    <url>/2020/07/04/08_SPRINGMVC_DAY02/</url>
    <content><![CDATA[<h2 id="1-接收客户端提交的请求参数"><a href="#1-接收客户端提交的请求参数" class="headerlink" title="1. 接收客户端提交的请求参数"></a>1. 接收客户端提交的请求参数</h2><h3 id="1-1-使用HttpServletRequest接收请求参数"><a href="#1-1-使用HttpServletRequest接收请求参数" class="headerlink" title="1.1. 使用HttpServletRequest接收请求参数"></a>1.1. 使用HttpServletRequest接收请求参数</h3><p>在处理请求的方法的参数列表中，添加<code>HttpServletRequest</code>类型的参数，在处理请求的过程中，调用该参数对象的<code>getParameter()</code>方法即可获取请求参数；</p>
<h3 id="1-2-将请求参数设计为方法的参数"><a href="#1-2-将请求参数设计为方法的参数" class="headerlink" title="1.2. 将请求参数设计为方法的参数"></a>1.2. 将请求参数设计为方法的参数</h3><p>可以将客户端提交的请求参数直接声明为处理请求的方法的参数，并且，可以直接将参数声明为期望的数据类型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【处理注册请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_reg.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleReg</span><span class="params">(String username, String password, Integer age, String phone, String email)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleReg()"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"username="</span> + username);</span><br><span class="line">    System.out.println(<span class="string">"password="</span> + password);</span><br><span class="line">    System.out.println(<span class="string">"age="</span> + age);</span><br><span class="line">    System.out.println(<span class="string">"phone="</span> + phone);</span><br><span class="line">    System.out.println(<span class="string">"email="</span> + email);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Over"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种做法时，必须保证客户端提交的请求参数与服务器端处理请求的方法的参数的名称是一致的！如果名称不一致，默认情况下，则服务器端处理请求的方法中，对应的参数将是<code>null</code>！</p>
<p>如果服务器端决定不使用方法的参数名作为客户端应该提交的请求参数名称，还可以在方法的参数之前添加<code>@RequestParam</code>注解，以指定参数名，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleReg</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String aaaaa, String password)</span></span><br></pre></td></tr></table></figure>

<p>按照以上代码中的注解，则客户端必须按照<code>username</code>和<code>password</code>这2个名称来提交请求参数！</p>
<h2 id="1-3-使用封装的类型接收请求参数"><a href="#1-3-使用封装的类型接收请求参数" class="headerlink" title="1.3. 使用封装的类型接收请求参数"></a>1.3. 使用封装的类型接收请求参数</h2><p>可以事先自定义类，将需要接收的请求参数都声明为这个类的属性，同时，为这些属性生成Set / Get方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="keyword">private</span> String phone;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> username;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.username = username;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> password;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> phone;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.phone = phone;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> email;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.email = email;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"User [username="</span> + username + <span class="string">", password="</span> + password + <span class="string">", age="</span> + age + <span class="string">", phone="</span> + phone</span><br><span class="line">				+ <span class="string">", email="</span> + email + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将自定义的数据类型声明为处理请求的方法的参数即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【处理注册请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_reg.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleReg</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleReg()"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Over"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种做法，应该保证客户端提交的请求参数名称与以上<code>User</code>类中的属性名称相同，且<code>User</code>类中的各属性都有规范名称的Set / Get方法！</p>
<h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4. 小结"></a>1.4. 小结</h2><p>以上3种方式中，<code>1.1</code>是在任何情况下都不推荐使用的！</p>
<p>通常，当参数数量较少且固定（数量或意义）时，优先使用<code>1.2</code>的做法；</p>
<p>当参数数量较多或不固定时，优先使用<code>1.3</code>的做法。</p>
<p>以上各做法可以综合在一起同时使用！</p>
<h2 id="2-控制器向模版页面转发数据"><a href="#2-控制器向模版页面转发数据" class="headerlink" title="2. 控制器向模版页面转发数据"></a>2. 控制器向模版页面转发数据</h2><h3 id="2-1-通过HttpServletRequest转发数据"><a href="#2-1-通过HttpServletRequest转发数据" class="headerlink" title="2.1. 通过HttpServletRequest转发数据"></a>2.1. 通过HttpServletRequest转发数据</h3><p>在处理请求的方法的参数列表中添加<code>HttpServletRequest</code>类型的参数，当需要将某些数据显示到页面中时，调用该参数对象的<code>setAttribute(String name, Object value)</code>方法将数据封装到<code>HttpServletRequest</code>请求对象中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【处理登录请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_login.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleLogin</span><span class="params">(String username, String password, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleLogin()"</span>);</span><br><span class="line">    System.out.println(<span class="string">"username="</span> + username);</span><br><span class="line">    System.out.println(<span class="string">"password="</span> + password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设root/1234是正确的用户名/密码</span></span><br><span class="line">    <span class="comment">// 判断用户名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"root"</span>.equals(username)) &#123;</span><br><span class="line">        <span class="comment">// 用户名正确，需要判断密码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"1234"</span>.equals(password)) &#123;</span><br><span class="line">            <span class="comment">// 密码也正确，登录成功</span></span><br><span class="line">            <span class="comment">// 暂不考虑登录成功后的处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录失败，密码错误</span></span><br><span class="line">            String errorMessage = <span class="string">"登录失败，密码错误！"</span>;</span><br><span class="line">            request.setAttribute(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 登录失败，用户名错误</span></span><br><span class="line">        String errorMessage = <span class="string">"登录失败，用户名不存在！"</span>;</span><br><span class="line">        request.setAttribute(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Over."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于当前使用的是<code>Thymeleaf</code>框架，在HTML模版页面中，可以通过<code>Thymeleaf</code>表达式取出在控制器中封装到<code>HttpServletRequest</code>中的参数，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>操作失败！<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-通过ModelMap转发数据"><a href="#2-2-通过ModelMap转发数据" class="headerlink" title="2.2. 通过ModelMap转发数据"></a>2.2. 通过ModelMap转发数据</h2><p>使用<code>ModelMap</code>转发数据的做法与使用<code>HttpServletRequest</code>转发数据几乎相同！例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【处理登录请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_login.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleLogin</span><span class="params">(String username, String password, ModelMap modelMap)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleLogin()"</span>);</span><br><span class="line">    System.out.println(<span class="string">"username="</span> + username);</span><br><span class="line">    System.out.println(<span class="string">"password="</span> + password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设root/1234是正确的用户名/密码</span></span><br><span class="line">    <span class="comment">// 判断用户名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"root"</span>.equals(username)) &#123;</span><br><span class="line">        <span class="comment">// 用户名正确，需要判断密码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"1234"</span>.equals(password)) &#123;</span><br><span class="line">            <span class="comment">// 密码也正确，登录成功</span></span><br><span class="line">            <span class="comment">// 暂不考虑登录成功后的处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录失败，密码错误</span></span><br><span class="line">            String errorMessage = <span class="string">"登录失败，密码错误！！"</span>;</span><br><span class="line">            modelMap.addAttribute(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 登录失败，用户名错误</span></span><br><span class="line">        String errorMessage = <span class="string">"登录失败，用户名不存在！！"</span>;</span><br><span class="line">        modelMap.addAttribute(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Over."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-使用ModelAndView转发数据"><a href="#2-3-使用ModelAndView转发数据" class="headerlink" title="2.3. 使用ModelAndView转发数据"></a>2.3. 使用ModelAndView转发数据</h2><p>将处理请求的方法的返回值类型声明为<code>ModelAndView</code>类型，在方法返回<code>ModelAndView</code>对象之前，必须向该对象中封装视图名称与数据，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【处理登录请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_login.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleLogin</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleLogin()"</span>);</span><br><span class="line">    System.out.println(<span class="string">"username="</span> + username);</span><br><span class="line">    System.out.println(<span class="string">"password="</span> + password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设root/1234是正确的用户名/密码</span></span><br><span class="line">    <span class="comment">// 判断用户名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"root"</span>.equals(username)) &#123;</span><br><span class="line">        <span class="comment">// 用户名正确，需要判断密码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"1234"</span>.equals(password)) &#123;</span><br><span class="line">            <span class="comment">// 密码也正确，登录成功</span></span><br><span class="line">            <span class="comment">// 暂不考虑登录成功后的处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录失败，密码错误</span></span><br><span class="line">            String errorMessage = <span class="string">"MAV:登录失败，密码错误！！"</span>;</span><br><span class="line">            Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            model.put(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">            ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model);</span><br><span class="line">            <span class="keyword">return</span> mav;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 登录失败，用户名错误</span></span><br><span class="line">        String errorMessage = <span class="string">"MAV:登录失败，用户名不存在！！"</span>;</span><br><span class="line">        Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        model.put(<span class="string">"msg"</span>, errorMessage);</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3. 重定向"></a>3. 重定向</h2><p>当处理请求的方法的返回值类型是<code>String</code>类型时，返回<code>&quot;redirect:目标路径&quot;</code>即可实现重定向！</p>
<blockquote>
<p>当处理请求的方法的返回值类型是<code>String</code>类型时，如果希望执行转发，可以使用<code>&quot;forward:视图名称&quot;</code>的格式，由于转发是默认的行为，所以直接返回<code>&quot;视图名称&quot;</code>即可，不需要显式的添加<code>forward:</code>前缀。</p>
</blockquote>
<p><strong>关于转发与重定向的区别</strong></p>
<ul>
<li>转发是服务器内部的行为，具体表现为“控制器将请求转发给视图组件（可以有数据，也可以没有数据）”，对于客户端来说，只发出过1次请求，并且，只知道这1次请求的路径，在客户端的浏览器中，地址栏显示的URL也不会发生变化！同时，由于这是服务器内部的行为，所以，控制器可以向视图组件传递任意数据！从编写代码的角度来看，转发时，需要指定的是视图名称！</li>
<li>重定向的本质是客户端向服务器第1次发出请求后，服务器响应了302响应码，及目标路径，客户端收到这次响应后，由于响应码是<code>302</code>，会自动发出第2次请求，请求路径（目标）就是第1次请求时服务器端响应的目标路径！所以，总的来说，重定向至少发生了2次请求与响应的交互过程，由于是多次请求，并且，后续的请求目标路径对于客户端来说是已知的，所以，在客户端的浏览器中，地址栏显示的URL会发生变化！同时，由于整个过程是多次请求，由服务器端多个不同的控制器类（同一个控制器，但处理请求的方法不同）进行处理的，会导致在默认情况下，多次处理请求的过程中产生的数据无法共享使用或不便于传递！从编写代码的角度来看，重定向时，需要指定的是目标路径！</li>
</ul>
<h2 id="4-使用Session"><a href="#4-使用Session" class="headerlink" title="4. 使用Session"></a>4. 使用Session</h2><p>在处理请求的方法的参数列表中，可以直接添加<code>HttpSession</code>类型的参数，用于访问Session中的数据，添加参数后，在当前方法体中，就可以向Session中存入数据，也可以取出Session的数据，当然，只要存入了数据，在Session的有效期内，视图组件也可以直接获取Session中的数据！</p>
<p><strong>关于Session的消失：</strong></p>
<ul>
<li>服务器关机或重启；</li>
<li>超时；</li>
<li>关闭浏览器。</li>
</ul>
<p><strong>关于存入到Session中的数据：</strong></p>
<ul>
<li>用户身份的唯一标识，例如用户的id、用户名等；</li>
<li>高频率访问的数据，例如用户名、头像等；</li>
<li>不便于使用其它技术进行传递或共享的数据。</li>
</ul>
]]></content>
      <categories>
        <category>达内笔记</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC01</title>
    <url>/2020/07/04/08_SPRINGMVC_DAY01/</url>
    <content><![CDATA[<h2 id="1-SpringMVC框架的作用"><a href="#1-SpringMVC框架的作用" class="headerlink" title="1. SpringMVC框架的作用"></a>1. SpringMVC框架的作用</h2><p><strong>MVC</strong> = <strong>M</strong>odel（数据模型） + <strong>V</strong>iew（视图） + <strong>C</strong>ontroller（控制器）</p>
<p>SpringMVC框架主要解决了接收请求与处理响应的问题，也可以认为是解决了V-C交互的问题，与M其实没有关系。</p>
<p>在传统的Java EE的开发模式下，可能存在<code>Servlet</code>组件数量太多的问题，会导致项目的管理难度太大，且运行时，会有大量的<code>Servlet</code>对象长期占用内存的问题！</p>
<p>另外，传统的Java EE开发模式下，数据的处理过程中代码量相对较大，而SpringMVC非常大极度的简化了开发量！</p>
<h2 id="2-SpringMVC-HelloWorld"><a href="#2-SpringMVC-HelloWorld" class="headerlink" title="2. SpringMVC HelloWorld"></a>2. SpringMVC HelloWorld</h2><h4 id="2-1-案例目标"><a href="#2-1-案例目标" class="headerlink" title="2.1. 案例目标"></a>2.1. 案例目标</h4><p>最终程序运行后，打开浏览器，输入<code>http://localhost:8080/项目名/hello.do</code>即可看到自定义输出的内容。</p>
<h4 id="2-2-在Eclipse中添加Server"><a href="#2-2-在Eclipse中添加Server" class="headerlink" title="2.2. 在Eclipse中添加Server"></a>2.2. 在Eclipse中添加Server</h4><p>打开Eclipse的<strong>Servers</strong>面板，添加Tomcat，当添加成功后，在Eclipse的项目列表中，会出现<strong>Servers</strong>项目，在需要使用Tomcat时，必须保证该项目是存在且打开的状态。</p>
<h4 id="2-3-创建项目"><a href="#2-3-创建项目" class="headerlink" title="2.3. 创建项目"></a>2.3. 创建项目</h4><p>创建<strong>Maven Project</strong>，<strong>Group Id</strong>为<code>cn.tedu</code>，<strong>Artifact Id</strong>为<code>springmvc01</code>，<strong>Packaing</strong>必须选择<code>war</code>。</p>
<p>当项目创建出来后，对项目名称点右键，在项目属性的<strong>Targeted Runtimes</strong>中勾选Tomcat。</p>
<p>刚刚创建好的项目的<strong>pom.xml</strong>会报错，因为缺少<strong>web.xml</strong>文件，并且<code>&lt;failOnMissingWebXml&gt;</code>节点默认为<code>true</code>，结合指定Java版本的代码，在<strong>pom.xml</strong>中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">failOnMissingWebXml</span>&gt;</span>false<span class="tag">&lt;/<span class="name">failOnMissingWebXml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，还需要在<strong>pom.xml</strong>中添加<code>spring-webmvc</code>的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-创建初始化类"><a href="#2-4-创建初始化类" class="headerlink" title="2.4. 创建初始化类"></a>2.4. 创建初始化类</h4><p>创建<code>cn.tedu.spring</code>包，在这个包中创建<code>SpringMvcConfig</code>配置类，并在这个类上配置组件扫描：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringMvc的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cn.tedu.spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个包中创建<code>SpringMvcInitializer</code>类，作为整个项目的初始化类，该类需要继承自<code>AbstractAnnotationConfigDispatcherServletInitializer</code>类，并重写该类中的抽象方法，在重写的<code>getServletConfigClasses()</code>方法中，返回以上<code>SpringMvcConfig</code>类，在重写的<code>getServletMappings()</code>方法中，返回的字符串数组中配置<code>&quot;*.do&quot;</code>即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 项目的初始化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcInitializer</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">	<span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">		<span class="comment">// 当项目初始化时，会加载当前方法的返回值</span></span><br><span class="line">		<span class="comment">// 类似于创建了AnnotationConfigApplicationContext的对象，并且把当前方法的返回值作为构造方法参数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Class[] &#123; SpringMvcConfig<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">		<span class="comment">// 所有以 .do 为后缀的请求都由SpringMVC框架处理</span></span><br><span class="line">		<span class="comment">// 之所以使用 .do 是因为它不是一个正常的扩展名</span></span><br><span class="line">		<span class="comment">// 可以与访问普通的文件区分开来</span></span><br><span class="line">		<span class="comment">// 也可以换成其它后缀，例如 .action</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"*.do"</span> &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上2个类都可以不必放在<code>cn.tedu.spring</code>包中，但是，应该为这2个类确定一个合理的包名。</p>
</blockquote>
<h4 id="2-5-使用控制器接收并处理请求"><a href="#2-5-使用控制器接收并处理请求" class="headerlink" title="2.5. 使用控制器接收并处理请求"></a>2.5. 使用控制器接收并处理请求</h4><p>在组件扫描的<code>cn.tedu.spring</code>包中创建<code>HelloController</code>类，并在类的声明之前添加<code>@Controller</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制器类，SpringMVC框架中的控制器的名称是自定义的，并且，不需要继承自某个类，也不需要实现某个接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在这个中添加以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @RequestMapping用于配置请求路径</span></span><br><span class="line"><span class="comment">// 后续，当项目运行时，按照这个路径来访问</span></span><br><span class="line"><span class="comment">// 就会导致接下来的方法被执行</span></span><br><span class="line"><span class="comment">// 接下来的方法就相当于Servlet中的service()方法</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello.do"</span>)</span><br><span class="line"><span class="comment">// @ResponseBody表示响应正文</span></span><br><span class="line"><span class="comment">// 会导致接下来的方法的返回值会直接响应到客户端去</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：不要返回中文或中文的标点符号，默认不支持</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, SpringMVC!!!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-SpringMVC框架的核心组件"><a href="#3-SpringMVC框架的核心组件" class="headerlink" title="3. SpringMVC框架的核心组件"></a>3. SpringMVC框架的核心组件</h2><ul>
<li><code>DispatcherServlet</code>：前端控制器，负责接收所配置的所有请求（假设配置为<code>*.do</code>，则它将接收所有以<code>.do</code>为后缀的请求），并负责分发这些请求；</li>
<li><code>HandlerMapping</code>：记录了请求路径与处理请求的<code>Controller</code>或其方法的对应关系，</li>
<li><code>Controller</code>：控制器，负责处理具体的请求，每个项目中可能有若干个<code>Controller</code>组件，每个<code>Controller</code>组件中可以有若干个处理请求的方法；</li>
<li><code>ModelAndView</code>：控制器处理完请求后得到的结果，该结果可以包含数据与视图名称；</li>
<li><code>ViewResovler</code>：视图解析器，可以根据视图名称来确定具体的视图组件。</li>
</ul>
<h2 id="4-显示html模版页面"><a href="#4-显示html模版页面" class="headerlink" title="4. 显示html模版页面"></a>4. 显示html模版页面</h2><p>先在<strong>src/main/resources</strong>下创建<strong>templates</strong>文件夹，然后，在该文件夹创建<strong>register.html</strong>页面，页面的内容可以自行设计。</p>
<p>然后，在控制器中，将处理请求的方法之前的<code>@ResponseBody</code>注解去掉，并将方法的返回值改为<code>register</code>（HTML文件的名称），例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【显示注册页面】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"reg.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"register"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在<strong>pom.xml</strong>中添加<code>thymeleaf</code>和<code>thymeleaf-spring4</code>/<code>thymeleaf-spring5</code>的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并在<code>SpringMvcConfig</code>中添加关于<code>ViewResolver</code>的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String characterEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoaderTemplateResolver templateResolver = <span class="keyword">new</span> ClassLoaderTemplateResolver();</span><br><span class="line">    templateResolver.setCharacterEncoding(characterEncoding);</span><br><span class="line">    templateResolver.setCacheable(<span class="keyword">false</span>);</span><br><span class="line">    templateResolver.setTemplateMode(<span class="string">"HTML"</span>);</span><br><span class="line">    templateResolver.setPrefix(<span class="string">"/templates/"</span>); <span class="comment">// 前缀</span></span><br><span class="line">    templateResolver.setSuffix(<span class="string">".html"</span>); <span class="comment">// 后缀</span></span><br><span class="line"></span><br><span class="line">    SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">    templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line"></span><br><span class="line">    ThymeleafViewResolver viewResolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">    viewResolver.setCharacterEncoding(characterEncoding);</span><br><span class="line">    viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上配置中，需要关注的就是配置“前缀”和“后缀”的2条配置！SpringMVC框架在使用以上视图解析器时，会将“前缀”、“控制器方法返回的视图名称”、“后缀”拼接起来，得到具体用于显示的视图组件，以上代码中，拼接起来的值就是<code>/templates/register.html</code>，能够指向所设计的网页文件！当然，也可以采取其它的组件方式，例如“前缀”和“后缀”都配置为空字符串，而方法的返回值直接返回<code>&quot;/templates/register.html&quot;</code>也是可以的！</p>
<p>另外，以上代码中使用到了<code>ClassLoaderTemplateResolver</code>模版解析器，该模版解析器在工作时，默认会在项目的<strong>src/main/resources</strong>下查找视图组件，所以，视图文件（HTML）文件必须放在这个位置！还可以使用<code>ServletContextTemplateResolver</code>模版解析器，其查找视图组件的位置是在<strong>webapp</strong>下。</p>
<h2 id="5-接收客户端提交的请求参数"><a href="#5-接收客户端提交的请求参数" class="headerlink" title="5. 接收客户端提交的请求参数"></a>5. 接收客户端提交的请求参数</h2><p>在SpringMVC框架中，将“客户端提交的请求参数”直接声明为“处理请求的方法的参数”即可，甚至，还可以将参数直接声明为所期望的类型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【处理注册请求】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"handle_reg.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleReg</span><span class="params">(String username, String password, Integer age, String phone, String email)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.handleReg()"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"username="</span> + username);</span><br><span class="line">    System.out.println(<span class="string">"password="</span> + password);</span><br><span class="line">    System.out.println(<span class="string">"age="</span> + age);</span><br><span class="line">    System.out.println(<span class="string">"phone="</span> + phone);</span><br><span class="line">    System.out.println(<span class="string">"email="</span> + email);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Over"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-SpringMVC执行流程图"><a href="#6-SpringMVC执行流程图" class="headerlink" title="6.SpringMVC执行流程图"></a>6.SpringMVC执行流程图</h2><p><img src= "/img/loading.gif" data-src="/img/SpringMVC.png" alt="SpringMVC执行流程图"></p>
]]></content>
      <categories>
        <category>达内笔记</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC03</title>
    <url>/2020/07/06/08_SPRINGMVC_DAY03/</url>
    <content><![CDATA[<h2 id="1-关于-RequestMapping注解"><a href="#1-关于-RequestMapping注解" class="headerlink" title="1. 关于@RequestMapping注解"></a>1. 关于@RequestMapping注解</h2><p>在控制器中，在处理请求的方法之前添加<code>@RequestMapping</code>注解，可以配置请求路径与处理请求的方法的映射关系！</p>
<p>在<code>@RequestMapping</code>注解的源代码中有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The primary mapping expressed by this annotation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is an alias for &#123;<span class="doctag">@link</span> #path&#125;. For example,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@RequestMapping</span>("/foo")&#125; is equivalent to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@RequestMapping</span>(path="/foo")&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Supported at the type level as well as at the method level!&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * When used at the type level, all method-level mappings inherit</span></span><br><span class="line"><span class="comment"> * this primary mapping, narrowing it for a specific handler method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: A handler method that is not mapped to any path</span></span><br><span class="line"><span class="comment"> * explicitly is effectively mapped to an empty path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>由于<code>value</code>是默认的属性，所以，平时所使用到的<code>@RequestMapping(&quot;reg.do&quot;)</code>其实配置的就是这个<code>value</code>属性的值！</p>
<p>它的数据类型是<code>String[]</code>，所以，在配置时，可以同时配置多个路径！例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【显示注册页面】</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(&#123;<span class="string">"reg.do"</span>, <span class="string">"register.do"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController.reg()"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"register"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则通过<code>reg.do</code>和<code>register.do</code>均可使得<code>reg()</code>方法被执行，而方法的代码是不变的，最终的效果就是这2个路径都可以打开同一个页面！</p>
<p>在源代码中，还有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The path mapping URIs (e.g. &#123;<span class="doctag">@code</span> "/profile"&#125;).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Ant-style path patterns are also supported (e.g. &#123;<span class="doctag">@code</span> "/profile/**"&#125;).</span></span><br><span class="line"><span class="comment"> * At the method level, relative paths (e.g. &#123;<span class="doctag">@code</span> "edit"&#125;) are supported</span></span><br><span class="line"><span class="comment"> * within the primary mapping expressed at the type level.</span></span><br><span class="line"><span class="comment"> * Path mapping URIs may contain placeholders (e.g. &lt;code&gt;"/$&#123;profile_path&#125;"&lt;/code&gt;).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Supported at the type level as well as at the method level!&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * When used at the type level, all method-level mappings inherit</span></span><br><span class="line"><span class="comment"> * this primary mapping, narrowing it for a specific handler method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: A handler method that is not mapped to any path</span></span><br><span class="line"><span class="comment"> * explicitly is effectively mapped to an empty path.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>结合以上2段源代码，可以看到<code>value</code>属性与<code>path</code>属性是完全相同的！如果需要显式的指定属性名称时，使用<code>path</code>可以更好的表现语义，该属性名称是从4.2版本加入的！</p>
<p>在源代码还有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The HTTP request methods to map to, narrowing the primary mapping:</span></span><br><span class="line"><span class="comment"> * GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Supported at the type level as well as at the method level!&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * When used at the type level, all method-level mappings inherit</span></span><br><span class="line"><span class="comment"> * this HTTP method restriction (i.e. the type-level restriction</span></span><br><span class="line"><span class="comment"> * gets checked before the handler method is even resolved).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>以上源代码说明在使用<code>@RequestMapping</code>时，可以配置名为<code>method</code>的属性，该属性的值的类型是<code>RequestMethod[]</code>类型，默认值是无。</p>
<p>该属性的作用是“配置所映射的HTTP请求方式”，如果没有配置该属性，表示“可以通过任何请求方式访问该路径”！如果显式的配置了该属性，则只有配置值对应的请求方式才是允许的，而没有被配置值的请求方式将不被允许！</p>
<p>例如，将请求方式限制为POST类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"handle_reg.do"</span>, method=RequestMethod.POST)</span><br></pre></td></tr></table></figure>

<p>如果仍尝试使用GET或其它不被允许的请求方式，将会出现405错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP Status 405 – Method Not Allowed</span><br></pre></td></tr></table></figure>

<p>并且，还伴随具体的提示信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Request method &#39;GET&#39; not supported</span><br></pre></td></tr></table></figure>

<p>由于<code>method</code>属性的值类型是<code>RequestMethod[]</code>，所以，可以设置为允许多种请求方式，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"login.do"</span>, method=&#123;RequestMethod.GET, RequestMethod.POST&#125;)</span><br></pre></td></tr></table></figure>

<p>如果需要将请求方式限制为固定的某1种，还可以使用简化后的注解！例如使用<code>@PostMapping</code>注解，就可以将请求方式限制为<code>POST</code>类型，在使用时，只需要配置请求路径即可，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @RequestMapping(value="handle_reg.do", method=RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"handle_reg.do"</span>)</span><br></pre></td></tr></table></figure>

<p>在<code>@PostMapping</code>注解的源代码中，关于该注解的声明是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PostMapping &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该注解的声明之前添加了<code>@RequestMapping(method = RequestMethod.POST)</code>就表示当前<code>@PostMapping</code>注解具有<code>@RequestMapping</code>的作用特点且已经将请求方式限制为<code>POST</code>了！</p>
<p>除此以外，还有<code>@GetMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>、<code>@PatchMapping</code>，均对应某1种请求方式！</p>
<p><strong>小结：如果需要将请求方式限制为某1种，则应该使用以上这些简化的注解，如果需要同时允许多种不同的请求方式，应该使用<code>@RequestMapping</code>！</strong></p>
<p>关于<code>@RequestMapping</code>注解，除了添加在处理请求的方法之前，还可以添加在控制器类的声明之前！例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当控制器类的声明之前配置了<code>@RequestMapping(&quot;user&quot;)</code>后，当前类中映射的所有请求路径中都需要添加<code>user</code>这个层级，例如，在没有添加该配置之前时，访问路径是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;springmvc02&#x2F;reg.do</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;springmvc02&#x2F;login.do</span><br></pre></td></tr></table></figure>

<p>添加了配置之后，访问路径是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;springmvc02&#x2F;user&#x2F;reg.do</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;springmvc02&#x2F;user&#x2F;login.do</span><br></pre></td></tr></table></figure>

<p><strong>通常，推荐为每一个控制器类的声明之前都添加该注解的配置！</strong></p>
<p>可以看到 ，SpringMVC框架在处理配置的路径时，会把类之前的<code>@RequestMapping</code>配置值与方法之前的配置值拼接起来作为完整的访问路径，但是，开发人员并不需要考虑配置值的左右两侧的<code>/</code>符号，例如以下配置是等效的：</p>
<table>
<thead>
<tr>
<th>在控制器类之前的配置</th>
<th>在方法之前的配置</th>
</tr>
</thead>
<tbody><tr>
<td><strong>user</strong></td>
<td><strong>reg.do</strong></td>
</tr>
<tr>
<td>user</td>
<td>/reg.do</td>
</tr>
<tr>
<td>user/</td>
<td>reg.do</td>
</tr>
<tr>
<td>user/</td>
<td>/reg.do</td>
</tr>
<tr>
<td>/user</td>
<td>reg.do</td>
</tr>
<tr>
<td>/user</td>
<td>/reg.do</td>
</tr>
<tr>
<td>/user/</td>
<td>reg.do</td>
</tr>
<tr>
<td>/user/</td>
<td>/reg.do</td>
</tr>
</tbody></table>
<p>在实际使用时，推荐使用第1种即可！如果使用其它的配置风格也是可以的，但是，在同一个项目中，应该只使用1种风格的配置！</p>
<h2 id="2-拦截器"><a href="#2-拦截器" class="headerlink" title="2. 拦截器"></a>2. 拦截器</h2><p>拦截器（<code>Interceptor</code>）在SpringMVC框架中可以作用于若干个不同的请求，且经过拦截器的处理后，可以选择对这些请求进行阻止（不允许继续向后续的流程中执行），或选择放行！</p>
<blockquote>
<p>注意：拦截器的作用并不一定是”拦“下来就不允许执行了，可能某些拦截器的做法就是”拦“下来后全部放行！</p>
</blockquote>
<p>当需要要使用拦截器时，首先，需要自定义类，实现<code>HandlerInterceptor</code>接口，并在重写的方法中添加输出语句，以便于观察方法的执行时间点及执行的先后顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"LoginInterceptor.preHandle()"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"LoginInterceptor.postHandle()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"LoginInterceptor.afterCompletion()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，还需要对拦截器进行配置，关于该配置的写法要求：</p>
<ul>
<li>相关的配置需要写在某个类中，这个类需要实现<code>WebMvcConfigurer</code>接口，且在类的声明之前必须添加<code>@Configuration</code>和<code>@EnableWebMvc</code>这2个注解，且这个类的对象必须是初始化类的<code>getServletConfigClasses()</code>方法的返回值；</li>
<li>在以上类中重写<code>addInterceptors()</code>方法，以配置拦截器。</li>
</ul>
<p>例如使用原本存在的<code>SpringMvcConfig</code>为作配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cn.tedu.spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String characterEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 省略</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">		HandlerInterceptor interceptor = <span class="keyword">new</span> LoginInterceptor();</span><br><span class="line">		<span class="comment">// 注意：表示拦截器处理的路径时，各路径必须使用 / 作为第1个字符</span></span><br><span class="line">		registry.addInterceptor(interceptor).addPathPatterns(<span class="string">"/index.do"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个项目中，允许同时存在若干个拦截器，配置的先后顺序决定了执行顺序，如果某个请求会经过多个拦截器，只有这些拦截器全部都放行，才可以继续向后执行，只要其中任何一个拦截器的处理结果是阻止运行，该请求就不可以向后执行了！</p>
<p>通过运行效果可以观察到：</p>
<ul>
<li>当拦截器中的<code>preHandle()</code>方法返回<code>true</code>时，会行执行拦截器中的<code>preHandle()</code>方法，再执行需要请求的控制器中的方法，再执行拦截器中的<code>postHandle()</code>和<code>afterCompletion()</code>方法；</li>
<li>当拦截器中的<code>preHandle()</code>方法返回<code>false</code>时，只会执行拦截器中的<code>preHandle()</code>方法，且客户端的浏览器窗口将显示一片空白。</li>
<li>只有拦截器中的<code>preHandle()</code>方法才是真正意义上的”拦截“方法！</li>
</ul>
<p>回到<code>LoginInterceptor</code>类中，重写<code>preHandle()</code>方法以判断阻止或放行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"LoginInterceptor.preHandle()"</span>);</span><br><span class="line">    <span class="comment">// 如果已经登录，则放行，如果未登录，则阻止且重定向到登录界面</span></span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line">    <span class="keyword">if</span> (session.getAttribute(<span class="string">"username"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        String contextPath = request.getContextPath();</span><br><span class="line">        response.sendRedirect(contextPath + <span class="string">"/user/login.do"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于拦截器的配置，首先，每个拦截器都可以配置若干个拦截的路径！关于配置拦截路径时调用的<code>addPathPatterns()</code>方法，其源代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add URL patterns to which the registered interceptor should apply to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InterceptorRegistration <span class="title">addPathPatterns</span><span class="params">(String... patterns)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addPathPatterns(Arrays.asList(patterns));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List-based variant of &#123;<span class="doctag">@link</span> #addPathPatterns(String...)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InterceptorRegistration <span class="title">addPathPatterns</span><span class="params">(List&lt;String&gt; patterns)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.includePatterns.addAll(patterns);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际使用时，可以写成例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry.addInterceptor(interceptor).addPathPatterns(<span class="string">"/index.do"</span>, <span class="string">"/user/password.do"</span>);</span><br></pre></td></tr></table></figure>

<p>或者写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; pathPatterns = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">pathPatterns.add(<span class="string">"/index.do"</span>);</span><br><span class="line">pathPatterns.add(<span class="string">"/user/password.do"</span>);</span><br><span class="line">registry.addInterceptor(interceptor).addPathPatterns(pathPatterns);</span><br></pre></td></tr></table></figure>

<p>在配置路径时，还可以使用星号(<code>*</code>)作为通配符，例如，可以将<code>/blog/*</code>配置到拦截路径中，则<code>/blog/delete.do</code>、<code>/blog/edit.do</code>等路径都可以被匹配！</p>
<p>但是，需要注意的是：1个星号(<code>*</code>)只能表示某层级下的资源，不可以匹配到若干个层级！例如配置为<code>/blog/*</code>时，就无法匹配到<code>/blog/2020/list.do</code>！如果一定匹配若干个层级，必须使用2个连续的星号(<code>**</code>)，例如配置为<code>/blog/**</code>，则可以匹配到<code>/blog/list.do</code>、<code>/blog/2020/list.do</code>、<code>/blog/2020/07/list.do</code>……</p>
<p>在注册拦截器之后，还可以调用<code>excludePathPatterns()</code>方法添加”排除“的路径，被”排除“的路径将不会被拦截器处理！所以，也可以理解为”例外“或”白名单“，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; pathPatterns = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">pathPatterns.add(<span class="string">"/user/reg.do"</span>);</span><br><span class="line">pathPatterns.add(<span class="string">"/user/handle_reg.do"</span>);</span><br><span class="line">pathPatterns.add(<span class="string">"/user/login.do"</span>);</span><br><span class="line">pathPatterns.add(<span class="string">"/user/handle_login.do"</span>);</span><br><span class="line">registry.addInterceptor(interceptor)</span><br><span class="line">    .addPathPatterns(<span class="string">"/user/**"</span>)</span><br><span class="line">    .excludePathPatterns(pathPatterns);</span><br></pre></td></tr></table></figure>

<p>注意：在调用方法时，必须先调用<code>addPathPatterns()</code>方法然后再调用<code>excludePathPatterns()</code>方法！</p>
<h2 id="3-拦截器与过滤器的区别"><a href="#3-拦截器与过滤器的区别" class="headerlink" title="3. 拦截器与过滤器的区别"></a>3. 拦截器与过滤器的区别</h2><p><strong>【相同/相似】</strong></p>
<p>拦截器与过滤器都是可以作用于若干个不同的请求的，在处理请求之前将执行拦截器或过滤器中的代码，并且，都能够实现放行或阻止的效果，并且，都有”链“的概念，在同一个项目中允许存在若干个拦截器或过滤器，同一个请求需要经历多个拦截器或过滤器，只有这些拦截器或过滤器全部放行，才能向后执行！</p>
<p><strong>【区别】</strong></p>
<ul>
<li>过滤器Filter是Java EE中的组件，则任何Java EE项目都可以使用过滤器，而拦截器Interceptor是SpringMVC框架中的组件，只有使用了SpringMVC框架的Java EE项目才可以使用拦截器，并且，只有被SpringMVC框架处理的请求才可能被拦截器处理，例如将SpringMVC框架处理的路径设置为<code>*.do</code>时，直接访问HTML页面、图片等资源将不会被拦截器处理；</li>
<li>过滤器Filter是执行在所有Servlet组件之前的，而拦截器Interceptor的第1次执行是在<code>DispatcherServlet</code>之后，且在Controller组件之前的（当然，使用过滤器时，也许是通过Servlet来处理请求的，使用拦截器时，是通过Controller来处理请求的，所以，这2者都是在处理请求之前执行，所以，一般情况下，差异并不明显）；</li>
<li>过滤器Filter只能配置过滤路径（黑名单），而拦截器Interceptor既可以配置拦截路径（黑名单），又可以配置排除路径（例外，白名单），后者的配置更加灵活！</li>
</ul>
<p><strong>【小结】</strong></p>
<p>通过分析以上区别，可以发现：通过过滤器Filter实现的效果，改为使用拦截器Interceptor基本上都可以实现！同时，拦截器还具备”配置更加灵活“的特点，所以，在绝大部分情况下，应该优先使用拦截器！</p>
<p>当然，过滤器也具有拦截器无法取代的特点，就是”执行时间点“非常早，它是执行在所有Servlet组件之前的，所以，如果某个需要被”拦“下来执行的任务是非常早期就要执行，则必须使用过滤器！</p>
<p>例如，SpringMVC框架默认使用的编码是<code>ISO-8859-1</code>，是不支持中文的，所以，使用<code>POST</code>提交的请求参数中，只要存在非ASCII码字符，就会出现乱码，如果需要自定义编码，需要在项目的初始化类中重写<code>getServletFilters()</code>方法，并在该方法中返回SpringMVC框架自带的字符编码过滤器，且设置编码，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Filter[] &#123; <span class="keyword">new</span> CharacterEncodingFilter(<span class="string">"UTF-8"</span>) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-SpringMVC阶段小结"><a href="#4-SpringMVC阶段小结" class="headerlink" title="4. SpringMVC阶段小结"></a>4. SpringMVC阶段小结</h2><ul>
<li>【理解】SpringMVC框架的作用：解决V-C交互的问题；</li>
<li>【理解】SpringMVC框架的核心执行流程图；</li>
<li>【掌握】通过SpringMVC框架接收并处理客户端的请求：<ul>
<li>SpringMVC项目的搭建：添加<code>spring-webmvc</code>依赖，配置不使用<strong>web.xml</strong>，添加Tomcat环境，创建SpringMVC的配置类，创建初始化项目的类并加载SpringMVC的配置类、设置SpringMVC框架所处理的请求路径；</li>
<li>创建控制器类：自定义名称，必须放在组件扫描的包或其子孙包中，必须添加<code>@Controller</code>注解；</li>
<li>创建处理请求的方法：使用<code>@RequestMapping</code>系列注解配置请求路径，使用<code>public</code>访问权限，暂定使用<code>String</code>作为返回值类型，方法名称可以自定义，方法的参数列表可以按需设计。</li>
</ul>
</li>
<li>【掌握】通过SpringMVC框架接收客户端提交的请求参数：<ul>
<li>将请求参数逐一声明为处理请求的方法的参数；</li>
<li>将多个请求参数封装到自定义对象中，并将自定义的数据类型声明为处理请求的方法的参数。</li>
</ul>
</li>
<li>【掌握】使用SpringMVC封装转发的数据到视图组件，并且在视图组件显示转发的数据；</li>
<li>【理解】转发与重定向的区别；</li>
<li>【掌握】Session的使用原则与使用方式；</li>
<li>【掌握】拦截器的使用与配置；</li>
<li>【理解】拦截器与过滤器的区别；</li>
<li>【掌握】解决POST请求中文乱码的问题；</li>
<li>【掌握】阅读简单的注解源代码，例如<code>@RequestMapping</code>、<code>@RequestParam</code>等。</li>
</ul>
]]></content>
      <categories>
        <category>达内笔记</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring02</title>
    <url>/2020/07/01/07_SPRING_DAY02/</url>
    <content><![CDATA[<h2 id="1-组件扫描"><a href="#1-组件扫描" class="headerlink" title="1. 组件扫描"></a>1. 组件扫描</h2><p>首先，必须让Spring扫描组件所在的包，并且，组件类的声明之前必须添加<code>@Component</code>注解！</p>
<p>其实，除了<code>@Component</code>注解以外，还可以使用以下注解实现同样的效果：</p>
<ul>
<li><code>@Controller</code>:推荐添加在<strong>控制器类</strong>之前;</li>
<li><code>@Service</code>:推荐添加在<strong>业务类</strong>之前;</li>
<li><code>@Repository</code>:推荐添加在<strong>处理持久层的类</strong>之前.</li>
</ul>
<p>以上4个注解在Spring框架的作用领域中，效果是完全相同的，用法也完全相同，只是<strong>语义</strong>不同。</p>
<p>在使用组件扫描时，还可以自定义某个类，作为配置类，在这个类的声明之前使用<code>@ComponentScan</code>注解来配置组件扫描的包：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cn.tedu.spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续,程序运行时,就需要加载这个配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ac </span><br><span class="line">    = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>关于组件扫描的包，严格来说，是配置需要被扫描的“<strong>根包</strong>（base package）”，也就是说，在执行扫描时，会扫描所设置的包及其所有子孙包中的所有组件类！当设置为扫描<code>cn.tedu</code>包时，会把<code>cn.tedu.spring</code>甚至<code>cn.tedu.spring.dao</code>这些包中的组件类都扫描到！</p>
<h2 id="2-关于注解的使用"><a href="#2-关于注解的使用" class="headerlink" title="2. 关于注解的使用"></a>2. 关于注解的使用</h2><p>以<code>@Bean</code>注解为例，其声明是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，注解都是通过<code>@interface</code>声明的！</p>
<p>在注解的声明之前，还添加了一系列的注解，例如以上的<code>@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})</code>、<code>@Retention(RetentionPolicy.RUNTIME)</code>、<code>@Documented</code>，则表示当前<code>@Bean</code>注解同时具有以上3个注解的特性。也就是说，<code>@Bean</code>注解相当于以上3个注解的同时，还具有自身的特性！</p>
<p>在<code>@Bean</code>注解内部，还有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Alias for &#123;<span class="doctag">@link</span> #name&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Intended to be used when no other attributes are needed, for example:</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>("customBeanName")&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.3.3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>以上<code>String[] value() default {};</code>有点像接口中的抽象方法，但是，在注解中，这是声明的注解属性！<code>value</code>是属性名称，所以，在使用当前注解时，可以配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=???)</span><br></pre></td></tr></table></figure>

<p>以上源代码中的<code>String[]</code>看似是抽象方法的返回值，实则是<code>value</code>属性的值的数值类型！所以，可以配置为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>以上源代码中的<code>default {}</code>表示该属性的默认值，所以，以下2段配置是完全等效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>在配置注解属性时，如果属性名称是<code>value</code>，它是默认的属性，在配置时，可以不用显式的写出<code>value=</code>部分，也就是说，以下2段配置是完全等效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>在配置注解属性时，如果属性的值的类型是数组类型，但是，当前只需要配置1个值时，可以不用写成数组格式，只需要写成数组元素的格式即可！也就是说，以下2段配置是完全等效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(&#123;<span class="string">"a"</span>&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"a"</span>)</span><br></pre></td></tr></table></figure>

<p>所以，总的来说，关于<code>@Bean</code>注解的<code>value</code>属性，如果需要配置的值是<code>&quot;user&quot;</code>，则以下4段代码都是完全等效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"user"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(&#123;<span class="string">"user"</span>&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=<span class="string">"user"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=&#123;<span class="string">"user"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>在以上源代码中，注释中还标明了<code>@since 4.3.3</code>，表示该属性从Spring框架4.3.3版本开始才加入的，如果当前使用的环境改为4.3.3以下的版本，将导致该属性不可用，因为在更低的版本中，根本就没有这个属性，甚至可能连个注解本身都不存在！</p>
<p>在以上源代码中，在<code>value</code>属性的声明之前还添加了<code>@AliasFor(&quot;name&quot;)</code>注解，表示当前<code>value</code>属性另有<strong>别名</strong>为<code>name</code>，所以，在<code>@Bean</code>注解的源代码中，还有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The name of this bean, or if several names, a primary bean name plus aliases.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If left unspecified, the name of the bean is the name of the annotated method.</span></span><br><span class="line"><span class="comment"> * If specified, the method name is ignored.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The bean name and aliases may also be configured via the &#123;<span class="doctag">@link</span> #value&#125;</span></span><br><span class="line"><span class="comment"> * attribute if no other attributes are declared.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>则在<code>@Bean</code>注解中，<code>name</code>和<code>value</code>这2个注解是完全等效的！</p>
<p>之所以存在2个完全等效的属性，是因为：</p>
<ul>
<li><code>value</code>属性是默认的，在配置时可以不必显式的写出<code>value=</code>部分，配置时更加简单；</li>
<li><code>name</code>属性表现的语义更好，更易于根据源代码读懂程序的意思，在其它注解中，也可能存在与<code>value</code> 等效的属性。</li>
</ul>
<p>需要注意的是：在配置注解中的属性时，如果需要配置的是<code>value</code>属性的值，可以不用显式的写出<code>value=</code>部分，<strong>前提是当前注解只配置<code>value</code>这1个属性</strong>！如果需要配置多个属性，则必须写出每一个属性名，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(value=<span class="string">"user"</span>, initMethod=<span class="string">"init"</span>)</span><br></pre></td></tr></table></figure>

<p>而不能写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"user"</span>, initMethod=<span class="string">"init"</span>)	<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h2 id="3-使用组件扫描后配置作用域与生命周期"><a href="#3-使用组件扫描后配置作用域与生命周期" class="headerlink" title="3. 使用组件扫描后配置作用域与生命周期"></a>3. 使用组件扫描后配置作用域与生命周期</h2><p>在类的声明之前，添加<code>@Scope(&quot;prototype&quot;)</code>即可将当前类配置为“非单例”的对象！例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在单例的情况下，在类的声明之前添加<code>@Lazy</code>注解，就可以将对象配置为“懒加载”的模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要配置当前类中的生命周期的处理，首先，还是需要在类中自定义2个方法，分别表示“初始化方法”和“销毁方法”，然后，在初始化方法之前添加<code>@PostConstruct</code>注解，在销毁方法之前添加<code>@PreDestroy</code>注解，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"User.User()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"User.init()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@PreDestroy</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"User.destroy()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：以上2个注解并不是Spring的注解，如果JRE环境版本太低，将无法识别以上2个注解，需要调整当前项目的JRE环境！</p>
<h2 id="4-关于Spring管理对象的小结"><a href="#4-关于Spring管理对象的小结" class="headerlink" title="4. 关于Spring管理对象的小结"></a>4. 关于Spring管理对象的小结</h2><p>如果需要Spring管理某个类的对象，可以：</p>
<ul>
<li>自定义方法，将方法的返回值类型设置为期望管理的类型，并在方法中返回匹配类型的对象，最后，在方法的声明之前添加<code>@Bean</code>注解；</li>
<li>设置组件扫描的包，并在类的声明之前添加<code>@Component</code> / <code>@Controller</code> / <code>@Service</code> / <code>@Repository</code>这4个注解中的某1个。</li>
</ul>
<p>在实际使用时，大多采取第2种做法，但是，如果需要Spring管理的类并<strong>不是自定义的类</strong>，就只能采取第1种做法！</p>
<h2 id="5-关于Spring的解耦"><a href="#5-关于Spring的解耦" class="headerlink" title="5. 关于Spring的解耦"></a>5. 关于Spring的解耦</h2><p>在没有使用Spring框架的情况下，在项目中，各组件之间是存在依赖关系的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理用户登录请求的Servlet组件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserJdbcDao userDao = <span class="keyword">new</span> UserJdbcDao();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理用户数据增删改查的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserJdbcDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过JDBC技术实现数据查询，判断用户名与密码是否正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就体现了类与类之前的<strong>依赖</strong>关系，具体表现就是<code>UserLoginServlet</code>是依赖于<code>UserJdbcDao</code>的！</p>
<p>如果直接依赖于某个类，将会导致<strong>耦合度过高</strong>的问题！</p>
<p>假设在<code>UserJdbcDao</code>中，是通过原生的JDBC技术实现数据访问的，后续，需要改为使用MyBatis框架技术来实现，则可能创建<code>UserMybatisDao</code>类，用于取代<code>UserJdbcDao</code>类！</p>
<p>如果需要替换，则项目中原有的以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserJdbcDao userDao = <span class="keyword">new</span> UserJdbcDao();</span><br></pre></td></tr></table></figure>

<p>全部需要替换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserMybatisDao userDao = <span class="keyword">new</span> UserMybatisDao();</span><br></pre></td></tr></table></figure>

<p>这种<strong>替换时需要调整大量原有代码</strong>的问题，就是<strong>高耦合</strong>的问题，我们希望的目标是<strong>低耦合</strong>，将原有<strong>高耦合</strong>的项目调整为<strong>低耦合</strong>的状态，就是<strong>解耦</strong>的做法！</p>
<p>可以将处理用户数据增删改查的相关操作声明在接口中，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，各个处理用户数据增删改查的类都去实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserJdbcDao</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过JDBC实现处理用户登录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMybatisDao</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过MyBatis框架技术实现处理用户登录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续，在各个Servlet组件中，就可以声明为接口类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserMybatisDao();</span><br></pre></td></tr></table></figure>

<p>通过以上代码调整，就可以使得Servlet组件<strong>依赖于接口</strong>，而不再是<strong>依赖于类</strong>，从而实现了解耦！</p>
<p>另外，还可以通过设计模式中的工厂模式来生产对象，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserMybatisDao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有了以上工厂后，原本在Servlet组件中声明持久层对象的代码就可以再调整为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao = UserDaoFactory.newInstance();</span><br></pre></td></tr></table></figure>

<p>至此，在项目中到底是使用<code>UserJdbcDao</code>还是使用<code>UserMybatisDao</code>，在以上代码都不会体现出来了，也就意味着当需要切换/替换时，以上代码是不需要修改的，而是修改<code>UserDaoFactory</code>工厂类的方法的返回值这1处即可！</p>
<p>所以，通过定义接口和创建工厂类就可以实现解耦，但是，在实际项目开发时，不可能为每一个组件都创建专门的工厂类，而Spring框架就可以当作是一个庞大的工厂，开发人员可以通过Spring框架的使用约定，将某些类的对象交给Spring框架进行管理，后续，在具体使用过程中，就不必自行创建对象，而是<strong>获取</strong>对象即可！</p>
<h2 id="6-自动装配"><a href="#6-自动装配" class="headerlink" title="6. 自动装配"></a>6. 自动装配</h2><p>在Spring框架的应用中，可以为需要被Spring自动赋值的属性添加<code>@Autowired</code>，则Spring框架会从Spring容器中找出匹配的值，并自动完成赋值！这就是Spring框架的自动装配机制！</p>
<p>当Spring尝试为某个属性实现自动装配时，采取的模式主要有：</p>
<ul>
<li><code>byName</code>：根据名称实现自动装配，在这种模式下，要求被装配的属性名称，与被Spring管理的对象的名称（调用<code>getBean()</code>方法给出的参数名）必须相同；</li>
<li><code>byType</code>：根据类型实现自动装配，在这种模式，要求被装配的属性的类型，在Spring容器中存在匹配类型的对象，当应用这种机制时，必须在Spring容器中保证匹配类型的对象只有1个，否则，将会出现<code>NoUniqueBeanDefinitionException</code>异常；</li>
</ul>
<p>当使用<code>@Autowired</code>尝试自动装配时，Spring框架会先根据<code>byType</code>模式找出所有匹配类型的对象，如果匹配类型的对象的数量为0，也就是没有匹配类型的对象，默认情况下会直接报错，提示信息例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;cn.tedu.spring.UserDao&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required&#x3D;true)&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用<code>@Autowired</code>时明确的配置为<code>@Autowired(required=false)</code>，当没有匹配类型的对象时，也不会因为装配失败而报错！</p>
</blockquote>
<p>如果匹配类型的对象的数量为1，则直接装配；</p>
<p>如果匹配类型的对象的数量超过1个（有2个甚至更多个），会尝试<code>byName</code>来装配，如果存在名称匹配的对象，则成功装配，如果名称均不匹配，则装配失败，会提示如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;cn.tedu.spring.UserDao&#39; available: expected single matching bean but found 2: userJdbcDao,userMybatisDao</span><br></pre></td></tr></table></figure>

<p>当需要自动装配时，除了使用<code>@Autowired</code>注解以外，还可以使用<code>@Resource</code>注解！</p>
<p>当使用<code>@Resource</code>注解尝试自动装配时，其工作原理是先尝试<code>byName</code>装配，如果存在名称匹配的对象，则直接装配，如果没有名称匹配的对象，则尝试<code>byType</code>装配。</p>
<p>另外，如果某个方法是被Spring调用的，还可以将需要装配的对象设置为方法的参数（不需要添加注解即可正常使用），Spring也可以实现方法参数的自动装配！例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(UserDao userDao)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-通过Spring框架读取-properties文件"><a href="#7-通过Spring框架读取-properties文件" class="headerlink" title="7. 通过Spring框架读取.properties文件"></a>7. 通过Spring框架读取.properties文件</h2><p>首先，在案例的<strong>src/main/resources</strong>下创建<strong>jdbc.properties</strong>文件，并且，在文件中，添加一些自定义的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db_name</span><br><span class="line">driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">username&#x3D;root</span><br><span class="line">password&#x3D;1234</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本次案例的目标是读取以上文件的信息，并不用于真实的连接某个数据库，所以，各属性的值可以不是真正使用的值！</p>
</blockquote>
<p>如果要读取以上信息，可以将这些信息都读取到某个类的各个属性中去，则先创建一个类，并在类中声明4个属性（与以上<strong>jdbc.properties</strong>文件中的配置信息的数量保持一致）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String url;</span><br><span class="line">	<span class="keyword">private</span> String driver;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在类的声明之前，通过<code>@PropertySource</code>配置需要读取的配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br></pre></td></tr></table></figure>

<p>然后，在各个属性的声明之前，通过<code>@Value</code>注解读取配置信息中的值，并注入到属性中，其基本格式是<code>@Value(&quot;${配置文件中的属性名称}&quot;)</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;url&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String url;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;driver&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String driver;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;username&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;password&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"JdbcConfig [url="</span> + url + <span class="string">", driver="</span> + driver + <span class="string">", username="</span> + username + <span class="string">", password="</span> + password</span><br><span class="line">				+ <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于期望的是由Spring读取配置文件，并为以上类的各个属性赋值，所以，以上<code>JdbcConfig</code>应该是被Spring管理的！所以，先使用一个类来配置组件扫描：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cn.tedu.spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在<code>JdbcConfig</code>类的声明之前添加<code>@Component</code>注解即可！</p>
<p><strong>注意：在Windows操作系统中，如果配置文件中的属性名是<code>username</code>，则最终注入属性的值将不是配置文件中的值，而是当前登录Windows操作系统的用户名，为了避免出现此类问题，建议在配置文件中，每个属性的名称之前都添加一些自定义的前缀。</strong></p>
]]></content>
      <categories>
        <category>达内笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>IntellijIDEA快捷使用</title>
    <url>/2020/07/02/IntellijIDEA%E5%BF%AB%E6%8D%B7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Intellij-IDEA快捷使用"><a href="#Intellij-IDEA快捷使用" class="headerlink" title="Intellij IDEA快捷使用"></a>Intellij IDEA快捷使用</h1><h2 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="1. 快捷键"></a>1. 快捷键</h2><h3 id="1-1-按键说明"><a href="#1-1-按键说明" class="headerlink" title="1.1. 按键说明"></a>1.1. 按键说明</h3><table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>需要同时按下加号左右两侧的键</td>
</tr>
<tr>
<td>,</td>
<td>按下逗号左侧的键后，松开，然后按下逗号右侧的键</td>
</tr>
<tr>
<td>Ctrl</td>
<td>控制键，键盘上标记了<code>Ctrl</code>的键，在Mac键盘上标记为<code>control</code></td>
</tr>
<tr>
<td>Shift</td>
<td>上档键，键盘上标记了<code>Shift</code>的键</td>
</tr>
<tr>
<td>Alt</td>
<td>切换键，键盘上标记了<code>Alt</code>的键，在Mac键盘上与<code>Option</code>是同一个键</td>
</tr>
<tr>
<td>Command</td>
<td>命令键，<strong>Mac键盘独有</strong>，标记了<code>Command</code>的键</td>
</tr>
<tr>
<td>Enter</td>
<td>回车键，键盘上标记了<code>Enter</code>的键，在Mac键盘上与<code>return</code>是同一个键</td>
</tr>
<tr>
<td>Space</td>
<td>空格键，键盘上最下方、最大的按键</td>
</tr>
<tr>
<td>Up / Down</td>
<td>方向上/方向下，通常在键盘上标记了向上/向下的箭头</td>
</tr>
</tbody></table>
<p>某些快捷键可能与操作系统或其它软件的全局快捷键是冲突的，则按下会无效或执行其它命令，可以在Intellij IDEA的设置的<strong>Keymap</strong>中修改为其它按键。</p>
<p>以下快捷键是Intellij IDEA的默认风格快捷键，如果改成了Eclipse风格或其它风格，请参考所更改的设置。</p>
<p>标记了<code>[!]</code>是可能存在冲突的快捷键。</p>
<p>全部快捷键可在Intellij IDEA的设置的<strong>Keymap</strong>中查看，或者查看官方文档：<a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf?_ga=2.5349558.422550521.1580708138-1891300040.1568641704" target="_blank" rel="noopener">https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf?_ga=2.5349558.422550521.1580708138-1891300040.1568641704</a></p>
<p>在各种编辑软件中都会使用到的快捷键可能不会被列举到以下各表中，例如<code>Ctrl</code> + <code>C</code>表示<strong>复制</strong>，在各种编辑软件中都是这样设计的，就不重复列举了。</p>
<h3 id="1-2-推荐快捷键"><a href="#1-2-推荐快捷键" class="headerlink" title="1.2. 推荐快捷键"></a>1.2. 推荐快捷键</h3><table>
<thead>
<tr>
<th>Windows / Linux</th>
<th>Mac OS</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>[!]</strong> Ctrl + Space</td>
<td>Ctrl + Space</td>
<td>基本代码提示</td>
</tr>
<tr>
<td>Ctrl + Shift + Space</td>
<td>Ctrl + Shift + Space</td>
<td>智能代码提示</td>
</tr>
<tr>
<td>Shift, Shift</td>
<td>Shift, Shift</td>
<td>全局查找</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>Option + Enter</td>
<td>代码错误解决方案</td>
</tr>
<tr>
<td>Alt + Insert</td>
<td>Command + N 或 Ctrl + Enter</td>
<td>自动生成Bean方法</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>Command + P</td>
<td>在调用方法时，将光标定位在方法的括号中，提示方法的参数列表</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>Shift + F6</td>
<td>重命名，适用于：在文件列表中对文件重命名，在文件内部对类名、属性名、方法名等重命名</td>
</tr>
</tbody></table>
<h3 id="1-3-常规"><a href="#1-3-常规" class="headerlink" title="1.3. 常规"></a>1.3. 常规</h3><table>
<thead>
<tr>
<th>Windows / Linux</th>
<th>Mac OS</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Shift + A</td>
<td>Command + Shift + A</td>
<td>查找命令（IDE中可执行的命令，例如运行、调试、重命名等）</td>
</tr>
</tbody></table>
<h3 id="1-4-查找与替换"><a href="#1-4-查找与替换" class="headerlink" title="1.4. 查找与替换"></a>1.4. 查找与替换</h3><table>
<thead>
<tr>
<th>Windows / Linux</th>
<th>Mac OS</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Shift, Shift</td>
<td>Shift, Shift</td>
<td>全局查找</td>
</tr>
<tr>
<td>Ctrl + F</td>
<td>Command + F</td>
<td>在当前源代码中查找</td>
</tr>
<tr>
<td>Ctrl + R</td>
<td>Command + R</td>
<td>在当前源代码中替换</td>
</tr>
<tr>
<td>Ctrl + Shift + F</td>
<td>Command + Shift + F</td>
<td>在指定路径（例如整个项目）中查找</td>
</tr>
<tr>
<td>Ctrl + Shift + R</td>
<td>Command + Shift + R</td>
<td>在指定路径（例如整个项目）中替换</td>
</tr>
</tbody></table>
<h3 id="1-5-代码编辑"><a href="#1-5-代码编辑" class="headerlink" title="1.5. 代码编辑"></a>1.5. 代码编辑</h3><table>
<thead>
<tr>
<th>Windows / Linux</th>
<th>Mac OS</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[!] Ctrl + Space</td>
<td>Ctrl + Space</td>
<td>基本代码提示</td>
</tr>
<tr>
<td>Ctrl + Shift + Space</td>
<td>Ctrl + Shift + Space</td>
<td>智能代码提示</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>Command + P</td>
<td>在调用方法时，将光标定位在方法的括号中，提示方法的参数列表</td>
</tr>
<tr>
<td>Alt + Insert</td>
<td>Command + N 或 Ctrl + Enter</td>
<td>自动生成Bean方法</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>Ctrl + O</td>
<td>重写方法</td>
</tr>
<tr>
<td>Ctrl + Alt + T</td>
<td>Command + Option +  T</td>
<td>使用if/try…catch等代码块包裹当前选中代码</td>
</tr>
<tr>
<td>Ctrl + /</td>
<td>Command + /</td>
<td>添加/移除行注释</td>
</tr>
<tr>
<td>Ctrl + Alt + L</td>
<td>Command + Option + L</td>
<td>格式化源代码</td>
</tr>
<tr>
<td>Ctrl + Alt + O</td>
<td>[!] Ctrl + Option + O</td>
<td>整理import语句</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>Command + D</td>
<td>向下复制代码行</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>Command + Delete</td>
<td>删除代码行</td>
</tr>
<tr>
<td>Shift + Enter</td>
<td>Shift + Enter</td>
<td>新增下一行代码，并将光标定位到下一行代码</td>
</tr>
<tr>
<td>Ctrl + Enter</td>
<td>Command + Enter</td>
<td>新增下一行代码，光标在原有位置不变</td>
</tr>
<tr>
<td>Ctrl + +/-</td>
<td>Command + +/-</td>
<td>展开或收起类的某个成员，例如方法、内部类等</td>
</tr>
<tr>
<td>Ctrl + Shift + +/-</td>
<td>Command + Shift + +/-</td>
<td>展开或收起当前类的所有成员</td>
</tr>
<tr>
<td></td>
<td>Option + Shift + 上/下</td>
<td>向上/下移动代码</td>
</tr>
<tr>
<td></td>
<td>Command + Option + V</td>
<td>将光标所在位置的常量声明为局部变量</td>
</tr>
<tr>
<td>Ctrl + Shift + V</td>
<td>Command + Shift + V</td>
<td>从最近复制过的多项中选择某项来粘贴</td>
</tr>
</tbody></table>
<blockquote>
<p>也有很多开发者使用<code>Ctrl</code> + <code>X</code>作为<strong>删除代码行</strong>的快捷键，其本质是<strong>剪切</strong>了代码，当然，只要不粘贴，其效果也是相同的。</p>
</blockquote>
<h3 id="1-6-管理与导航"><a href="#1-6-管理与导航" class="headerlink" title="1.6. 管理与导航"></a>1.6. 管理与导航</h3><table>
<thead>
<tr>
<th>Windows</th>
<th>Mac OS</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Shift + F6</td>
<td>Shift + F6</td>
<td>重命名，适用于：在文件列表中对文件重命名，在文件内部对类名、属性名、方法名等重命名</td>
</tr>
<tr>
<td></td>
<td>Shift + 单击</td>
<td>在选项卡处单击以关闭文件</td>
</tr>
<tr>
<td>Ctrl  + F12</td>
<td>Command + F12</td>
<td>显示当前文档结构</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>Command + U</td>
<td>打开父类方法，打开父类，需先装光标定位到类名，不适用于打开Object类</td>
</tr>
<tr>
<td>F4 / Ctrl + Enter</td>
<td>Command + 下 / Ctrl + 单击</td>
<td>打开光标所在位置的类、属性、方法的声明</td>
</tr>
</tbody></table>
<h2 id="2-快捷输入"><a href="#2-快捷输入" class="headerlink" title="2. 快捷输入"></a>2. 快捷输入</h2><h3 id="2-1-操作方式"><a href="#2-1-操作方式" class="headerlink" title="2.1. 操作方式"></a>2.1. 操作方式</h3><p>可以通过快捷输入简单的内容后按下Enter键，快速完成特定的代码内容，这些内容可以在设置的Editor &gt; Live Templates中查看或调整。</p>
<h3 id="2-2-常规"><a href="#2-2-常规" class="headerlink" title="2.2. 常规"></a>2.2. 常规</h3><table>
<thead>
<tr>
<th>输入内容</th>
<th>等效代码</th>
</tr>
</thead>
<tbody><tr>
<td><code>psvm</code></td>
<td><code>public static void main(String[] args) {}</code></td>
</tr>
<tr>
<td><code>sout</code></td>
<td><code>System.out.println();</code></td>
</tr>
<tr>
<td><code>serr</code></td>
<td><code>System.err.println();</code></td>
</tr>
<tr>
<td><code>soutm</code></td>
<td><code>System.out.println(&quot;类名.方法名&quot;);</code></td>
</tr>
<tr>
<td><code>soutp</code></td>
<td><code>System.out.println(&quot;参数1 = [值1], 参数2 = [值2], ... , 参数N = [值N]&quot;);</code></td>
</tr>
<tr>
<td><code>soutv</code></td>
<td><code>System.out.println(&quot;参数名 = 值&quot;);</code></td>
</tr>
</tbody></table>
<h3 id="2-3-声明静态常量"><a href="#2-3-声明静态常量" class="headerlink" title="2.3. 声明静态常量"></a>2.3. 声明静态常量</h3><table>
<thead>
<tr>
<th>输入内容</th>
<th>等效代码</th>
</tr>
</thead>
<tbody><tr>
<td><code>psf</code></td>
<td><code>public static final</code></td>
</tr>
<tr>
<td><code>prsf</code></td>
<td><code>private static final</code></td>
</tr>
<tr>
<td><code>psfi</code></td>
<td><code>public static final int</code></td>
</tr>
<tr>
<td><code>psfs</code></td>
<td><code>public static final String</code></td>
</tr>
</tbody></table>
<h3 id="2-4-判断"><a href="#2-4-判断" class="headerlink" title="2.4. 判断"></a>2.4. 判断</h3><table>
<thead>
<tr>
<th>输入内容</th>
<th>等效代码</th>
</tr>
</thead>
<tbody><tr>
<td><code>ifn</code></td>
<td><code>if (变量 == null) {}</code></td>
</tr>
<tr>
<td><code>inn</code></td>
<td><code>if (变量 != null) {}</code></td>
</tr>
<tr>
<td><code>inst</code></td>
<td><code>if (变量 instanceof 类) {}</code></td>
</tr>
</tbody></table>
<h3 id="2-5-循环与遍历"><a href="#2-5-循环与遍历" class="headerlink" title="2.5. 循环与遍历"></a>2.5. 循环与遍历</h3><table>
<thead>
<tr>
<th>输入内容</th>
<th>等效代码</th>
</tr>
</thead>
<tbody><tr>
<td><code>fori</code></td>
<td><code>for (int 循环变量 = 0; 循环变量 &lt; ; i++) {}</code></td>
</tr>
<tr>
<td><code>itar</code></td>
<td><code>for (int 循环变量 = 0; 循环变量 &lt; 数组.length(); i++) { 类型 数组元素变量名 = 数组[i]}</code></td>
</tr>
<tr>
<td><code>iter</code></td>
<td><code>for (元素类型 变量名 : 被遍历对象) {}</code></td>
</tr>
<tr>
<td><code>itli</code></td>
<td><code>for (int 循环变量 = 0; 循环变量 &lt; 集合.size(); i++) { 类型 集合元素变量名 = 集合.get(循环变量); }</code></td>
</tr>
</tbody></table>
<h2 id="3-快捷输入–高级"><a href="#3-快捷输入–高级" class="headerlink" title="3. 快捷输入–高级"></a>3. 快捷输入–高级</h2><h3 id="3-1-遍历数组或集合对象"><a href="#3-1-遍历数组或集合对象" class="headerlink" title="3.1. 遍历数组或集合对象"></a>3.1. 遍历数组或集合对象</h3><p>假设存在名为<code>numbers</code>的<code>int</code>数组或集合，输入<code>numbers.for</code>即可生成增强for循环代码，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> number : numbers) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-为值声明变量"><a href="#3-2-为值声明变量" class="headerlink" title="3.2. 为值声明变量"></a>3.2. 为值声明变量</h3><p>假设需要声明<code>int</code>类型的变量，其值为<code>1</code>，输入<code>1.var</code>即可生成对应的声明语句，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>整型数字默认生成的变量名是<code>i</code>，代码生成后，可以自行调整。</p>
<p>同理，假设需要声明<code>String</code>类型的变量，其值为<code>&quot;Java&quot;</code>，输入<code>&quot;Java&quot;.var</code>即可，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String java = <span class="string">"Java"</span>;</span><br></pre></td></tr></table></figure>

<p>字符串类型默认生成的变量名有多种情况，例如字符串内容是简单字母时，默认变量名就是字母，如果字母首字母是大写的，也会自动使用首字母小写作为默认变量名，字符串类型是汉字时，默认变量名就是汉字，字符串中包含不允许组成变量名的字符时，会使用<code>s</code>或<code>s1</code>、<code>s2</code>等作为默认变量名，当然，在代码生成后，都可以自行调整。</p>
<p>其它数据类型的值也可以使用同样的方法声明出变量，例如输入<code>new Date().var</code>时，就可以生成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure>

<h3 id="3-3-判断对象是否为空"><a href="#3-3-判断对象是否为空" class="headerlink" title="3.3. 判断对象是否为空"></a>3.3. 判断对象是否为空</h3><p>假设存在名为<code>x</code>的变量，需要判断是否为空，输入<code>x.null</code>然后在提示菜单中选择<code>null</code>一栏回车，即可生成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要判断是否非空，则输入<code>x.no</code>后选择<code>notnull</code>一栏并回车，即可生成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>未完，某天再续……</p>
]]></content>
  </entry>
  <entry>
    <title>linux防火墙常用命令</title>
    <url>/2020/06/24/linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h5 id="开启防火墙端口"><a href="#开启防火墙端口" class="headerlink" title="开启防火墙端口"></a>开启防火墙端口</h5><p>​    firewall-cmd –zone=public –add-port=80/tcp –permanent</p>
<h5 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h5><p>systemctl restart firewalld.service</p>
<h5 id="查看已经开放的端口"><a href="#查看已经开放的端口" class="headerlink" title="查看已经开放的端口"></a><strong>查看已经开放的端口</strong></h5><p>firewall-cmd –list-ports</p>
]]></content>
  </entry>
  <entry>
    <title>博客项目</title>
    <url>/2020/06/29/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="博客项目"><a href="#博客项目" class="headerlink" title="博客项目"></a>博客项目</h1><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ol>
<li><p>Nginx反向代理、动静分离</p>
</li>
<li><p>部署在服务器上并添加SSL证书</p>
</li>
<li><p>使用手机号登录注册</p>
</li>
<li><p>使用QQ号登录注册</p>
</li>
<li><p>发布博客支持emoji表情包</p>
</li>
<li><p>支持发送图片（仅单张）</p>
</li>
<li><p>发布的文字支持MarkDown语法</p>
</li>
<li><p>发送的图片支持点击放大预览</p>
</li>
<li><p>实时获取微博热搜话题显示在主页</p>
</li>
<li><p>获取用户是用什么设备发送的博客，例如android，iPhone</p>
</li>
<li><p>根据设置的出生日期计算年龄</p>
</li>
<li><p>点赞功能</p>
</li>
<li><p>搜索功能</p>
</li>
<li><p>置顶功能</p>
</li>
<li><p>更换头像</p>
</li>
</ol>
<h2 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a>技术框架</h2><p>SpringBoot  核心框架  </p>
<p>Appache Shiro  安全框架  </p>
<p>Mybatis  ORM框架  </p>
<p>Redis  缓存数据库</p>
<p>Nginx web服务器</p>
<p>BootStrap 前端框架</p>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a><a href="https://blog.igali.xyz" target="_blank" rel="noopener">项目地址</a></h2>]]></content>
  </entry>
  <entry>
    <title>redis命令</title>
    <url>/2020/06/24/redis%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>开启redis命令</strong></p>
<p>systemctl start pedis.service</p>
]]></content>
  </entry>
  <entry>
    <title>Tomcat中配置去掉项目名</title>
    <url>/2020/07/06/tomcat%E5%8E%BB%E6%8E%89%E9%A1%B9%E7%9B%AE%E5%90%8D/</url>
    <content><![CDATA[<p>负载均衡中war放在tomcat中时，访问会带有包名。</p>
<h5 id="打开tomcat-conf-server-xml-把"><a href="#打开tomcat-conf-server-xml-把" class="headerlink" title="打开tomcat/conf/server.xml,把"></a>打开tomcat/conf/server.xml,把</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Context path&#x3D;&quot;&#x2F;&quot; docBase&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;tomcat-8102&#x2F;webapps&#x2F;blog&quot; reloadable&#x3D;&quot;true&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>



<p>添加到<code>&lt;Host&gt;&lt;/Host&gt;</code>标签中。</p>
]]></content>
      <tags>
        <tag>tomcat</tag>
        <tag>nginx</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题笔记</title>
    <url>/2020/04/08/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="JVM的工作原理"><a href="#JVM的工作原理" class="headerlink" title="JVM的工作原理"></a>JVM的工作原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JVM是JRE的一部分，Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。(怎么跨平台的：jvm它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、JVM内存分为堆、方法区、虚拟机栈、本地方法栈、程序计数器五个部分。</span><br><span class="line"></span><br><span class="line">二、堆和方法区是线程共享的，虚拟机栈、本地方法栈和程序计数器是线程隔离的。</span><br><span class="line"></span><br><span class="line">三、1.堆主要是存放对象实例的也包括数组，是垃圾管理的主要作用区。</span><br></pre></td></tr></table></figure>

<h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a><strong>JVM的生命周期</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）JVM实例的诞生：当启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点。 </span><br><span class="line">（2）JVM实例的运行 main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程。 </span><br><span class="line">（3）JVM实例的消亡：当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。</span><br></pre></td></tr></table></figure>



<h3 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">栈是运行时的单位，而堆是存储的单位。</span><br><span class="line">栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</span><br><span class="line">在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。</span><br><span class="line">堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。</span><br><span class="line">堆和栈中，栈是程序运行最根本的东西。程序运行可以没有堆，但是不能没有栈。</span><br></pre></td></tr></table></figure>



<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="SpringMVC的流程"><a href="#SpringMVC的流程" class="headerlink" title="SpringMVC的流程"></a>SpringMVC的流程</h3><pre><code>发送请求-接收请求-记录请求与控制器的对应关系-委托请求到控制器-处理后得到的数据及视图名称-根据视图名称确定具体的视图组件-产生响应</code></pre><h3 id="SpringMVC能否从请求url中截取参数？"><a href="#SpringMVC能否从请求url中截取参数？" class="headerlink" title="SpringMVC能否从请求url中截取参数？"></a>SpringMVC能否从请求url中截取参数？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以利用@PathVariable实现。在Controller方法上添加的&#96;@RequestMapping&#96;注解中，使用&#96;&#123;变量名&#125;&#96;的方式，将url中指定位置的值作为变量。在对应方法的参数中，声明一个接收该变量值的参数，前面使用&#96;@PathVariable(&quot;变量名&quot;)&#96;标注。</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC框架的核心组件"><a href="#SpringMVC框架的核心组件" class="headerlink" title="SpringMVC框架的核心组件"></a>SpringMVC框架的核心组件</h3><p>-<code>DispatcherServlet</code>：前端控制器，用于接收所有请求，并组织分发；</p>
<p>-<code>HandlerMapping</code>：记录请求路径与控制器的对应关系；</p>
<p>-<code>Controller</code>：自定义的处理请求的控制器组件；</p>
<p>-<code>ModelAndView</code>：控制器组件处理完请求之后得到的结果，包含数据与视图名称；</p>
<p>-<code>ViewResolver</code>：视图解析器，可以根据视图名称，确定具体的视图组件。</p>
<h3 id="1-关于-RequestMapping注解"><a href="#1-关于-RequestMapping注解" class="headerlink" title="1. 关于@RequestMapping注解"></a>1. 关于@RequestMapping注解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在处理请求的方法之前添加&#96;@RequestMapping&#96;注解，可以配置请求路径与处理请求的方法的映射关系！</span><br></pre></td></tr></table></figure>



<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 什么是索引：索引是数据库中提高查询效率的技术，数据量越大索引效果越明显，索引类似于目录</span><br><span class="line"></span><br><span class="line">- 为什么使用索引：数据会零散的保存在磁盘中的每个磁盘块中，如果不使用索引，查找数据只能挨个遍历每一个磁盘块进行查找，如果使用了索引后，磁盘块会以树桩结构进行保存，查找数据时大大降低了磁盘块的访问量，从而达到了提高查询效率的目的</span><br></pre></td></tr></table></figure>



<h2 id="转发与重定向的区别"><a href="#转发与重定向的区别" class="headerlink" title="转发与重定向的区别"></a>转发与重定向的区别</h2><h3 id="能否共享request对象"><a href="#能否共享request对象" class="headerlink" title="能否共享request对象?"></a>能否共享request对象?</h3><pre><code>转发可以，而重定向不行。
注：
    因为request和response这两个对象的生存时间是在一次请求与响应
期间存在。
    转发是一次请求，重定向是两次请求。
转发是服务器内部的行为，具体表现为</code></pre><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>1.什么是散列表?</p>
<pre><code>依据关键码值(key)直接获取表中对应纪录的一种数据结构。
其中，将关键码值映射到表中的位置的函数叫散列函数(hash函数),
存放记录的数组称之为散列表。</code></pre><p>2.散列表的工作原理:<br>    首先我们使用散列函数将给定键转化为一个“数组的索引”，(key如果相同就是碰撞)<br>    得到了索引后，我们就可以像访问数组一样，通过这个索引访问到相应的键值对。<br>3.散列表常见的一些实现类。</p>
<pre><code>Hashtable: 线程安全，但是性能低,不建议使用。
HashMap:线程不安全，性能高。
    注：
        可以调用Collections.synchronizedMap来将hashMap
    转换成一个线程安全的map。

ConcurrentHashMap: 线程安全，并且性能良好。</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>(1)什么是事务?
事务(Transaction)：是数据库领域中，一种能保证多项增删改操作能够全部执行成功，或全部执行失败的机制！

(2)事务的特点(ACID)
    A.原子性（atomicity):
            事务所涉及的各个操作要么全部成功，要么全部失败。
    C.一致性（consistency):
            事务完成之后，不允许非法的数据保存到数据库。一个事务在执行之前和执行之后，数据的完整性都必须处于一致性状态。
    I.隔离性（isolation）：
            多个事务可以同时执行，彼此不所影响。
            事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
    D.持久性（durability）：
            事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</code></pre><h2 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h2><p><strong>什么是业务：业务(Service)，对于普通用户来说，就是一个“功能”，但是，它可能是由多项数据操作组成的，例如“用户注册”就是一个业务，它至少由“根据用户名查询数据”和“插入数据”组成，在编写代码时，业务层主要完成业务流程和业务逻辑的控制，业务流程指的是先做什么、后做什么，业务逻辑指的是什么情况下能做什么、不能做什么，最终，业务层的目标是保障数据的完整性、安全性。</strong></p>
<p>####POJO<br>POJO是各种实体类的统称，常用的实体类包括DO/DTO/BO/VO。</p>
<ol>
<li>DO：与数据库表相对应的实体类，属性与表中字段相对应</li>
<li>DTO：业务层传输数据时使用的实体类</li>
<li>BO：业务层对外提供远程调用时使用的实体类</li>
<li>VO：供视图层使用的实体类</li>
</ol>
<ul>
<li><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>什么是Spring：<br>  简单来说，<strong>Spring是一个轻量级的控制反转（IoC)和面向切面（AOP)的容器框架。</strong></p>
</li>
</ul>
<h2 id="Spring框架的好处，为什么要用Spring"><a href="#Spring框架的好处，为什么要用Spring" class="headerlink" title="Spring框架的好处，为什么要用Spring?"></a>Spring框架的好处，为什么要用Spring?</h2><p>1.方便解耦，便于开发（Spring就是一个大工厂，可以将所有对象的创建和依赖关系维护都交给spring管理）</p>
<p>2.spring支持aop编程（spring提供面向切面编程，可以很方便的实现对程序进行权限拦截和运行监控等功能）</p>
<p>3.声明式事务的支持（通过配置就完成对事务的支持，不需要手动编程）</p>
<p>4.方便程序的测试，spring 对junit4支持，可以通过注解方便的测试spring 程序</p>
<p>5.方便集成各种优秀的框架（）</p>
<p>6.降低javaEE API的使用难度（Spring 对javaEE开发中非常难用的一些API 例如JDBC,javaMail,远程调用等，都提供了封装，是这些API应用难度大大降低）</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>什么是AOP：<br>    简单地说，<strong>就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低 模块间的耦合度，并有利于未来的可操作性和可维护性。</strong><br>    核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横 切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。<br>    Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king = <span class="keyword">new</span> King();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是饿汉式单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> King king;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">King</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> King <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123; <span class="comment">// 判断是否有必须加锁，如果没有该判断，则效率可能偏低</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="string">"java"</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (king == <span class="keyword">null</span>) &#123; <span class="comment">// 判断是否有必须创建对象，如果没有该判断，则可能创建多个对象</span></span><br><span class="line">                    king = <span class="keyword">new</span> King();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> king;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，就是完整的懒汉式的单例模式！</p>
<p><strong>小结：单例模式的特点就是“单一实例”，表现为“同一时间内，某个类的对象只有1个”！单例模式分为“饿汉式”和“懒汉式”这2种，前者是“早早的创建出对象，随时可以获取”，后者是“不到逼不得已不会创建对象”！</strong></p>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p><code>byName</code>：要求被装配的属性名称，与被Spring管理的对象的名称（调用<code>getBean()</code>方法给出的参数名）必须相同；</p>
<p><code>byType</code>：要求被装配的属性的类型，在Spring容器中存在匹配类型的对象，当应用这种机制时，必须在Spring容器中保证匹配类型的对象只有1个，否则，将会出现<code>NoUniqueBeanDefinitionException</code>异常；</p>
<hr>
<h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><pre><code>索引是数据库中提高查询效率的技术，数据量越大索引效果越明显，索引类似于目录
索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，</code></pre><h3 id="为什么使用索引："><a href="#为什么使用索引：" class="headerlink" title="为什么使用索引："></a>为什么使用索引：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据会零散的保存在磁盘中的每个磁盘块中，如果不使用索引，查找数据只能挨个遍历每一个磁盘块进行查找，如果使用了索引后，磁盘块会以树桩结构进行保存，查找数据时大大降低了磁盘块的访问量，从而达到了提高查询效率的目的</span><br></pre></td></tr></table></figure>

<h3 id="mysql-索引是怎么实现的？"><a href="#mysql-索引是怎么实现的？" class="headerlink" title="mysql 索引是怎么实现的？"></a>mysql 索引是怎么实现的？</h3><pre><code>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，
可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</code></pre><h2 id="什么是Serializable接口"><a href="#什么是Serializable接口" class="headerlink" title="什么是Serializable接口"></a>什么是Serializable接口</h2><pre><code>一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才能被序列化。</code></pre><h3 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h3><pre><code>序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</code></pre><h3 id="为什么要序列化对象"><a href="#为什么要序列化对象" class="headerlink" title="为什么要序列化对象"></a>为什么要序列化对象</h3><pre><code>把对象转换为字节序列的过程称为对象的序列化
把字节序列恢复为对象的过程称为对象的反序列化</code></pre><h3 id="什么情况下需要序列化？"><a href="#什么情况下需要序列化？" class="headerlink" title="什么情况下需要序列化？"></a>什么情况下需要序列化？</h3><pre><code>当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，以便将来使用时都需要把对象进行序列化</code></pre><h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h2><p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。</p>
<h3 id="3-关于Session"><a href="#3-关于Session" class="headerlink" title="3. 关于Session"></a>3. 关于Session</h3><p>因为HTTP协议是无状态协议，所以，同一个客户端的多次请求，服务器是无法区分这是来自同一个客户端的，如果需要保存用户的某些数据或状态，就需要使用Session。</p>
<h3 id="4-拦截器-Interceptor"><a href="#4-拦截器-Interceptor" class="headerlink" title="4. 拦截器(Interceptor)"></a>4. 拦截器(Interceptor)</h3><p>拦截器：是一种可以使得若干种请求都会自动的执行其中的代码组件！该组件对所处理的请求可以选择放行，或选择阻止继续执行！</p>
<p>在SpringMVC项目中，如果需要使用拦截器，首先，需要自定义类，实现<code>HandlerInterceptor</code>拦截器接口：</p>
<h3 id="附1：关于拦截器-Interceptor-和过滤器-Filter"><a href="#附1：关于拦截器-Interceptor-和过滤器-Filter" class="headerlink" title="附1：关于拦截器(Interceptor)和过滤器(Filter)"></a>附1：关于拦截器(Interceptor)和过滤器(Filter)</h3><p>过滤器(Filter)是Java EE中的组件，而拦截器(Interceptor)是SpringMVC中的组件！</p>
<p>过滤器(Filter)是执行在所有的<code>Servlet</code>之前的组件，而SpringMVC中的拦截器的第1次执行是在<code>DispatcherServlet</code>之后，且在<code>Controller</code>之前执行的！(对应SpringMVC核心执行流程图，过滤器是1号位置执行，而拦截器第1次执行是在4号位置)</p>
<h2 id="MyBatis框架的作用"><a href="#MyBatis框架的作用" class="headerlink" title="MyBatis框架的作用"></a>MyBatis框架的作用</h2><p>MyBatis框架最直接的作用就是简化持久层开发！</p>
<blockquote>
<p>持久层：处理数据持久化的组件；</p>
</blockquote>
<blockquote>
<p>持久化：将数据永久的存储下来；</p>
</blockquote>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Set-无序-唯一"><a href="#Set-无序-唯一" class="headerlink" title="Set 无序,唯一"></a>Set 无序,唯一</h3><p>HashSet如何保证元素的唯一性</p>
<p><strong>依赖两个方法：hashCode()和equals()</strong></p>
<p>TreeSet底层数据结构是红黑树</p>
<ol>
<li><p>如何保证元素排序的呢?</p>
<p>自然排序、比较器排序</p>
</li>
<li><p>如何保证元素唯一性的呢?<br>根据比较的返回值是否是0来决定</p>
</li>
</ol>
<h3 id="List-有序-可重复"><a href="#List-有序-可重复" class="headerlink" title="List 有序,可重复"></a>List 有序,可重复</h3><p>ArrayList和Vector底层数据结构是数组</p>
<p>linkedList底层数据结构是链表</p>
<p>只有Vector是线程安全的</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>TreeMap是有序的，HashMap和HashTable是无序的。</li>
<li>Hashtable的方法是同步的，HashMap的方法不是同步的。这是两者最主要的区别。</li>
<li>Hashtable是线程安全的，HashMap不是线程安全的。</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="StringBuffer和StringBuilder的区别"><a href="#StringBuffer和StringBuilder的区别" class="headerlink" title="StringBuffer和StringBuilder的区别"></a>StringBuffer和StringBuilder的区别</h3><p>在改变字符串时，都不会创建新的对象。</p>
<p>不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>在Object类中主要包括clone()、finalize()、equals()、toString()等方法，其中常用的两个方法为equals()和toString()方法。</p>
<p><strong>Object类中的getClass()、notify()、notifyAll()、wait()等方法不能被重写，因为这些方法被定义为final类型。</strong></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Error-和-Exception的区别"><a href="#Error-和-Exception的区别" class="headerlink" title="Error 和 Exception的区别"></a>Error 和 Exception的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。</span><br><span class="line"></span><br><span class="line">Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。</span><br></pre></td></tr></table></figure>

<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其中的Exception又分为检查性异常和非检查性异常。两个根本的区别在于，检查性异常 必须在编写代码时，使用try catch捕获（比如：IOException异常）。非检查性异常 在代码编写使，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。</span><br></pre></td></tr></table></figure>

<p><strong>它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。</strong></p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表示系统级的错误和程序不必处理的异常，如：OutOfMemoryError、NoClassDefFoundError等。</span><br></pre></td></tr></table></figure>



<h3 id="受检异常和非受检异常"><a href="#受检异常和非受检异常" class="headerlink" title="受检异常和非受检异常"></a>受检异常和非受检异常</h3><p><strong>非受检异常指的是java.lang.RuntimeException和java.lang.Error类及其子类，所有其他的异常类都称为受检异常。</strong></p>
<p>以下是RuntimeException 非受检异常</p>
<p><code>Java.lang.ClassCastException</code></p>
<p><code>Java.lang.IllegalArgumentException</code></p>
<p><code>Java.lang.IndexOutOfBoundsException</code></p>
<p><code>Java.lang.ArrayIndexOutOfBoundsException</code></p>
<p><code>Java.lang.NullPointerException</code></p>
<h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><p>1、throw代表动作，表示抛出一个异常的动作；throws代表一种状态，代表方法可能有异常抛出<br>2、throw用在方法实现中，而throws用在方法声明中<br>3、throw只能用于抛出一种异常，而throws可以抛出多个异常</p>
<h2 id="什么是Java-EE"><a href="#什么是Java-EE" class="headerlink" title="什么是Java EE"></a>什么是Java EE</h2><p>Java 平台企业版</p>
<h3 id="JavaEE-与-JavaSE-的区别与联系"><a href="#JavaEE-与-JavaSE-的区别与联系" class="headerlink" title="JavaEE 与 JavaSE 的区别与联系"></a>JavaEE 与 JavaSE 的区别与联系</h3><p>JavaEE 是在 JavaSE 的基础上构建的，是对 JavaSE 的扩展，增加了一些更加便捷的应用框架。</p>
<h2 id="JavaEE主要技术"><a href="#JavaEE主要技术" class="headerlink" title="JavaEE主要技术"></a>JavaEE主要技术</h2><p><strong>JDBC</strong>  <strong>Servlet</strong>  <strong>jsp</strong>  <strong>XML</strong></p>
]]></content>
  </entry>
</search>
