<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM部分面试题</title>
      <link href="/2020/08/03/JVM%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/03/JVM%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ol><li>说一下jvm的主要组成部分，及其作用？</li><li>说一下jvm运行时数据区？</li><li>说一下堆栈的区别？</li><li>队列和栈是什么？有什么区别？</li><li>什么是双亲委派模式？</li><li>说一下类加载的执行过程？</li><li>怎么判断对象是否可以被回收？</li><li>Java中都有哪些引用类型？</li><li>说一下jvm有哪些垃圾回收算法？</li><li>说一下jvm有哪些垃圾回收器？</li><li>详细介绍一下CMS垃圾回收器？</li><li>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</li><li>简述分代垃圾回收器是怎么工作的？</li><li>说一下jvm调优的工具？</li><li>常用的jvm调优的参数都有哪些？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础部分面试题</title>
      <link href="/2020/08/03/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/08/03/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ol><li>JDK和JRE有什么区别？</li><li>==和equals有什么区别？</li><li>两个对象的hashcode()相同，则equals()也一定为true，对吗，为什么？</li><li>final在Java中有什么作用？</li><li>Java中的math.round(-1.5)等于多少？</li><li>String属于基础的数据类型吗？</li><li>Java中操作字符串都有哪些类？他们之间有什么区别？</li><li>String str = “i”与String str=new String(“i”)一样吗？</li><li>如何将字符串反转？</li><li>String类的常用方法有哪些？</li><li>抽象类必须要有抽象方法吗？</li><li>普通类和抽象类有哪些区别？</li><li>抽象类能使用final修饰吗？</li><li>接口和抽象类有什么区别？</li><li>Java中IO流分为几种？</li><li>BIO、NIO、AIO、有什么区别？</li><li>Files的常用方法有哪些？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx部分面试题</title>
      <link href="/2020/08/03/Nginx%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/03/Nginx%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql部分面试题</title>
      <link href="/2020/08/03/MySql%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/03/MySql%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ol><li>数据库的三范式是什么？</li><li>如何获取当前数据库版本？</li><li>说一下ACID是什么？</li><li>char和varchar的区别是什么？</li><li>float和double的区别是什么？</li><li>mysql的内连接、左连接、右连接有什么区别？</li><li>mysql的索引怎么实现的？</li><li>怎么验证mysql的索引是否满足要求？</li><li>说一下数据库的事物隔离？</li><li>说一下mysql常用的引擎？</li><li>说一下mysql的行锁和表锁？</li><li>说一下乐观锁和悲观锁？</li><li>mysql问题排查都有哪些手段？</li><li>如何做mysql的性能优化？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis部分面试题</title>
      <link href="/2020/08/03/Redis%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/03/Redis%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ol><li>redis是什么？都有哪些使用场景？</li><li>redis为什么是单线程的？</li><li>什么是缓存穿透？怎么解决？</li><li>redis支持的数据类型有哪些？</li><li>redis支持的java客户端有哪些？</li><li>jedis和redisson有哪些区别？</li><li>怎么保证缓存和数据库数据的一致性？</li><li>redis持久化有几种方式？</li><li>redis怎么实现分布式锁？</li><li>redis分布式锁有什么缺陷？</li><li>redis如何做内存优化？</li><li>redis淘汰策略有哪些？</li><li>redis常见的性能问题有哪些？该如何解决？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis部分面试题</title>
      <link href="/2020/08/03/mybatis%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/03/mybatis%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ol><li>mybatis中#{}和${}有什么区别？</li><li>mybatis有几种分页方式？</li><li>RowBounds是一次性查询全部结果吗？为什么？</li><li>mybatis逻辑分页和物理分页的区别是什么？</li><li>mybatis是否支持延迟加载？延迟加载的原理是什么？</li><li>说一下mybatis的一级缓存和二级缓存？</li><li>mybatis和hibernate的区别有哪些？</li><li>mybatis有哪些执行器(Executor)？</li><li>mybatis的分页插件的实现原理是什么？</li><li>mybatis如何编写一个自定义插件？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器部分面试题</title>
      <link href="/2020/08/03/%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/03/%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ol><li>Java容器都有哪些？</li><li>collection和collections有什么区别？</li><li>List、Set、Map之间的区别是什么？</li><li>HashMap和HashTable有什么区别？</li><li>如何决定使用hashMap还是TreeMap？</li><li>说一下HashMap的实现原理？</li><li>说一下HashSet的实现原理？</li><li>ArrayList和LinkedList的区别？</li><li>如何实现数组和List之间的转换？</li><li>ArrayList和Vector之间的区别？</li><li>Array和ArrayList有何区别？</li><li>中Queue中poll()和remove()有什么区别？</li><li>哪些集合类是线程安全的？</li><li>迭代器Iterator是什么？</li><li>Iterator怎么使用？有什么特点？</li><li>iterator和ListIterator有什么区别？</li><li>怎么确保一个集合不能被修改？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程部分面试题</title>
      <link href="/2020/08/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ol><li>并行和并发有什么区别？</li><li>线程和进程有什么区别？</li><li>守护线程是什么？</li><li>创建线程有哪几种方式？</li><li>说一下runnable和callable有什么区别？</li><li>线程有哪些状态？</li><li>sleep()和wait()有什么区别？</li><li>notify()和notifyAll()有什么区别？</li><li>线程的run()和start()有什么区别？</li><li>创建线程池有哪几种方式？</li><li>线程池有哪些状态？</li><li>线程池submit()和execute()方法有什么区别？</li><li>在Java程序中怎么保证多线程的运行安全？</li><li>synchronized和volatile的区别是什么？</li><li>synchronized和Lock有什么区别？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/2020/07/24/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/07/24/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Collection 和collections的区别</p><p>什么是面向对象</p><p>jvm的工作原理</p><p>遇到异常要怎么处理</p><p>Error 和 Exception的区别</p><p>Error和Exception下的子类有哪些？</p><p>受检异常和非受检异常</p><p>throw和throws的区别</p><p>反射</p><p>Java EE</p><p>为什么不用servlet：一个功能就需要一个servlet，太多了</p><p>什么是Springboot</p><p>枚举类型</p><p>拦截器和过滤器的区别</p><p>泛型</p><p>什么是bean</p><p>并发和并行有什么区别</p><p>明天看线程和Spring SpringMVC</p><p>DDL</p><p>DML</p><p>悲观锁，乐观锁</p><p>怎么解决死锁</p><p><strong><a href="https://www.jianshu.com/p/7e76ce65e3ad">脏读、幻读和不可重复读</a></strong></p><p>DAP</p><p>junit</p><p>spring五个模块</p><p>servlet的作用域</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题笔记</title>
      <link href="/2020/07/24/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/24/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM的工作原理"><a href="#JVM的工作原理" class="headerlink" title="JVM的工作原理"></a>JVM的工作原理</h3><pre><code>JVM是JRE的一部分，Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。(怎么跨平台的：jvm它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统) </code></pre><p>一、JVM内存分为堆、方法区、虚拟机栈、本地方法栈、程序计数器五个部分。</p><p>二、堆和方法区是线程共享的，虚拟机栈、本地方法栈和程序计数器是线程隔离的。</p><p>三、1.堆主要是存放对象实例的也包括数组，是垃圾管理的主要作用区。</p><h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a><strong>JVM的生命周期</strong></h3><p>（1）JVM实例的诞生：当启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点。<br>（2）JVM实例的运行 main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程。<br>（3）JVM实例的消亡：当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。</p><h3 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h3><p>栈是运行时的单位，而堆是存储的单位。<br>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。<br>在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。<br>堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。<br>堆和栈中，栈是程序运行最根本的东西。程序运行可以没有堆，但是不能没有栈。</p><h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h2><p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。</p><p><strong>== 的作用：</strong><br>　　基本类型：比较的就是值是否相同<br>　　引用类型：比较的就是地址值是否相同<br><strong>equals 的作用:</strong><br>　　引用类型：默认情况下，比较的是地址值。<br>注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同</p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>1.什么是散列表?</p><p>依据关键码值(key)直接获取表中对应纪录的一种数据结构。<br>其中，将关键码值映射到表中的位置的函数叫散列函数(hash函数),<br>存放记录的数组称之为散列表。</p><p>2.散列表的工作原理:<br>    首先我们使用散列函数将给定键转化为一个“数组的索引”，(key如果相同就是碰撞)<br>    得到了索引后，我们就可以像访问数组一样，通过这个索引访问到相应的键值对。<br>3.散列表常见的一些实现类。</p><p>Hashtable: 线程安全，但是性能低,不建议使用。<br>HashMap:线程不安全，性能高。<br>    注：<br>        可以调用Collections.synchronizedMap来将hashMap<br>    转换成一个线程安全的map。</p><p>ConcurrentHashMap: 线程安全，并且性能良好。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>(1)什么是事务?事务(Transaction)：是数据库领域中，一种能保证多项增删改操作能够全部执行成功，或全部执行失败的机制！(2)事务的特点(ACID)    A.原子性（atomicity):            事务所涉及的各个操作要么全部成功，要么全部失败。    C.一致性（consistency):            事务完成之后，不允许非法的数据保存到数据库。一个事务在执行之前和执行之后，数据的完整性都必须处于一致性状态。    I.隔离性（isolation）：            多个事务可以同时执行，彼此不所影响。            事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。    D.持久性（durability）：            事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</code></pre><h2 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h2><p><strong>什么是业务：业务(Service)，对于普通用户来说，就是一个“功能”，但是，它可能是由多项数据操作组成的，例如“用户注册”就是一个业务，它至少由“根据用户名查询数据”和“插入数据”组成，在编写代码时，业务层主要完成业务流程和业务逻辑的控制，业务流程指的是先做什么、后做什么，业务逻辑指的是什么情况下能做什么、不能做什么，最终，业务层的目标是保障数据的完整性、安全性。</strong></p><h3 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h3><p>POJO是各种实体类的统称，常用的实体类包括DO/DTO/BO/VO。</p><ol><li>DO：与数据库表相对应的实体类，属性与表中字段相对应</li><li>DTO：业务层传输数据时使用的实体类</li><li>BO：业务层对外提供远程调用时使用的实体类</li><li>VO：供视图层使用的实体类</li></ol><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>什么是Spring：<br>    简单来说，<strong>Spring是一个轻量级的控制反转（IoC)和面向切面（AOP)的容器框架。</strong></p><h3 id="Spring框架的好处，为什么要用Spring"><a href="#Spring框架的好处，为什么要用Spring" class="headerlink" title="Spring框架的好处，为什么要用Spring?"></a>Spring框架的好处，为什么要用Spring?</h3><p>1.方便解耦，便于开发（Spring就是一个大工厂，可以将所有对象的创建和依赖关系维护都交给spring管理）</p><p>2.spring支持aop编程（spring提供面向切面编程，可以很方便的实现对程序进行权限拦截和运行监控等功能）</p><p>3.声明式事务的支持（通过配置就完成对事务的支持，不需要手动编程）</p><p>4.方便程序的测试，spring 对junit4支持，可以通过注解方便的测试spring 程序</p><p>5.方便集成各种优秀的框架（）</p><p>6.降低javaEE API的使用难度（Spring 对javaEE开发中非常难用的一些API 例如JDBC,javaMail,远程调用等，都提供了封装，是这些API应用难度大大降低）</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>什么是AOP：<br>    简单地说，<strong>就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低 模块间的耦合度，并有利于未来的可操作性和可维护性。</strong><br>    核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横 切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。<br>    Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><h3 id="Spring-bean的作用域"><a href="#Spring-bean的作用域" class="headerlink" title="Spring bean的作用域"></a>Spring bean的作用域</h3><p>Spring默认是单例的，当一个bean的作用域为singleton时，那么Spring容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义的相匹配，则只会返回bean的同一实例。</p><p>prototype作用域的bean会导致在每次对该bean请求时都会创建一个新的bean实例。</p><p>bean的注入属性有几种方式</p><ol><li>构造器注入</li><li>set注入</li><li>接口注入</li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><pre><code class="java">public class King {    private static King king = new King();    private King() {}    public static King getInstance() {        return king;    }}</code></pre><p>以上是饿汉式单例模式</p><pre><code class="java">public class King {    private static King king;    private King() {}    public static King getInstance() {        if (king == null) { // 判断是否有必须加锁，如果没有该判断，则效率可能偏低            synchronized(&quot;java&quot;) {                if (king == null) { // 判断是否有必须创建对象，如果没有该判断，则可能创建多个对象                    king = new King();                }            }        }        return king;    }}</code></pre><p>以上，就是完整的懒汉式的单例模式！</p><p><strong>小结：单例模式的特点就是“单一实例”，表现为“同一时间内，某个类的对象只有1个”！单例模式分为“饿汉式”和“懒汉式”这2种，前者是“早早的创建出对象，随时可以获取”，后者是“不到逼不得已不会创建对象”！</strong></p><h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p><code>byName</code>：要求被装配的属性名称，与被Spring管理的对象的名称（调用<code>getBean()</code>方法给出的参数名）必须相同；</p><p><code>byType</code>：要求被装配的属性的类型，在Spring容器中存在匹配类型的对象，当应用这种机制时，必须在Spring容器中保证匹配类型的对象只有1个，否则，将会出现<code>NoUniqueBeanDefinitionException</code>异常；</p><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="SpringMVC框架的作用"><a href="#SpringMVC框架的作用" class="headerlink" title="SpringMVC框架的作用"></a>SpringMVC框架的作用</h3><p>SpringMVC框架主要解决了接收请求与处理响应的问题，也可以认为是解决了V-C交互的问题，与M其实没有关系。</p><p>在传统的Java EE的开发模式下，可能存在<code>Servlet</code>组件数量太多的问题，会导致项目的管理难度太大，且运行时，会有大量的<code>Servlet</code>对象长期占用内存的问题！</p><p>另外，传统的Java EE开发模式下，数据的处理过程中代码量相对较大，而SpringMVC非常大极度的简化了开发量！</p><h3 id="SpringMVC的流程"><a href="#SpringMVC的流程" class="headerlink" title="SpringMVC的流程"></a>SpringMVC的流程</h3><p>发送请求-接收请求-记录请求与控制器的对应关系-委托请求到控制器-处理后得到的数据及视图名称-根据视图名称确定具体的视图组件-产生响应</p><h3 id="SpringMVC能否从请求url中截取参数？"><a href="#SpringMVC能否从请求url中截取参数？" class="headerlink" title="SpringMVC能否从请求url中截取参数？"></a>SpringMVC能否从请求url中截取参数？</h3><p>可以利用@PathVariable实现。在Controller方法上添加的<code>@RequestMapping</code>注解中，使用<code>{变量名}</code>的方式，将url中指定位置的值作为变量。在对应方法的参数中，声明一个接收该变量值的参数，前面使用<code>@PathVariable(&quot;变量名&quot;)</code>标注。</p><h3 id="SpringMVC框架的核心组件"><a href="#SpringMVC框架的核心组件" class="headerlink" title="SpringMVC框架的核心组件"></a>SpringMVC框架的核心组件</h3><p>-<code>DispatcherServlet</code>：前端控制器，用于接收所有请求，并组织分发；</p><p>-<code>HandlerMapping</code>：记录请求路径与控制器的对应关系；</p><p>-<code>Controller</code>：自定义的处理请求的控制器组件；</p><p>-<code>ModelAndView</code>：控制器组件处理完请求之后得到的结果，包含数据与视图名称；</p><p>-<code>ViewResolver</code>：视图解析器，可以根据视图名称，确定具体的视图组件。</p><h3 id="1-关于-RequestMapping注解"><a href="#1-关于-RequestMapping注解" class="headerlink" title="1. 关于@RequestMapping注解"></a>1. 关于@RequestMapping注解</h3><p>在处理请求的方法之前添加<code>@RequestMapping</code>注解，可以配置请求路径与处理请求的方法的映射关系！</p><h3 id="SpringMVC怎么使用中文？"><a href="#SpringMVC怎么使用中文？" class="headerlink" title="SpringMVC怎么使用中文？"></a>SpringMVC怎么使用中文？</h3><pre><code class="java">@Overrideprotected Filter[] getServletFilters() {    //注册过滤器: 注册Spring MVC提供的编码过滤器,解决POST请求乱码问题    return new Filter[] {new CharacterEncodingFilter(&quot;UTF-8&quot;)};}</code></pre><p>重写getServletFilters方法，返回CharacterEncodingFilter类，设置字符编码为uft-8，或在web.xml中配置CharacterEncodingFilter过滤器，设置字符编码为utf-8。</p><h3 id="转发与重定向的区别"><a href="#转发与重定向的区别" class="headerlink" title="转发与重定向的区别"></a>转发与重定向的区别</h3><h4 id="能否共享request对象"><a href="#能否共享request对象" class="headerlink" title="能否共享request对象?"></a>能否共享request对象?</h4><p>转发可以，而重定向不行。<br>注：<br>    因为request和response这两个对象的生存时间是在一次请求与响应<br>期间存在。<br>    转发是服务器内部的行为，具体表现为“控制器将请求转发给视图组件（可以有数据，也可以没有数据）”，对于客户端来说，只发出过1次请求，并且，只知道这1次请求的路径，在客户端的浏览器中，地址栏显示的URL也不会发生变化！同时，由于这是服务器内部的行为，所以，控制器可以向视图组件传递任意数据！从编写代码的角度来看，转发时，需要指定的是视图名称！</p><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><pre><code>索引是数据库中提高查询效率的技术，数据量越大索引效果越明显，索引类似于目录索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，</code></pre><h3 id="为什么使用索引："><a href="#为什么使用索引：" class="headerlink" title="为什么使用索引："></a>为什么使用索引：</h3><pre><code>数据会零散的保存在磁盘中的每个磁盘块中，如果不使用索引，查找数据只能挨个遍历每一个磁盘块进行查找，如果使用了索引后，磁盘块会以树桩结构进行保存，查找数据时大大降低了磁盘块的访问量，从而达到了提高查询效率的目的</code></pre><h3 id="mysql-索引是怎么实现的？"><a href="#mysql-索引是怎么实现的？" class="headerlink" title="mysql 索引是怎么实现的？"></a>mysql 索引是怎么实现的？</h3><pre><code>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</code></pre><h2 id="什么是Serializable接口"><a href="#什么是Serializable接口" class="headerlink" title="什么是Serializable接口"></a>什么是Serializable接口</h2><pre><code>一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才能被序列化。</code></pre><h3 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h3><pre><code>序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</code></pre><h3 id="为什么要序列化对象"><a href="#为什么要序列化对象" class="headerlink" title="为什么要序列化对象"></a>为什么要序列化对象</h3><pre><code>把对象转换为字节序列的过程称为对象的序列化把字节序列恢复为对象的过程称为对象的反序列化</code></pre><h3 id="什么情况下需要序列化？"><a href="#什么情况下需要序列化？" class="headerlink" title="什么情况下需要序列化？"></a>什么情况下需要序列化？</h3><pre><code>当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，以便将来使用时都需要把对象进行序列化</code></pre><h3 id="关于Session"><a href="#关于Session" class="headerlink" title="关于Session"></a>关于Session</h3><p>因为HTTP协议是无状态协议，所以，同一个客户端的多次请求，服务器是无法区分这是来自同一个客户端的，如果需要保存用户的某些数据或状态，就需要使用Session。</p><h3 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h3><ul><li><p>为什么使用Cookie和Session?</p><p>浏览器和服务器之间数据传输遵循的是HTTP数据传输协议,此协议属于无状态协议(一次请求对应一次响应,服务器无法跟踪客户端的请求),通过Cookie服务器可以给客户端设置一个标识,设置完之后客户端之后的请求都会带着这个标识,从而识别客户端. 但是Cookie由于是明文保存在客户端的数据,可以被客户端伪造造成安全隐患, 这时Session的产生解决了此问题,Session基于Cookie实现,但是数据保存在了服务器端,这样保存的数据就不能被伪造从而提高了安全性</p></li><li><p>作用: Cookie和Session都是为了实现多个Servlet之间共享数据而存在的 </p></li><li><p>Cookie:数据保存在客户端,类似于打孔式的会员卡, </p><ul><li>保存时间: 默认保存在内存中浏览器关闭时就会被删除,如果设置了保存时间,数据会保存到磁盘中,时间到了后再销毁</li><li>保存数据大小: cookie保存的数据不能超过4k</li><li>只能保存字符串数据 </li><li>应用场景: 长时间保存的数据</li></ul></li><li><p>Session:数据保存在服务器,类似于银行卡</p><ul><li>Session保存时间为半个小时, 这个时间可以修改但不建议,因为Session对象保存在服务器中会占用资源,Session不建议数据存储时间太久,而且Session的工作原理基于Cookie,在Cookie中保存了sessionId,并且是在内存中保存,浏览器关闭时sessionId就删除.</li><li>保存数据大小:没有限制</li><li>可以保存任意对象</li><li>应用场景: 记录登录状态 </li></ul></li></ul><h3 id="4-拦截器-Interceptor"><a href="#4-拦截器-Interceptor" class="headerlink" title="4. 拦截器(Interceptor)"></a>4. 拦截器(Interceptor)</h3><p>拦截器：是一种可以使得若干种请求都会自动的执行其中的代码组件！该组件对所处理的请求可以选择放行，或选择阻止继续执行！</p><p>在SpringMVC项目中，如果需要使用拦截器，首先，需要自定义类，<strong>实现<code>HandlerInterceptor</code>拦截器接口</strong>：</p><h3 id="附1：关于拦截器-Interceptor-和过滤器-Filter"><a href="#附1：关于拦截器-Interceptor-和过滤器-Filter" class="headerlink" title="附1：关于拦截器(Interceptor)和过滤器(Filter)"></a>附1：关于拦截器(Interceptor)和过滤器(Filter)</h3><p>过滤器(Filter)是Java EE中的组件，而拦截器(Interceptor)是SpringMVC中的组件！</p><p>过滤器(Filter)是执行在所有的<code>Servlet</code>之前的组件，而SpringMVC中的拦截器的第1次执行是在<code>DispatcherServlet</code>之后，且在<code>Controller</code>之前执行的！(对应SpringMVC核心执行流程图，过滤器是1号位置执行，而拦截器第1次执行是在4号位置)</p><h2 id="MyBatis框架的作用"><a href="#MyBatis框架的作用" class="headerlink" title="MyBatis框架的作用"></a>MyBatis框架的作用</h2><p>MyBatis框架最直接的作用就是简化持久层开发！</p><blockquote><p>持久层：处理数据持久化的组件；</p></blockquote><blockquote><p>持久化：将数据永久的存储下来；</p></blockquote><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Set-无序-唯一"><a href="#Set-无序-唯一" class="headerlink" title="Set 无序,唯一"></a>Set 无序,唯一</h3><p>HashSet如何保证元素的唯一性</p><p><strong>依赖两个方法：hashCode()和equals()</strong></p><p>TreeSet底层数据结构是红黑树</p><ol><li><p>如何保证元素排序的呢?</p><p>自然排序、比较器排序</p></li><li><p>如何保证元素唯一性的呢?<br>根据比较的返回值是否是0来决定</p></li></ol><h3 id="List-有序-可重复"><a href="#List-有序-可重复" class="headerlink" title="List 有序,可重复"></a>List 有序,可重复</h3><p>ArrayList和Vector底层数据结构是数组</p><p>linkedList底层数据结构是链表</p><p>只有Vector是线程安全的</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>TreeMap是有序的，HashMap和HashTable是无序的。</li><li>Hashtable的方法是同步的，HashMap的方法不是同步的。这是两者最主要的区别。</li><li>Hashtable是线程安全的，HashMap不是线程安全的。</li></ul><p><strong>TreeMap底层实现是红黑树</strong></p><h4 id="TreeSet和TreeMap的区别"><a href="#TreeSet和TreeMap的区别" class="headerlink" title="TreeSet和TreeMap的区别"></a>TreeSet和TreeMap的区别</h4><p>其中 TreeMap 是 Map 接口的常用实现类，而 TreeSet 是 Set 接口的常用实现类。虽然 TreeMap 和TreeSet 实现的接口规范不同，<strong>但 TreeSet 底层是通过 TreeMap 来实现的</strong>（如同HashSet底层是是通过HashMap来实现的一样），因此二者的实现方式完全一样。而 TreeMap 的实现就是红黑树算法。</p><p><strong>相同点：</strong></p><ul><li>TreeMap和TreeSet都是非同步集合，因此他们不能在多线程之间共享，不过可以使用方法Collections.synchroinzedMap()来实现同步</li><li>运行速度都要比Hash集合慢，他们内部对元素的操作时间复杂度为O(logN)，而HashMap/HashSet则为O(1)。</li><li>TreeMap和TreeSet都是有序的集合，也就是说他们存储的值都是拍好序的。</li></ul><p><strong>不同点：</strong></p><ul><li>最主要的区别就是TreeSet和TreeMap分别实现Set和Map接口</li><li>TreeSet只存储一个对象，而TreeMap存储两个对象Key和Value（仅仅key对象有序）</li><li>TreeSet中不能有重复对象，而TreeMap中可以存在</li><li>TreeMap的底层采用红黑树的实现，完成数据有序的插入，排序。</li></ul><p><strong>红黑树的特点：</strong></p><ul><li>性质 1：每个节点要么是红色，要么是黑色。</li><li>性质 2：根节点永远是黑色的。</li><li>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。</li><li>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</li><li>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</li></ul><h3 id="集合树状图"><a href="#集合树状图" class="headerlink" title="集合树状图"></a>集合树状图</h3><p><img src= "/img/loading.gif" data-src="/Users/fupeijun/Downloads/collection.png" alt="collection"></p><p><img src= "/img/loading.gif" data-src="/Users/fupeijun/Downloads/map.png" alt="map"></p><h2 id="数组和集合有什么区别"><a href="#数组和集合有什么区别" class="headerlink" title="数组和集合有什么区别"></a>数组和集合有什么区别</h2><ol><li>数组声明了它容纳的元素的类型，而集合不声明。</li><li>数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小，集合提供更多的成员方法，能满足更多的需求。</li><li>数组的存放的类型只能是一种（基本类型/引用类型）,集合存放的类型可以不是一种(不加泛型时添加的类型是Object)。</li><li>数组是java语言中内置的数据类型,是线性排列的,执行效率或者类型检查都是最快的。</li></ol><table><thead><tr><th align="center">数组</th><th align="center">集合</th></tr></thead><tbody><tr><td align="center">静态的 ,有固定的大小</td><td align="center">动态的,大小不固定</td></tr><tr><td align="center">存放类型只能是一种</td><td align="center">存放类型不只是一种</td></tr><tr><td align="center">线性排列,速度快</td><td align="center">多种排列方式,速度不一</td></tr></tbody></table><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h3 id="StringBuffer和StringBuilder的区别"><a href="#StringBuffer和StringBuilder的区别" class="headerlink" title="StringBuffer和StringBuilder的区别"></a>StringBuffer和StringBuilder的区别</h3><p>在改变字符串时，都不会创建新的对象。</p><p>不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>在Object类中主要包括clone()、finalize()、equals()、toString()等方法，其中常用的两个方法为equals()和toString()方法。</p><p><strong>Object类中的getClass()、notify()、notifyAll()、wait()等方法不能被重写，因为这些方法被定义为final类型。</strong></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Error-和-Exception的区别"><a href="#Error-和-Exception的区别" class="headerlink" title="Error 和 Exception的区别"></a>Error 和 Exception的区别</h3><pre><code>Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。</code></pre><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><pre><code>其中的Exception又分为检查性异常和非检查性异常。两个根本的区别在于，检查性异常 必须在编写代码时，使用try catch捕获（比如：IOException异常）。非检查性异常 在代码编写使，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。 </code></pre><p><strong>它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。</strong></p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><pre><code>表示系统级的错误和程序不必处理的异常，如：OutOfMemoryError、NoClassDefFoundError等。</code></pre><h3 id="受检异常和非受检异常"><a href="#受检异常和非受检异常" class="headerlink" title="受检异常和非受检异常"></a>受检异常和非受检异常</h3><p><strong>非受检异常指的是java.lang.RuntimeException和java.lang.Error类及其子类，所有其他的异常类都称为受检异常。</strong></p><p>以下是RuntimeException 非受检异常</p><p><code>Java.lang.ClassCastException</code></p><p><code>Java.lang.IllegalArgumentException</code></p><p><code>Java.lang.IndexOutOfBoundsException</code></p><p><code>Java.lang.ArrayIndexOutOfBoundsException</code></p><p><code>Java.lang.NullPointerException</code></p><h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><p>1、throw代表动作，表示抛出一个异常的动作；throws代表一种状态，代表方法可能有异常抛出<br>2、throw用在方法实现中，而throws用在方法声明中<br>3、throw只能用于抛出一种异常，而throws可以抛出多个异常</p><h2 id="什么是Java-EE"><a href="#什么是Java-EE" class="headerlink" title="什么是Java EE"></a>什么是Java EE</h2><p>Java 平台企业版</p><h3 id="JavaEE-与-JavaSE-的区别与联系"><a href="#JavaEE-与-JavaSE-的区别与联系" class="headerlink" title="JavaEE 与 JavaSE 的区别与联系"></a>JavaEE 与 JavaSE 的区别与联系</h3><p>JavaEE 是在 JavaSE 的基础上构建的，是对 JavaSE 的扩展，增加了一些更加便捷的应用框架。</p><h2 id="JavaEE主要技术"><a href="#JavaEE主要技术" class="headerlink" title="JavaEE主要技术"></a>JavaEE主要技术</h2><p><strong>JDBC</strong>  <strong>Servlet</strong>  <strong>jsp</strong>  <strong>XML</strong></p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><h2 id="JDBC执行步骤"><a href="#JDBC执行步骤" class="headerlink" title="JDBC执行步骤"></a>JDBC执行步骤</h2><ol><li>注册驱动</li><li>建立连接</li><li>创建statement语句对象</li><li>执行sql语句</li><li>处理返回的结果</li><li>关闭连接</li></ol><h2 id="什么是JDBC，在什么时候会用到它？"><a href="#什么是JDBC，在什么时候会用到它？" class="headerlink" title="什么是JDBC，在什么时候会用到它？"></a><strong>什么是JDBC，在什么时候会用到它？</strong></h2><p>JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包 里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。</p><p>JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p><h2 id="array和arrayList有什么区别"><a href="#array和arrayList有什么区别" class="headerlink" title="array和arrayList有什么区别"></a>array和arrayList有什么区别</h2><p>ArrayList可以算是Array的加强版，（对array有所取舍的加强）。</p><p>array长度固定，arrayList长度可变；</p><p>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>在处理元素前用于保存元素的 collection。除了基本的 <a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Collection.html"><code>Collection</code></a> 操作外，队列还提供其他的插入、提取和检查操作。每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（<code>null</code> 或 <code>false</code>，具体取决于操作）。插入操作的后一种形式是用于专门为有容量限制的 <code>Queue</code> 实现设计的；在大多数实现中，插入操作不会失败。</p><h2 id="Queue-中-poll-和-remove-有什么区别"><a href="#Queue-中-poll-和-remove-有什么区别" class="headerlink" title="Queue 中 poll()和 remove()有什么区别"></a>Queue 中 poll()和 remove()有什么区别</h2><p>poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。</p><table><thead><tr><th></th><th><em>抛出异常</em></th><th><em>返回特殊值</em></th></tr></thead><tbody><tr><td><strong>插入</strong></td><td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#add(E)"><code>add(e)</code></a></td><td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#offer(E)"><code>offer(e)</code></a></td></tr><tr><td><strong>移除</strong></td><td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#remove()"><code>remove()</code></a></td><td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#poll()"><code>poll()</code></a></td></tr><tr><td><strong>检查</strong></td><td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#element()"><code>element()</code></a></td><td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#peek()"><code>peek()</code></a></td></tr></tbody></table><h2 id="如何通过反射创建对象"><a href="#如何通过反射创建对象" class="headerlink" title="如何通过反射创建对象"></a>如何通过反射创建对象</h2><p>通过类对象调用newInstance()方法</p><p>通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象</p><h2 id="Spring用了哪些模式"><a href="#Spring用了哪些模式" class="headerlink" title="Spring用了哪些模式"></a>Spring用了哪些模式</h2><ol><li>工厂模式</li><li>单例模式</li><li>策略模式</li><li>代理模式</li><li>模版模式</li><li>适配器模式</li><li>观察者模式</li></ol><h2 id="代理模式是什么"><a href="#代理模式是什么" class="headerlink" title="代理模式是什么"></a>代理模式是什么</h2><p>为被代理对象提供一个代理对象，并由代理对象控制被代理对象的引用。</p><h3 id="为什么要用代理模式？"><a href="#为什么要用代理模式？" class="headerlink" title="为什么要用代理模式？"></a>为什么要用代理模式？</h3><p>中介隔离作用：<br>在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到<strong>中介的作用</strong>，其特征是代理类和委托类实现相同的接口。</p><h3 id="三种代理模式"><a href="#三种代理模式" class="headerlink" title="三种代理模式"></a>三种代理模式</h3><ol><li>静态代理</li><li>jdk动态代理</li><li>cblib动态代理</li></ol><h2 id="单例模式是什么"><a href="#单例模式是什么" class="headerlink" title="单例模式是什么"></a>单例模式是什么</h2><p><strong>单例模式（Singleton Pattern</strong>）是一种常用的软件设计模式，该模式的主要目的是确保<strong>某一个类只有一个实例存在</strong>。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。</p><h3 id="单例模式的作用："><a href="#单例模式的作用：" class="headerlink" title="单例模式的作用："></a>单例模式的作用：</h3><p>一是，解决多线程并发访问的问题。二是节约系统内存，提交系统运行的效率，提高系统性能。</p><h2 id="什么是工厂模式"><a href="#什么是工厂模式" class="headerlink" title="什么是工厂模式"></a>什么是工厂模式</h2><p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p><h2 id="数据库中有哪些约束"><a href="#数据库中有哪些约束" class="headerlink" title="数据库中有哪些约束"></a>数据库中有哪些约束</h2><ol><li><strong>主键约束</strong>（Primay Key Coustraint） 唯一性，非空性</li><li><strong>唯一约束</strong> （Unique Counstraint）唯一性，可以空，但只能有一个</li><li><strong>外键约束</strong> （Foreign Key Counstraint）需要建立两表间的关系并引用主表的列</li><li><strong>检查约束</strong> （Check Counstraint）对该列数据的范围、格式的限制（如：年龄、性别等）</li><li><strong>默认约束</strong> （Default Counstraint）该数据的默认值</li></ol><h2 id="Servlet的执行流程"><a href="#Servlet的执行流程" class="headerlink" title="Servlet的执行流程"></a>Servlet的执行流程</h2><ol><li>客户端发送请求给服务器。</li><li>服务器开始接受，先判断该请求的servlet实例是否存在，如果不存在先装载一个servlet类并创建实例。如果存在则直接调用该servlet的service方法，之后进行判断是调用doGet方法还是doPost方法。</li><li>servlet创建实例后，调用init方法进行初始化。之后调用servce方法，判断是调用doGet方法还是doPost方法。</li><li>最后判断服务是否关闭，如果关闭则调用destroy方法。</li></ol><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p><code>init()</code> <code>service()</code> <code>destroy()</code></p><h2 id="关系型数据库和非关系型数据库有什么区别"><a href="#关系型数据库和非关系型数据库有什么区别" class="headerlink" title="关系型数据库和非关系型数据库有什么区别"></a>关系型数据库和非关系型数据库有什么区别</h2><p><strong>关系型数据库 有</strong><code>MySQL</code> <code>SQLServer</code> <code>MariaDB</code> <code>oracle</code> <code>SQLite</code></p><p>关系型和非关系型数据库的主要差异是数据存储的方式。关系型数据天然就是表格式的，因此存储在数据表的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。</p><p><strong>优点：</strong><br>1、<strong>易于维护</strong>：都是使用表结构，<strong>格式一致</strong>；<br>2、<strong>使用方便</strong>：<strong>SQL语言通用</strong>，可用于复杂查询；<br>3、<strong>复杂操作</strong>：<strong>支持SQL</strong>，可用于一个表以及多个表之间非常复杂的查询。<br><strong>缺点：</strong><br>1、<strong>读写性能比较差</strong>，尤其是海量数据的高效率读写；<br>2、固定的表结构，<strong>灵活度稍欠</strong>；<br>3、高并发读写需求，传统关系型数据库来说，<strong>硬盘I/O是一个很大的瓶颈</strong>。</p><p><strong>非关系型数据库 有</strong> <code>Redis</code> <code>MongoDB</code> </p><p><strong>优点：</strong><br>1、<strong>格式灵活</strong>：存储数据的格式<strong>可以是key,value形式、文档形式、图片形式等等</strong>，文档形式、图片形式等等，使用灵活，应用场景广泛，<strong>而关系型数据库则只支持基础类型</strong>。<br>2、<strong>速度快</strong>：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>3、高扩展性；<br>4、<strong>成本低</strong>：nosql数据库<strong>部署简单</strong>，<strong>基本都是开源软件</strong>。</p><p><strong>缺点：</strong><br>1、不提供sql支持，<strong>学习和使用成本较高</strong>；<br>2、<strong>无事务处理</strong>；<br>3、<strong>数据结构相对复杂</strong>，复杂查询方面稍欠。</p><h2 id="配置SpringBean的几种方式"><a href="#配置SpringBean的几种方式" class="headerlink" title="配置SpringBean的几种方式"></a>配置SpringBean的几种方式</h2><p>有三种方式</p><ol><li>传统的XML配置方式</li><li>基于Java注解的配置</li><li>基于类的Java Config</li></ol><h2 id="Seralizable"><a href="#Seralizable" class="headerlink" title="Seralizable"></a>Seralizable</h2><p>Serializable是一个标识性接口，Java编译器在编译实现序列号接口的类的时候，会自动插入三个方法，这三个方法会自动完成对象的序列号与反序列化，在序列化时，Java的对象输入输出流，会自动调用这三个方法</p><h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><p>GET参数通过URL传递，POST放在Request body中。</p><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p><p>GET请求只能进行url编码，而POST支持多种编码方式。</p><p>GET请求在URL中传送的参数是有长度限制的，而POST没有。</p><h2 id="Spring中的bean是线程安全的吗"><a href="#Spring中的bean是线程安全的吗" class="headerlink" title="Spring中的bean是线程安全的吗"></a>Spring中的bean是线程安全的吗</h2><p>Spring容器本身并没有提供Bean的线程安全策略，因此可以说<strong>Spring容器中的Bean本身不具备线程安全的特性</strong></p><p>如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p><p>对于有状态的bean，Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法，<strong>因为ThreadLocal为每个线程保存线程私有的数据。</strong></p><h2 id="Java中参数传递的规则只有一种"><a href="#Java中参数传递的规则只有一种" class="headerlink" title="Java中参数传递的规则只有一种"></a>Java中参数传递的规则只有一种</h2><p><strong>值传递</strong></p><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><h2 id="JSP的作用域"><a href="#JSP的作用域" class="headerlink" title="JSP的作用域"></a>JSP的作用域</h2>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试内容</title>
      <link href="/2020/07/23/%E9%9D%A2%E8%AF%95%E5%86%85%E5%AE%B9/"/>
      <url>/2020/07/23/%E9%9D%A2%E8%AF%95%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>面试自我介绍<br>1,我是谁?我从哪里来?<br>2,我为什么来到这里?<br>3,我能给大家带来什么价值?<br>4,我希望得到什么样的支持.</p><p>自己的优点/优势  缺点 为什么要录用你<br>爱好<br>你还有什么问题要问的吗<br>    <code>工作时间安排</code> <code>在工作中具体的工作内容</code> <code>公司的未来发展规划</code> <code>公司的职业培训</code></p><h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><pre><code>针对每个功能，开发顺序应该是：数据库与数据表 &gt; 实体类 &gt; 持久层 &gt; 业务层 &gt; 控制器层 &gt; 前端界面。</code></pre><p>你好,我叫傅培峻.今天我面试的岗位是Java开发，我从网上看到贵公司招聘的这个职位，觉得自己比较适合公司的岗位，对自己的发展也有帮助，所以来这里争取下这份工作。我对Java这门语言能够熟练的掌握并使用,<br>并且有良好的面向对象的编程能力以及良好的编码习惯,愿意并喜欢去不断的学习新技术来继续丰富自已的知识,<br>希望能获得在贵公司提升自己的机会,并为公司发展贡献自己的力量。</p><h2 id="自己的优点-优势-缺点-为什么要录用你"><a href="#自己的优点-优势-缺点-为什么要录用你" class="headerlink" title="自己的优点/优势  缺点 为什么要录用你"></a>自己的优点/优势  缺点 为什么要录用你</h2><pre><code>我能够熟练的使用Java进行开发,熟悉开发流程,掌握SSM三大框架,熟练的使用MySQL数据库,对eclipse和idea开发工具都能够熟练的使用,对前端的html5,css和一些框架也有一定的了解.优点有一定自学能力,能够自己去学习新的技术,具有良好的编程能力和逻辑思维能力,熟悉计算机相关专业知识，。性格(比较随和吧)开朗，容易相处，有良好的团队合作意识和责任意识(上一次工作的经历有很强的责任感)缺点因为是转行的嘛，进入行业的时间还不长，对这个行业不是太了解，但是所需要的技术都已掌握，在工作中应该能很快的适应过来。</code></pre><p><strong>初级Java工程师</strong></p><p>　　面试初级Java工程师岗位时，首先应该重点突出一下自身的知识结构，因为面试初级岗位的应聘者往往没有实际工作经验，因此要强调自身的知识结构体系。如果是计算机相关专业的应届生，那么一定要首先突出描述自己的学历背景；因为学历背景是自身知识结构一个有力的“敲门砖”，如果是非计算机专业的毕业生，则要重点突出说一下自身的学习经历，强调自己的学习能力，与此同时突出一下自己的动手和实践能力。最后不管是计算机专业还是非计算机专业都要重点描述一下掌握了哪些Java技术，比如开源框架、数据库、大数据、消息队列、缓存等等。</p><p>总的来说，初级Java工程师岗位的面试需要在自我介绍中突出三点内容，其一是自身的知识结构；其二是独立开发能力；其三是学习能力，这三个方面的表述往往能够决定最终的面试结果。</p><p>带纸笔</p><p>复习资料</p><p>证书</p><p>u盘</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java十万个为什么(2)</title>
      <link href="/2020/07/22/Java%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88(2)/"/>
      <url>/2020/07/22/Java%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88(2)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>问题：关于JAVA 你知道什么？</p><p>问题：JAVA编程语言支持什么平台？</p><p>问题：请列举出JAVA至少5种特性。</p><p>问题：为什么JAVA是结构中立的？</p><p>问题：JAVA如何保证高效性？</p><p>问题：为什么JAVA是动态的？</p><p>问题：什么是JAVA虚拟机？它对JAVA的平台独立性有什么作用？</p><p>问题：列举两个JAVA集成编译环境。</p><p>问题：列举几个JAVA与C/C++不同的关键词。</p><p>问题：什么是对象？</p><p>一切事务皆对象，将现实的事物抽象出来，在java中，我们可以把拥有属性和getter&amp;setter方法的类都看作是对象。</p><p>问题：请给定义类 。</p><p>问题：一个类可以包含什么类型的变量？</p><p>问题：什么是局域变量？</p><p>问题：什么是实例变量？</p><p>问题：什么是类变量？</p><p>问题：什么是类的单例模式？</p><p>问题：什么是构造函数？</p><p>问题：列举为类创建对象的过程（三步）。</p><p>问题：JAVA中字节数据类型的默认值是多少？</p><p>问题：JAVA中float和double的默认值是多少？</p><p>问题：byte类型在什么时候使用？</p><p>问题：什么是静态变量？</p><p>问题：什么是访问控制修饰符？</p><p>问题：什么是受保护访问控制修饰符？</p><p>问题：什么是同步修饰符？</p><p>问题：在JAVA运算符优先级中，哪个运算符的优先级最高？</p><p>问题：在switch语句中能使用的数据类型包括哪些？</p><p>问题：parseInt()函数在什么时候使用到？</p><p>问题：为什么说String类是不可变的？</p><p>问题：为什么说StringBuffer类是可变的？</p><p>问题：StringBuffer和StringBuilder类的区别在哪？</p><p>问题：那个包使用正则表达式来实现模式匹配？</p><p>问题：java.util.regex包括那些类？</p><p>问题：什么是finalize()方法？</p><p>问题：什么是Exception？</p><p>问题：什么是受检查的异常？</p><p>问题：什么是运行时间异常？</p><p>问题：Exception类的两个子类是什么？</p><p>问题：关键词throws在什么情况下使用？</p><p>问题：关键词throw在什么时候使用？</p><p>问题：finally关键词在异常处理中如何使用？</p><p>问题：当自己创建异常类的时候应该注意什么？</p><p>回答：当创建异常类时应该注意：</p><p>问题：什么是继承？</p><p>问题：关键词super什么时候使用？</p><p>问题：什么是多态？</p><p>问题：什么是抽象？</p><p>问题：什么是抽象类？</p><p>问题：抽象方法什么时候被使用？</p><p>问题：什么是封装？</p><p>问题：封装最主要的优点是什么？</p><p>问题：什么是接口？</p><p>问题：接口具有什么特性？</p><p>问题：什么是包？</p><p>问题：为什么要使用包？</p><p>问题：什么是多线程编程？</p><p>问题：创建线程的两种方式是什么？</p><p>问题：什么是applet？</p><p>问题：applet继承哪个类？</p><p>问题：解释下JAVA的垃圾回收机制。</p><p>问题：什么是不可变对象？</p><p><a href="https://blog.csdn.net/weixin_33963594/article/details/90566155">https://blog.csdn.net/weixin_33963594/article/details/90566155</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库知识</title>
      <link href="/2020/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2020/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h5 id="SQL中有关DQL、DML、DDL、DCL的概念与区别"><a href="#SQL中有关DQL、DML、DDL、DCL的概念与区别" class="headerlink" title="SQL中有关DQL、DML、DDL、DCL的概念与区别"></a>SQL中有关DQL、DML、DDL、DCL的概念与区别</h5><p><strong>SQL结构化查询语言包含6个部分</strong></p><p><strong>1.数据查询语言（DQL: Data Query Language）</strong></p><p>select</p><p><strong>2.数据操纵语言（DML：Data Manipulation Language）</strong></p><p>insert</p><p>delete</p><p>update</p><p><strong>3.数据定义语言（DDL：Data Definition Language）</strong></p><p>常用的有CREATE和DROP，用于在数据库中创建新表或删除表，以及为表加入索引等。</p><p><strong>4.事务处理语言（DPL）</strong></p><p>事务处理语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION、COMMIT和ROLLBACK。</p><p><strong>5.数据控制语言（DCL：Data Control Language）</strong></p><p>通过GRANT和REVOKE，确定单个用户或用户组对数据库对象的访问权限。</p><p><strong>6.指针控制语言（CCL）</strong></p><p>它的语句，想DECLARE CURSOR、FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。</p><h5 id="SQL-Join"><a href="#SQL-Join" class="headerlink" title="SQL Join"></a>SQL Join</h5><p><strong>SQL中的join可以根据某些条件把指定的表结合起来并将数据返回给客户端</strong></p><p>join的方式有5种</p><p><code>inner join  内连接</code></p><p><code>left  join  左外连接</code></p><p><code>right join  右外连接</code></p><p><code>full  join  全连接</code></p><p><code>cross join  交叉连接</code></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程面试题</title>
      <link href="/2020/07/22/%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/07/22/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h5 id="线程的五种状态-生命周期"><a href="#线程的五种状态-生命周期" class="headerlink" title="线程的五种状态(生命周期)"></a>线程的五种状态(生命周期)</h5><p><code>新建状态</code></p><p><code>就绪状态</code></p><p><code>运行状态</code></p><p><code>阻塞状态</code></p><p><code>死亡状态</code></p><h5 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h5><h6 id="1、继承Thread类"><a href="#1、继承Thread类" class="headerlink" title="1、继承Thread类"></a>1、继承Thread类</h6><p>看jdk源码可以发现，Thread类其实是实现了Runnable接口的一个实例，继承Thread类后需要重写run方法并通过start方法启动线程。</p><p>继承Thread类耦合性太强了，因为java只能单继承，所以不利于扩展。</p><h6 id="2、实现Runnable接口"><a href="#2、实现Runnable接口" class="headerlink" title="2、实现Runnable接口"></a>2、实现Runnable接口</h6><p>通过实现Runnable接口并重写run方法，并把Runnable实例传给Thread对象，Thread的start方法调用run方法再通过调用Runnable实例的run方法启动线程。</p><p>所以如果一个类继承了另外一个父类，此时要实现多线程就不能通过继承Thread的类实现。</p><h6 id="3、实现Callable接口"><a href="#3、实现Callable接口" class="headerlink" title="3、实现Callable接口"></a>3、实现Callable接口</h6><p>通过实现Callable接口并重写call方法，并把Callable实例传给FutureTask对象，再把FutureTask对象传给Thread对象。它与Thread、Runnable最大的不同是Callable能返回一个异步处理的结果Future对象并能抛出异常，而其他两种不能。</p><h6 id="4、通过线程池创建线程"><a href="#4、通过线程池创建线程" class="headerlink" title="4、通过线程池创建线程"></a>4、通过线程池创建线程</h6><h5 id="start-方法和run-方法的区别"><a href="#start-方法和run-方法的区别" class="headerlink" title="start()方法和run()方法的区别"></a><strong>start()方法和run()方法的区别</strong></h5><p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p><h5 id="Runnable接口和Callable接口的区别"><a href="#Runnable接口和Callable接口的区别" class="headerlink" title="Runnable接口和Callable接口的区别"></a><strong>Runnable接口和Callable接口的区别</strong></h5><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>这其实是很有用的一个特性，因为<strong>多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p><h5 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a><strong>什么是线程安全</strong></h5><p><strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的</strong>。</p><p><strong>1）不可变</strong></p><p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><p><strong>2）绝对线程安全</strong></p><p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><p><strong>3）相对线程安全</strong></p><p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是<strong>fail-fast机制</strong>。</p><p><strong>4）线程非安全</strong></p><p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类，点击<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247486446&idx=2&sn=cb4f3aff0427c5ac3ffe5b61e150f506&chksm=eb538ed8dc2407ceb91fffe3c3bd559d9b15537446f84eb3bfb1a80e67f5efee176ca468a07b&scene=21#wechat_redirect">这里</a>了解为什么不安全。</p><h5 id="一个线程如果出现了运行时异常会怎么样"><a href="#一个线程如果出现了运行时异常会怎么样" class="headerlink" title="一个线程如果出现了运行时异常会怎么样"></a><strong>一个线程如果出现了运行时异常会怎么样</strong></h5><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：<strong>如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</strong></p><h5 id="如何在两个线程之间共享数据"><a href="#如何在两个线程之间共享数据" class="headerlink" title="如何在两个线程之间共享数据"></a><strong>如何在两个线程之间共享数据</strong></h5><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><h5 id="sleep方法和wait方法有什么区别"><a href="#sleep方法和wait方法有什么区别" class="headerlink" title="sleep方法和wait方法有什么区别"></a><strong>sleep方法和wait方法有什么区别</strong></h5><p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><ol><li>wait()来自Object类，sleep()来自Thread类</li><li>调用 sleep()方法，线程不会释放对象锁。而调用 wait() 方法线程会释放对象锁；</li><li>sleep()睡眠后不出让系统资源，wait()让其他线程可以占用 CPU；</li><li>sleep(millionseconds)需要指定一个睡眠时间，时间一到会自然唤醒。而wait()需要配合notify()或者notifyAll()使用</li></ol><h5 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a><strong>为什么要使用线程池</strong></h5><p>我们知道不用线程池的话，当线程数达到一定数量就会耗尽系统的CPU和内存资源，也会造成GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈。所以，线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存。点击<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247483824&idx=1&sn=7e34a3944a93d649d78d618cf04e0619&scene=21#wechat_redirect">这里</a>学习线程池详解。</p><h5 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a><strong>synchronized和ReentrantLock的区别</strong></h5><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><h5 id="怎么唤醒一个阻塞的线程"><a href="#怎么唤醒一个阻塞的线程" class="headerlink" title="怎么唤醒一个阻塞的线程"></a><strong>怎么唤醒一个阻塞的线程</strong></h5><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><h5 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a><strong>什么是乐观锁和悲观锁</strong></h5><p>1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将<strong>比较-替换</strong>这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><h5 id="并发与并行的区别是什么？"><a href="#并发与并行的区别是什么？" class="headerlink" title="并发与并行的区别是什么？"></a>并发与并行的区别是什么？</h5><p>如果某个系统支持两个或者多个动作（Action）<strong>同时存在</strong>，那么这个系统就是一个<strong>并发系统</strong>。如果某个系统支持两个或者多个动作<strong>同时执行</strong>，那么这个系统就是一个<strong>并行系统</strong>。并发系统与并行系统这两个定义之间的关键差异在于<strong>“存在”</strong>这个词。</p><h5 id="停止线程的方法"><a href="#停止线程的方法" class="headerlink" title="停止线程的方法"></a>停止线程的方法</h5><p>interrupt()</p><h5 id="同步方法有几种"><a href="#同步方法有几种" class="headerlink" title="同步方法有几种"></a>同步方法有几种</h5><p>synchronized同步方法</p><p>sychronized同步代码块</p><p>volatile关键字</p><p>Lock锁</p><p>AtomicInteger</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人网站建设方案书</title>
      <link href="/2020/07/20/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%A1%88%E4%B9%A6/"/>
      <url>/2020/07/20/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%A1%88%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>个人网站建设方案书</strong></p><p>备案主体：姓名，某ICP备XXXXXXX号，此次新增网站备案，域名：<a href="https://link.zhihu.com/?target=http%3A//XXXXX.cn">http://XXXXX.cn</a>，网站建设方案具体如下：</p><p>（一） 网站服务内容介绍：</p><p>用于搭建个人空间、程序代码学习测试，记录个人生活经历等，域名仅作个人使用，绑定国内云服务器用于学习云计算及测试。</p><p>（二） 组网方案：</p><p>使用华为云、阿里云、腾讯云、百度云、天翼云等服务器构建环境，配合CDN、云解析、函数计算和对象存储等组网搭建网站。</p><p>（三） 网站安全与信息安全管理制度：</p><p>网站防御上采用CDN和云解析防护，开启HTTPS访问，必要时开启WAF云防火墙及服务器端防火墙。信息安全上网站完全个人使用，用于展示，严格执行监管审核，网站内容不涉及违法违规内容，若有问题即刻关停整改。</p><p>（四） 本公司承诺网站实际开办内容与备案信息一致，如后续发现有违反以上承诺的行为，或者域名有交易行为、网站内容涉及互联网信息服务管理“九不准”等违法违规内容，愿意接受接入服务商关闭网站、主管部门注销备案并列入黑名单等处罚。</p><p>个人手写承诺：真的麻烦</p><p>个人签字：好麻烦</p><p>日期：麻烦</p><h2 id="网站建设方案书需包含的内容"><a href="#网站建设方案书需包含的内容" class="headerlink" title="网站建设方案书需包含的内容"></a>网站建设方案书需包含的内容</h2><p>网站建设方案书无固定模板，您可以根据网站的实际情况填写，但需要包含以下内容：</p><ul><li><p>网站内容及栏目介绍，需配上设计图。</p></li><li><p>人员及资金安排，包括人员的资质、能力、背景等。</p><p><strong>说明</strong> 如果是个人开办网站，需写明是全职或兼职，个人时间如何支配，个人政策知识、技术能力水平等。</p></li><li><p>内容管理制度。</p></li><li><p>网络部署方案，如使用什么技术，分别在哪里部署等。</p></li><li><p>网络信息安全技术措施。</p></li><li><p>应急处置方案。</p></li></ul><h2 id="保证书"><a href="#保证书" class="headerlink" title="保证书"></a>保证书</h2><p>本网站是个人网站，不含有企业、单位等非个人网站的信息，若在核实中发现网站中企业、单位等信息，本人愿接受以虚假信息进行备案，注销网站，并将主体和域名加入黑名单的处罚。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo问题解决</title>
      <link href="/2020/07/17/2020-07-17-Hexo%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/07/17/2020-07-17-Hexo%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>不知道什么原因，public文件夹里面没有了index.html。Nginx上会报 <code>403 Forbidden nginx/1.18.0</code>异常，本地 <code>hexo server</code>会报 <code>Cannot GET /</code>。</p><p>执行<code>npm audit fix</code>，查看是否少了什么组件，通过<code>npm install hexo-xxx-xxx</code> 安装即可。（我的hexo缺少了hexo-generator-index组件，因此执行npm install hexo-generator-index即可）</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Artitalk为hexo添加说说功能</title>
      <link href="/2020/07/11/%E4%BD%BF%E7%94%A8Artitalk%E4%B8%BAhexo%E6%B7%BB%E5%8A%A0%E8%AF%B4%E8%AF%B4%E5%8A%9F%E8%83%BD/"/>
      <url>/2020/07/11/%E4%BD%BF%E7%94%A8Artitalk%E4%B8%BAhexo%E6%B7%BB%E5%8A%A0%E8%AF%B4%E8%AF%B4%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="查看Artitalk官方使用文档"><a href="#查看Artitalk官方使用文档" class="headerlink" title="查看Artitalk官方使用文档"></a>查看<a href="https://artitalk.js.org/doc.html">Artitalk</a>官方使用文档</h1><p><img src= "/img/loading.gif" data-src="/img/Artitalk01.png" alt="官方文档方法"></p><p>严格按照官方文档创建，我就是看漏了一步弄了好久。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artitalk </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis03</title>
      <link href="/2020/07/10/09_MYBATIS_DAY03/"/>
      <url>/2020/07/10/09_MYBATIS_DAY03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-通过查询时自定义别名的方式解决名称不一致而导致的无法封装数据的问题"><a href="#1-通过查询时自定义别名的方式解决名称不一致而导致的无法封装数据的问题" class="headerlink" title="1. 通过查询时自定义别名的方式解决名称不一致而导致的无法封装数据的问题"></a>1. 通过查询时自定义别名的方式解决名称不一致而导致的无法封装数据的问题</h2><p>假设，向用户组数据表(<code>t_group</code>)表中插入一些测试数据：</p><pre><code class="mysql">INSERT INTO t_group (name) VALUES (&#39;超级管理员&#39;), (&#39;VIP用户&#39;), (&#39;普通用户&#39;);INSERT INTO t_group (name) VALUES (&#39;禁用用户&#39;);</code></pre><p>接下来，就应该在用户数据表(<code>t_user</code>)中添加新的字段，用于记录每个用户归属于哪个组：</p><pre><code class="mysql">ALTER TABLE t_user ADD COLUMN group_id int;</code></pre><p>然后，为现有的数据分配组：</p><pre><code class="mysql">UPDATE t_user SET group_id=1 WHERE id IN (11);UPDATE t_user SET group_id=2 WHERE id IN (9, 10);UPDATE t_user SET group_id=3 WHERE id IN (2, 6, 13);</code></pre><p>当用户数据表添加了新的字段以后，在项目中的<code>User</code>类也应该添加新的属性：</p><pre><code class="java">package cn.tedu.mybatis;public class User {    private Integer id;    private String username;    private String password;    private Integer age;    private String phone;    private String email;    private Integer groupId;    // Setters &amp; Getters    // toString()}</code></pre><p>当再次尝试查询数据时，会发现查询到的结果中，每条数据的<code>groupId</code>值均为<code>null</code>，其实这些数据在数据库中都是有值的，只是当前的查询功能并没有把它们查出来而已！</p><p><strong>MyBatis在处理查询时，会自动的将名称匹配的数据进行封装，其要求是查询结果的列名与封装结果的类的属性名相同</strong>（其实是要求属性的SET方法与之保持一致），如果名称不相同，则无法自动装配对应的数据！</p><blockquote><p>Field：字段，在设计数据表时定义的名称；</p><p>Column：列，在查询结果中，每个数据的名称就是列名；</p><p>Property：属性，在类中声明的全局变量；</p></blockquote><p>在查询时，默认情况下，列名就是字段名，但是，在查询的SQL语句中，可以自定义别名，例如：</p><pre><code class="mysql">SELECT id,username,password,age,phone,email,group_id groupId FROM t_user ORDER BY id</code></pre><p>则配置为：</p><pre><code class="xml">&lt;select id=&quot;findAll&quot; resultType=&quot;cn.tedu.mybatis.User&quot;&gt;    SELECT         id, username, password, age, phone, email,        group_id AS groupId     FROM         t_user     ORDER         BY id&lt;/select&gt;</code></pre><h2 id="2-使用resultMap节点解决名称不一致而导致的无法封装数据的问题"><a href="#2-使用resultMap节点解决名称不一致而导致的无法封装数据的问题" class="headerlink" title="2. 使用resultMap节点解决名称不一致而导致的无法封装数据的问题"></a>2. 使用resultMap节点解决名称不一致而导致的无法封装数据的问题</h2><p>在没有自定义别名的情况下，如果查询结果的列名与类的属性名不一致，还可以自定义<code>&lt;resultMap&gt;</code>节点进行配置，该节点的作用就是指导MyBatis封装查询到的数据！</p><pre><code class="xml">&lt;!-- id：自定义的名称，将应用于select节点的resultMap属性 --&gt;&lt;!-- type：封装查询结果的数据类型 --&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;cn.tedu.mybatis.User&quot;&gt;    &lt;!-- result节点：将查询结果中column列对应的值封装到类的property属性中去 --&gt;    &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;    &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt;    &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt;    &lt;result column=&quot;phone&quot; property=&quot;phone&quot;/&gt;    &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt;    &lt;result column=&quot;group_id&quot; property=&quot;groupId&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;findById&quot; resultMap=&quot;UserMap&quot;&gt;    SELECT        *    FROM         t_user     WHERE         id=#{id}&lt;/select&gt;</code></pre><p>在以上配置中，需要注意：<code>&lt;resultMap&gt;</code>节点中的<code>id</code>属性值就是<code>&lt;select&gt;</code>节点的<code>resultMap</code>属性值！</p><p>如果需要执行的查询操作是单表数据查询，在配置<code>&lt;resultMap&gt;</code>时，对于那些列名与属性名一致的，可以不作配置！</p><p>在配置<code>&lt;resultMap&gt;</code>时，推荐在子级使用<code>&lt;id&gt;</code>节点配置主键，然后使用<code>&lt;result&gt;</code>节点配置其它的，便于实现缓存！MyBatis有2级缓存，其中，MyBatis的1级缓存是SqlSession缓存，开发人员无法干预，2级缓存是namespace缓存，一旦开启，默认情况下，将作用于整个XML文件，需要事先在当前XML文件中添加<code>&lt;cache&gt;&lt;/cache&gt;</code>节点，表示“启用缓存”，理启用缓存，需要封装查询结果的数据类型是实现了<code>Serializable</code>接口的，如果某个查询不需要使用缓存，还可以在<code>&lt;select&gt;</code>节点中配置<code>useCache=&quot;false&quot;</code>，然后，就不需要开发人员进行其它配置了，MyBatis会自动处理缓存的数据，并且，一旦当前namespace执行了增删改类型的操作，就会重建缓存！</p><p><strong>小结</strong>：在SQL中使用自定义别名，并在<code>&lt;select&gt;</code>中使用<code>resultType</code>指定封装结果的数据类型，或在SQL中使用星号表示字段列表，并配置<code>&lt;resultMap&gt;</code>节点后在<code>&lt;select&gt;</code>中使用<code>resultMap</code>，均可解决由于名称不一致导致无法封装查询结果的问题。</p><h2 id="3-一对一的关联查询"><a href="#3-一对一的关联查询" class="headerlink" title="3. 一对一的关联查询"></a>3. 一对一的关联查询</h2><p>假设存在需求：根据id查询某用户的数据，并且，要求查出该用户归属的用户组的名称。</p><p>如果要根据id查询某用户的数据，需要执行的SQL语句大致是：</p><pre><code class="mysql">SELECT * FROM t_user WHERE id=?</code></pre><p>如果还要查出该用户归属的组的名称，需要关联<code>t_group</code>数据表一起查询：</p><pre><code class="mysql">SELECT * FROM t_user LEFT JOIN t_group ON t_user.group_id=t_group.id WHERE id=?</code></pre><p>由于以上关联条件就是<code>t_user.group_id=t_group.id</code>，结合使用星号作为字段列表，所以，在查询结果中，一定存在<code>group_id</code>和其后的<code>id</code>字段值一模一样的问题！由于有2个字段的值一定完全相同，则应该明确的指定需要查询的字段列表：</p><pre><code class="mysql">SELECT     t_user.*,    t_group.name FROM     t_user LEFT JOIN     t_group ON     t_user.group_id=t_group.id WHERE     t_user.id=?</code></pre><p>在使用MyBatis框架尝试实现功能时，目前并没有任何实体类可以封装以上查询的结果，因为实体类的属性设计是要求与数据表保持对应的，而此处需要执行的查询涉及2张表！则需要创建VO类（Value Object类）来封装此次查询的结果：</p><pre><code class="java">public class UserVO {    private Integer id;    private String username;    private String password;    private Integer age;    private String phone;    private String email;    private Integer groupId;    private String groupName;    // Setters &amp; Getters    // toString()}</code></pre><blockquote><p>实体类中的属性需要与数据表相对应；</p><p>VO类中的属性需要与查询结果相对应；</p><p>除此以外，这2种类的写法是一样的，只是定位不同。</p></blockquote><p>开发抽象方法：</p><pre><code class="java">UserVO findVOById(Integer id);</code></pre><p>配置SQL映射：</p><pre><code class="xml">&lt;select id=&quot;findVOById&quot; resultType=&quot;cn.tedu.mybatis.UserVO&quot;&gt;    SELECT         t_user.id, username, password, age, phone,         email, group_id AS groupId,        t_group.name AS groupName    FROM         t_user     LEFT JOIN         t_group     ON         t_user.group_id=t_group.id     WHERE         t_user.id=#{id}&lt;/select&gt;</code></pre><p>完成后，测试：</p><pre><code class="java">@Testpublic void findVOById() {    Integer id = 10;    UserVO user = userMapper.findVOById(id);    System.out.println(user);}</code></pre><h2 id="4-一对多的关联查询"><a href="#4-一对多的关联查询" class="headerlink" title="4. 一对多的关联查询"></a>4. 一对多的关联查询</h2><p>假设存在需求：根据id查询某个用户组的信息，并且，还查出该组有哪些用户，最终，把这些用户的信息也显示出来！</p><p>需要执行的SQL语句大致是：</p><pre><code class="mysql">SELECT    *FROM     t_groupLEFT JOIN    t_userON    t_group.id=t_user.group_idWHERE    t_group.id=1</code></pre><p>当查询后，需要使用一个新的VO类来封装此次的查询结果，则创建<code>GroupVO</code>类：</p><pre><code class="java">public class GroupVO {    private Integer id;    private String name;    private List&lt;User&gt; users;    // Setters &amp; Getters    // toString()}</code></pre><p>在一对多的查询中，MyBatis根本就不知道怎么封装查询结果中的数据！当没有匹配的查询结果，或只有1条查询结果时，并不会报错，只是查询结果的数据不正确而已，如果查询结果有多条，则会出现如下错误信息：</p><pre><code>Caused by: org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 2</code></pre><p>为了保障能够正确的封装查询结果，<strong>必须</strong>使用<code>&lt;resultMap&gt;</code>来指导MyBatis封装！并且，在SQL语句中，还需要为某个<code>id</code>定义别名，以保证查询结果每一列的名称都不同，否则，MyBatis只会从相同的列名中排列靠前的那一列中取数据，甚至，如果在<code>&lt;resultMap&gt;</code>中使用<code>&lt;id&gt;</code>配置主键，当出现多条数据的最靠前的那一列id值相同时，重复id的数据将不会被封装！</p><p>具体配置如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.tedu.mybatis.GroupMapper&quot;&gt;    &lt;resultMap id=&quot;GroupVOMap&quot; type=&quot;cn.tedu.mybatis.GroupVO&quot;&gt;        &lt;id column=&quot;gid&quot; property=&quot;id&quot; /&gt;        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;        &lt;!-- collection节点：用于配置1对多的属性 --&gt;        &lt;!-- ofType属性：集合元素类型 --&gt;        &lt;collection property=&quot;users&quot;            ofType=&quot;cn.tedu.mybatis.User&quot;&gt;            &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;            &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt;            &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt;            &lt;result column=&quot;phone&quot; property=&quot;phone&quot;/&gt;            &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt;            &lt;result column=&quot;group_id&quot; property=&quot;groupId&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;findVOById&quot; resultMap=&quot;GroupVOMap&quot;&gt;        SELECT            t_group.id AS gid, name,            t_user.*        FROM             t_group        LEFT JOIN            t_user        ON            t_group.id=t_user.group_id        WHERE            t_group.id=#{id}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>注意：在配置一对多的查询时，在<code>&lt;resultMap&gt;</code>中，即使存在列名与属性名完全相同的数据，也必须通过<code>&lt;id&gt;</code>或<code>&lt;result&gt;</code>节点进行配置！</p><h2 id="5-MyBatis阶段小结"><a href="#5-MyBatis阶段小结" class="headerlink" title="5. MyBatis阶段小结"></a>5. MyBatis阶段小结</h2><ul><li><p>【理解】MyBatis框架的主要作用是简化持久层开发；</p></li><li><p>【了解】使用MyBatis时的必要配置：</p><ul><li>添加依赖：<code>mybatis</code> / <code>mybatis-spring</code> / <code>spring-context</code> / <code>spring-jdbc</code> / <code>mysql-connector-java</code>(也可以是其它数据库连接jar包，根据实际情况选取) / <code>druid</code>(也可以是其它数据库连接池)；</li><li>配置连接数据库的信息，例如url、driver-class-name等；</li><li>配置XML文件的位置（如果使用XML配置SQL语句）；</li><li>使用配置类，读取连接数据库的信息，用于配置<code>DataSource</code>；配置<code>SqlSessionFactoryBean</code>；在配置类的声明之前使用<code>@MapperScan</code>注解配置接口文件所在的包；</li></ul></li><li><p>【掌握】抽象方法的声明原则</p><ul><li>【返回值类型】如果需要执行的操作是<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>类型的操作，使用<code>Integer</code>作为返回值类型，表示“受影响的行数”，也可以使用<code>void</code>但不推荐；如果需要执行操作是<code>SELECT</code>类型，使用期望的数据类型作为返回值类型，只需要保证该类型能够封装查询结果即可；</li><li>【方法名称】自定义，但不允许重载；</li><li>【参数列表】根据需要执行的SQL语句中的参数来设计，可以将所需的参数逐一的添加到抽象方法的参数列表中，也可以使用封装的类型作为参数，当抽象方法的参数超过1个（例如2个或更多个），必须（应该）为每个参数添加<code>@Param</code>注解并配置参数名称。</li></ul></li><li><p>【掌握】配置抽象方法对应的SQL语句</p><ul><li>可以在抽象方法的声明之前使用<code>@Insert</code>、<code>@Delete</code>、<code>@Update</code>、<code>@Select</code>节点配置SQL语句，这种做法不推荐用于篇幅较长的SQL语句，或配置较多的功能；</li><li>配置SQL语句的XML文件必须在配置指定的文件夹中；</li><li>每个XML文件的根节点是<code>&lt;mapper&gt;</code>，其中的<code>namespace</code>属性是对应的接口的全名；</li><li>在XML文件的子级通过<code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code>节点配置SQL语句，每个节点都必须配置<code>id</code>属性，取值为抽象方法的名称；</li><li>如果插入数据后需要获取自动编号的id值，需要在<code>&lt;insert&gt;</code>节点配置<code>useGeneratedKeys</code>和<code>keyProperty</code>属性；</li><li>在<code>&lt;select&gt;</code>节点中，必须配置<code>resultType</code>以指定抽象方法的返回值类型，或配置<code>resultMap</code>用于指导MyBatis封装查询结果，这2个属性必须配置其中的1个；</li></ul></li><li><p>【理解】关于<code>#{}</code>和<code>${}</code>格式的占位符的使用情景和区别；</p></li><li><p>【掌握】动态SQL的<code>&lt;foreach&gt;</code>的使用；</p></li><li><p>【了解】动态SQL的<code>&lt;if&gt;</code>和<code>&lt;choose&gt;</code>系列节点的使用；</p></li><li><p>【掌握】解决因为名称不一致导致MyBatis无法自动封装查询结果的问题</p><ul><li>当自定义字段列表时，自定义别名，使得名称保持一致，并且，在<code>&lt;select&gt;</code>节点中使用<code>resultType</code>即可；</li><li>当使用星号表示字段列表时，配置<code>&lt;resultMap&gt;</code>以指导MyBatis封装，并且，在<code>&lt;select&gt;</code>节点中使用<code>resultMap</code>应用配置的<code>&lt;resultMap&gt;</code>。</li></ul></li><li><p>【理解】实体类与VO类的区别；</p></li><li><p>【掌握】一对多的关联查询及相关配置（例如<code>&lt;resultMap&gt;</code>中的<code>&lt;collection&gt;</code>子节点）；</p></li><li><p>【了解】缓存的基本概念；</p></li><li><p>【理解】什么情况下需要使用<code>&lt;resultMap&gt;</code>：</p><ul><li>查询时，存在名称不匹配的问题，且使用星号表示字段列表；</li><li>【必须】配置1对多的查询；</li></ul></li><li><p>【理解】什么情况下需要自定义别名：</p><ul><li>查询时，存在名称不匹配的问题，且不使用<code>resultMap</code>，则需要自定义别名；</li><li>【必须】关联查询时，存在多个名称相同的列，则需要自定义别名，使得这些列名不同。</li></ul></li></ul><h2 id="6-作业"><a href="#6-作业" class="headerlink" title="6. 作业"></a>6. 作业</h2><p>要求用户可以通过注册页面提交注册数据，最终，注册成功后，数据将写入到<code>t_user</code>表中。</p><ul><li><p>要求用户名必须唯一，如果尝试注册的用户名已经被占用，应该给出错误提示，在持久层，应该至少开发<code>Integer insert(User user)</code>和<code>User findByUsername(String username)</code>方法，在用户尝试注册时，应该先通过<code>findByUsername()</code>检查用户名是否已经被占用（如果找到数据，则表示已被占用，如果找不到数据，则表示未被占用），再决定执行<code>insert()</code>或直接报错。</p></li><li><p>关于控制器中调用持久层方法，大致代码如下：</p><ul><li><pre><code class="java">@Controller@RequestMapping(&quot;user&quot;)public class UserController {    // 如果使用IDEA，可能报错，配置为@Autowired(required=false)即可    @Autowired    private UserMapper userMapper;    @RequestMapping(&quot;reg.do&quot;)    public String reg(User user) {        // 直接调用全局的userMapper即可访问持久层    }}</code></pre></li></ul></li></ul><p>如果时间充裕，再做一个登录功能。</p><p>如果已经完成，复习SSM框架，复习JSON，复习Vue。</p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis02</title>
      <link href="/2020/07/08/09_MYBATIS_DAY02/"/>
      <url>/2020/07/08/09_MYBATIS_DAY02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-使用XML文件配置SQL语句"><a href="#1-使用XML文件配置SQL语句" class="headerlink" title="1. 使用XML文件配置SQL语句"></a>1. 使用XML文件配置SQL语句</h2><p>首先下载<code>http://doc.canglaoshi.org/config/Mapper.xml.zip</code>，解压得到<strong>SomeMapper.xml</strong>。</p><p>在项目的<strong>src/main/resources</strong>下创建<strong>mappers</strong>文件夹，并将<strong>SomeMapper.xml</strong>复制到该文件夹，并重命名为<strong>UserMapper.xml</strong>。</p><blockquote><p>此步骤中创建的文件夹的名称是自定义的，与后续的配置有关。</p><p>此步骤中XML文件的名称是自定义的，与其它任何配置都无关。</p></blockquote><p>以上添加的<strong>UserMapper.xml</strong>就是用于配置SQL语句的文件，通常称之为<strong>映射文件</strong>！该文件中的以下代码是固定的，且不可缺少的：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</code></pre><p>该文件的根节点是<code>&lt;mapper&gt;</code>节点，必须配置<code>namespace</code>的属性，该属性的值是对应的MyBatis接口文件的全名，例如：</p><pre><code class="xml">&lt;mapper namespace=&quot;cn.tedu.mybatis.UserMapper&quot;&gt;&lt;/mapper&gt;</code></pre><p>接下来，根据需要执行的SQL语句的种类，选择使用<code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code>这4个节点中的某1个来配置SQL语句，这些节点都必须配置<code>id</code>属性，该属性的值就是接口中的抽象方法的名称，然后，在节点内部编写SQL语句即可：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace属性：接口的全名 --&gt;&lt;mapper namespace=&quot;cn.tedu.mybatis.UserMapper&quot;&gt;    &lt;!-- id属性：抽象方法的名称 --&gt;    &lt;insert id=&quot;insert&quot;&gt;        INSERT INTO t_user (            username, password, age, phone, email        ) VALUES (            #{username}, #{password}, #{age}, #{phone}, #{email}        )    &lt;/insert&gt;&lt;/mapper&gt;</code></pre><p>目前，MyBatis框架并不知道存在<strong>mappers</strong>文件夹，更加不知道哪个文件配置的SQL语句！可以将配置SQL语句的XML文件的位置配置在<strong>jdbc.properties</strong>中：</p><pre><code>mybatis.mapper-locations=classpath:mappers/*.xml</code></pre><p>以上代码就用于表示“在<strong>src/main/resouces</strong>下的<strong>mappers</strong>文件夹中的所有XML文件都是用于配置SQL语句的”，在后续使用时，也必须保证不会在<strong>mappers</strong>文件夹中添加其它作用的XML文件！</p><p>接下来，还应该读取以上配置信息：</p><pre><code class="java">@Value(&quot;${mybatis.mapper-locations}&quot;)private Resource[] mapperLocations;</code></pre><p>并应用于<code>SqlSessionFactoryBean</code>对象的属性中：</p><pre><code class="java">@Beanpublic SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) {    SqlSessionFactoryBean bean = new SqlSessionFactoryBean();    bean.setDataSource(dataSource);    bean.setMapperLocations(mapperLocations);    return bean;}</code></pre><p>最后，在运行或测试之前，还需要注意：每个抽象方法只能通过1种方式配置SQL语句，要么使用注解，要么使用XML文件，不可以同时使用！否则将报错，错误提示的关键信息例如：</p><pre><code>Caused by: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for cn.tedu.mybatis.UserMapper.insert. please check file [D:\eclipse-workspace-202003\mybatis\target\classes\mappers\UserMapper.xml] and cn/tedu/mybatis/UserMapper.java (best guess)</code></pre><p>以上提示中的<code>Mapped Statements collection already contains value for cn.tedu.mybatis.UserMapper.insert.</code>就表示“<code>cn.tedu.mybatis.UserMapper.insert</code>方法被映射了多个SQL语句的配置”，并且还推荐了检查<strong>UserMapper.xml</strong>和<strong>UserMapper.java</strong>文件！</p><p>如果配置的是<code>&lt;insert&gt;</code>节点，且需要获取自动编号的ID值，则在<code>&lt;insert&gt;</code>节点中继续配置属性即可，例如：</p><pre><code class="xml">&lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    INSERT INTO t_user (        username, password, age, phone, email    ) VALUES (        #{username}, #{password}, #{age}, #{phone}, #{email}    )&lt;/insert&gt;</code></pre><p>当需要实现的数据访问是查询类型的，在<code>&lt;select&gt;</code>节点中必须配置<code>resultType</code>或<code>resultMap</code>中的某1个属性（二选一），如果都没有指定，则会出现如下错误：</p><pre><code>Caused by: org.apache.ibatis.executor.ExecutorException: A query was run and no Result Maps were found for the Mapped Statement &#39;cn.tedu.mybatis.UserMapper.count&#39;.  It&#39;s likely that neither a Result Type nor a Result Map was specified.</code></pre><p>其中，<code>resultType</code>指的就是“封装查询结果的数据的类型”，也可以理解为“抽象方法的返回值的类型”，例如可以配置为：</p><pre><code class="xml">&lt;select id=&quot;count&quot; resultType=&quot;java.lang.Integer&quot;&gt;    SELECT COUNT(*) FROM t_user&lt;/select&gt;</code></pre><p>如果某个查询的抽象方法的返回值是<code>List</code>集合类型的，例如：</p><pre><code class="java">List&lt;User&gt; findAll();</code></pre><p>在配置<code>&lt;select&gt;</code>的<code>resultType</code>属性时，该属性值必须是集合中的元素的类型，例如：</p><pre><code class="xml">&lt;select id=&quot;findAll&quot; resultType=&quot;cn.tedu.mybatis.User&quot;&gt;    SELECT * FROM t_user ORDER BY id&lt;/select&gt;</code></pre><p>至于<code>resultMap</code>属性，后面专门介绍。</p><p>注意：使用了这种做法后，就需要对抽象方法名称的定义增加一个要求“不允许重载”！</p><h2 id="2-关于多参数的问题"><a href="#2-关于多参数的问题" class="headerlink" title="2. 关于多参数的问题"></a>2. 关于多参数的问题</h2><p>当抽象方法的参数列表中超过1个参数时，在配置SQL语句时直接使用<code>#{参数名称}</code>是无法访问到参数值的！</p><p>因为Java源文件在运行之前需要被编译成字节码文件（.class文件），编译时，会丢失所有局部的量的名称，所以，会导致运行时原有的“参数名称”无法使用的问题！</p><p>MyBatis允许使用<code>arg</code>作为前缀并添加从<code>0</code>开始编号的名称（例如<code>arg0</code>、<code>arg1</code>等等）表示第?个参数的名称，后续，在配置SQL语句时，就可以通过例如<code>#{arg0}</code>来表示抽象方法的第1个参数的值，使用<code>#{arg1}</code>表示抽象方法的第2个参数的值……以此类推！另外，还可以使用<code>param</code>作为前缀并添加从<code>1</code>开始编号的名称（例如<code>param1</code>、<code>param2</code>等等），在具体使用时，使用<code>arg</code>系列的名称和<code>param</code>系列的名称均可！</p><p>但是，使用<code>arg</code>和<code>param</code> 系列的名称不便于表示语义，并且，当抽象方法的参数列表发生变化时，这些名称中的序号也可能需要调整！</p><p>MyBatis提供了<code>@Param</code>注解，这个注解是添加在抽象方法的各参数之前的，可以在该注解中指定名称，后续，在配置SQL语句时，占位符中就使用注解中配置的名称！</p><h2 id="2-练习"><a href="#2-练习" class="headerlink" title="2. 练习"></a>2. 练习</h2><ul><li><p>在<code>tedu_ums</code>数据库中创建<code>t_group</code>表，用于存储“用户分组”的信息，该表需要有<code>id</code>和<code>name</code>这2个字段，分别表示“组id”和“组名称”；</p><ul><li><pre><code class="mysql">CREATE TABLE t_group (    id int AUTO_INCREMENT,    name VARCHAR(10) NOT NULL UNIQUE,    PRIMARY KEY (id)) DEFAULT CHARSET=utf8mb4;</code></pre></li></ul></li><li><p>在项目中，创建<code>Group</code>实体类，对应<code>t_group</code>表；</p><ul><li><pre><code class="java">package cn.tedu.mybatis;public class Group {    private Integer id;    private String name;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    @Override    public String toString() {        return &quot;Group [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;;    }}</code></pre></li></ul></li><li><p>通过MyBatis技术，实现：</p><ul><li>增加组；</li><li>根据id删除组；</li><li>根据id查询组；</li><li>查询所有组。</li></ul></li></ul><h2 id="3-动态SQL-–-foreach"><a href="#3-动态SQL-–-foreach" class="headerlink" title="3. 动态SQL – foreach"></a>3. 动态SQL – foreach</h2><p>假设存在需求：批量删除用户数据（一次性删除若干条用户数据）；</p><p>需要执行的SQL语句大致是：</p><pre><code class="mysql">DELETE FROM t_user WHERE id=? OR id=? OR id=?;DELETE FROM t_user WHERE id IN (?,?,?);</code></pre><p>作为开发人员，无法确定以上SQL语句中问号的数量，及问号对应的参数值！只能确定以上参数的数据类型及所表示的意义！</p><p>以上功能最终将由用户（软件的使用者）来决定需要删除的数据的数量（问号的数量），及删除的数据是哪几条（问号对应的参数值）！就会导致“当用户的操作不同时（选中需要删除的数据不同），最终需要执行的SQL语句是不同的”！MyBatis框架提供了“动态SQL”机制来解决这个问题！</p><p><strong>动态SQL</strong>：根据用户提供的参数值不同，最终需要执行的SQL语句可以不同！</p><p>当需要实现以上批量删除的需求时，可以将抽象方法设计为：</p><pre><code class="java">Integer deleteByIds(List&lt;Integer&gt; ids);</code></pre><p>或者，也可以设计为（本次案例就使用这个）：</p><pre><code class="java">Integer deleteByIds(Integer[] ids);</code></pre><p>甚至，还可以设计为：</p><pre><code class="java">Integer deleteByIds(Integer... ids);</code></pre><blockquote><p>可变参数在被处理时，本质上就是数据。</p></blockquote><p>在配置SQL语句时，需要通过<code>&lt;foreach&gt;</code>节点来配置SQL语句中需要通过循环生成的部分：</p><pre><code class="xml">&lt;delete id=&quot;deleteByIds&quot;&gt;    DELETE FROM t_user WHERE id IN (        &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;            #{id}        &lt;/foreach&gt;    )&lt;/delete&gt;</code></pre><p>关于<code>&lt;foreach&gt;</code>节点的配置：</p><ul><li><p><code>collection</code>：需要被遍历的对象，当抽象方法的参数只有1个且没有添加<code>@Param</code>注解时，如果参数类型是<code>List</code>集合，则取值为<code>list</code>，如果参数类型是数组，则取值为<code>array</code>；当抽象方法的参数超过1个，就一定添加了<code>@Param</code>注解，则取值为<code>@Param</code>注解配置的参数值；</p></li><li><p><code>item</code>：遍历过程中的每一个元素数据，当前属性可以自定义值表示元素数据的名称，在<code>&lt;foreach&gt;</code>节点的子级，使用<code>#{}</code>占位符时，就可以使用这个名称来表示数据；</p></li><li><p><code>separator</code>：遍历生成的代码片段中，各元素数据之间的分隔符号；</p></li><li><p><code>open</code> / <code>close</code>：遍历生成的代码片段的最左侧字符串/最右侧字符串。</p></li></ul><p><strong>练习</strong>：根据若干个用户的id将这些用户的密码设置为某个值。</p><p>需要执行的SQL语句大致是：</p><pre><code class="mysql">UPDATE t_user SET password=? WHERE id IN (?,?,?)</code></pre><p>可以将抽象方法设计为：</p><pre><code class="java">Integer updatePasswordByIds(    @Param(&quot;ids&quot;) List&lt;Integer&gt; ids,     @Param(&quot;password&quot;) String password);</code></pre><p>然后，配置SQL语句（配置映射）：</p><pre><code class="xml">&lt;update id=&quot;updatePasswordByIds&quot;&gt;    UPDATE t_user SET password=#{password} WHERE id IN (        &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;            #{id}        &lt;/foreach&gt;    )&lt;/update&gt;</code></pre><h2 id="4-动态SQL-–-if"><a href="#4-动态SQL-–-if" class="headerlink" title="4. 动态SQL – if"></a>4. 动态SQL – if</h2><p>在配置SQL语句时，可以添加<code>&lt;if&gt;</code>节点用于判断参数值，从而决定最终执行的SQL语句中是否包括某个SQL语句片段。</p><p>例如存在：</p><pre><code class="java">List&lt;User&gt; find(    @Param(&quot;where&quot;) String where,    @Param(&quot;orderBy&quot;) String orderBy,     @Param(&quot;offset&quot;) Integer offset,     @Param(&quot;count&quot;) Integer count);</code></pre><p>则可以配置为：</p><pre><code class="xml">&lt;select id=&quot;find&quot; resultType=&quot;cn.tedu.mybatis.User&quot;&gt;    SELECT * FROM t_user    &lt;if test=&quot;where != null&quot;&gt;        WHERE ${where}    &lt;/if&gt;    &lt;if test=&quot;orderBy != null&quot;&gt;        ORDER BY ${orderBy}    &lt;/if&gt;    &lt;if test=&quot;offset != null and count != null&quot;&gt;        LIMIT #{offset}, #{count}    &lt;/if&gt;&lt;/select&gt;</code></pre><p>需要注意：以上案例只是假想中的代码，在实际开发时，一定不要这样来使用！</p><p>需要注意：在动态SQL中，<code>&lt;if&gt;</code>节点并没有匹配的<code>else</code>部分！如果一定需要实现<code>if...else</code>的语法效果，可以写2个条件完全相反的<code>&lt;if&gt;</code>节点，或者，通过<code>&lt;choose&gt;</code>、<code>&lt;when&gt;</code>、<code>&lt;otherwise&gt;</code>节点进行配置，其基本格式是：</p><pre><code class="xml">&lt;choose&gt;    &lt;when test=&quot;&quot;&gt;        满足条件时的SQL语句片段    &lt;/when&gt;    &lt;otherwise&gt;        不满足条件时的SQL语句片段    &lt;/otherwise&gt;&lt;/choose&gt;</code></pre><h2 id="5-关于-和-格式的占位符"><a href="#5-关于-和-格式的占位符" class="headerlink" title="5. 关于#{}和${}格式的占位符"></a>5. 关于#{}和${}格式的占位符</h2><p>MyBatis允许在配置SQL语句时使用<code>#{}</code>和<code>${}</code>这2种格式的占位符来表示参数值。</p><p><strong>简单原则</strong>：在原本使用JDBC技术编程时，编写SQL语句时可以写问号(<code>?</code>)的位置，都使用<code>#{}</code>格式的占位符，不可以写问号的位置，必须使用<code>${}</code>格式的占位符！</p><p>使用<code>#{}</code>格式的占位符，只能表示某个值！MyBatis在处理时，会通过预编译的方式进行处理，即：先使用问号对占位符表示的值进行占位，并将整个SQL语句交由MySQL进行编译相关的处理（包括词法分析、语义分析、编译），当编译完成后，再将值代入到编译成功的SQL语句中一并执行。简单来说，使用<code>#{}</code>格式的占位符时，最终处理机制是使用了预编译的！所以，使用这种格式的占位符时，在编写SQL时<strong>不需要关心值的数据类型的问题</strong>，并且，<strong>不存在SQL注入的风险</strong>！</p><p>使用<code>${}</code>格式的占位符，可以表示SQL语句中的任意片段！MyBatis在处理时，会先将<code>${}</code>格式占位符对应的值<strong>拼接</strong>到SQL语句中，然后再将SQL语句交由MySQL进行编译相关处理，也就是说，<code>${}</code>格式占位符的值在编译之前就已经代入到SQL语句中了！很显然，在处理<code>${}</code>格式的占位符时，没有（也不可能）使用预编译！所以，使用这种格式的占位符时，<strong>需要自行在SQL语句中考虑数据类型的问题</strong>，例如字符串类型的值需要使用一对单引号框住！另外，还<strong>存在SQL注入的风险</strong>！</p><hr><h2 id="【整合SSM框架】"><a href="#【整合SSM框架】" class="headerlink" title="【整合SSM框架】"></a>【整合SSM框架】</h2><p>在创建SpringMVC项目的基础之上，将<code>mybatis</code>案例中的<code>SpringConfig</code>类放进去，并作为项目初始化类的<code>getRootConfigClasses()</code>方法的返回值，并添加<strong>jdbc.properties</strong>配置文件及相关依赖即可。</p><p>注意：为了确保框架整合后可以正常使用，推荐在<code>SpringConfig</code>类的声明之前添加<code>@Configuration</code>注解。</p><p>提示：当在控制器中需要使用持久层对象时，直接声明出<code>private UserMapper userMapper;</code>属性并添加<code>@Autowired</code>注解，即可在控制器中调用持久层所开发的方法！</p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码</title>
      <link href="/2020/07/08/09_MYBATIS_DAY01_PLUS/"/>
      <url>/2020/07/08/09_MYBATIS_DAY01_PLUS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>计算机能够直接识别并处理的只有二进制数，这是由计算机的电子元器件的特性所导致的！</p><p>在二进制数中，每个0或每个1所占据的存储空间是1个二进制位（bit），由于1个二进制能够表达的信息含义只有2种，所以，1个二进制位不足以表达大量有意义的信息，通常使用字节（byte）来表示，每1个字节占8个二进制位，它是计算机中最基础的存储单位。</p><p>为了表示人类生活中使用到的字符（字母、数字、标点符号），早期就设计出了ASCII码表，它就记录了字符与二进制数的对应关系，例如<code>110 0001</code>就对应<code>a</code>，<code>110 0010</code>对应<code>b</code>……</p><p>由于ASCII码表记录都是1个字节能够表示的字符，除去最高位的符号位，只有7个二进制位，只能表示128种不同的意义，就无法表示中文！所以，就出现了其它的编码，例如GBK、GB2312等，当然，ASCII码表也不适用于其它不使用英语的国家和民族，例如日本、韩国等，也创建了对应的编码。</p><p>由于越来越多的国家和民族都普及了计算机，设计出来的编码的种类太多，为了统一支持统一使用，就出现了Unicode编码，这是一种全球化编码，记录了全世界各国家和民族所使用的各种字符！</p><p>使用Unicode编码时，大多情况下使用2个字节来描述1个字符，假设可以使用<code>1010 0011 1010 0101</code>可以表示“汉”（只是假设而已），可以使用<code>1011 1111 0000 1010</code>表示“字”，当需要将“汉字”这2个字符在网络传输，可能在网络上出现的二进制数据就是<code>1010 0011 1010 0101 1011 1111 0000 1010</code> ，但是，当接收方接收到这个二进制的序列时，就无法明确：这到底是2个汉字，还是4个英文，甚至是1汉字2英文，或2英文1汉字，或1英文1汉字1英文……</p><p>为了保障传输过程不会出现以上假设的问题，就产生了UTF系列的编码！</p><blockquote><p>UTF = Unicode Transformation Format，Unicode传输编码。</p></blockquote><p>以UTF-8为例，当需要传输2个字节才可以表示的1个字符时，会将二进制序列中的特定位置作为标记，并不用于表示编码的含义，凡是2个字节的数据，其格式都是：</p><pre><code>110 xxxxx    10 xxxxxx</code></pre><p>以上第1个字节的<code>110</code>中包括了2个<code>1</code>，就表示“从当前字节开始，一共有2个字节来描述同1个字符”！</p><p>当需要传输3个字节才可以表示的1个字符时，其格式是：</p><pre><code>1110 xxxx    10 xxxxxx    10 xxxxxx</code></pre><p>甚至还可以使用4个字节表示1个字符，其格式是：</p><pre><code>11110 xxx    10 xxxxxx    10 xxxxxx    10 xxxxxx</code></pre><p>在UTF-8编码规则中，如果使用2个字节来表示1个字符，实际可用的编码位只有11个二进制位，只能表示2048种不同的意义，所以，使用UTF-8编码表示中文时，需要使用3个字节（3个字节可用的编码位有16位，可以表示65536种不同的意义）！</p><p>由于UTF-8编码使用3个字节就可以表示常规使用的所有字符，一般够用，也有一些罕见的字符并没有收录进来，所以就产生了“使用4个字节表示1个字符”的做法，由于非常罕见，一般并不需要使用，所以，UTF-8编码又被区分为utf8mb3和utf8mb4。</p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis01</title>
      <link href="/2020/07/08/09_MYBATIS_DAY01_1748/"/>
      <url>/2020/07/08/09_MYBATIS_DAY01_1748/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-MyBatis框架的作用"><a href="#1-MyBatis框架的作用" class="headerlink" title="1. MyBatis框架的作用"></a>1. MyBatis框架的作用</h2><p>MyBatis框架的主要作用是简化持久层开发。当使用MyBatis处理数据的增删改查时，只需要定义访问数据的抽象方法，并配置该抽象方法对应的SQL语句即可！</p><p>持久层：解决项目中数据持久化处理的组件。</p><p>数据持久化：将数据永久的保存下来，即将数据存储在硬盘等可以永久保存数据的存储介质中，如果要将数据保存在这些存储介质中，数据需要以文件的形式存在，通常，可以将数据存到文本文档、XML文档、数据库，通常，在没有明确的说明的情况下，讨论数据持久化指的就是使用数据库存取数据。</p><p>内存（RAM，具体表现通常是内存条）：是CPU与其它硬件交换数据的“桥梁”，正在执行的程序和数据都在内存中，一旦断电则数据全部丢失。</p><h2 id="2-创建MyBatis项目"><a href="#2-创建MyBatis项目" class="headerlink" title="2. 创建MyBatis项目"></a>2. 创建MyBatis项目</h2><p>创建Maven项目，Group Id为<code>cn.tedu</code>，Artifact Id为<code>mybatis</code>，Packaging保持为<code>jar</code>即可。</p><p>然后，在项目中添加相关依赖：</p><pre><code class="xml">&lt;properties&gt;    &lt;!-- java version --&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    &lt;!-- dependency version --&gt;    &lt;mybatis.version&gt;3.5.4&lt;/mybatis.version&gt;    &lt;mybatis.spring.version&gt;2.0.5&lt;/mybatis.spring.version&gt;    &lt;spring.version&gt;5.2.7.RELEASE&lt;/spring.version&gt;    &lt;mysql.version&gt;8.0.12&lt;/mysql.version&gt;    &lt;druid.version&gt;1.1.23&lt;/druid.version&gt;    &lt;junit.version&gt;4.13&lt;/junit.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;!-- MyBatis：mybatis --&gt;    &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;${mybatis.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- MyBatis整合Spring：mybatis-spring --&gt;    &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;${mybatis.spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring：spring-context --&gt;    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring JDBC：spring-jdbc --&gt;    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- MySQL：mysql-connector-java --&gt;    &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;${mysql.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 连接池：druid --&gt;    &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;${druid.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 单元测试：junit --&gt;    &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;${junit.version}&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h2 id="3-连接数据库"><a href="#3-连接数据库" class="headerlink" title="3. 连接数据库"></a>3. 连接数据库</h2><p>首先，登录MySQL控制台，创建<code>tedu_ums</code>数据库：</p><pre><code class="mysql">CREATE DATABASE tedu_ums;</code></pre><p>然后，在项目中，在<strong>src/main/resources</strong>下创建<strong>jdbc.properties</strong>文件，用于配置连接数据库的相关信息：</p><pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/tedu_ums?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghaispring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.username=rootspring.datasource.password=rootspring.datasource.initialSize=2spring.datasource.maxActive=10</code></pre><p>接下来，在项目的<strong>src/main/java</strong>下创建<code>cn.tedu.mybatis</code>包，并在这个包下创建<code>SpringConfig</code>类，在该类中声明属性以读取以上配置值：</p><pre><code class="java">package cn.tedu.mybatis;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;@PropertySource(&quot;classpath:jdbc.properties&quot;)public class SpringConfig {    @Value(&quot;${spring.datasource.url}&quot;)    private String url;    @Value(&quot;${spring.datasource.driver-class-name}&quot;)    private String driverClassName;    @Value(&quot;${spring.datasource.username}&quot;)    private String username;    @Value(&quot;${spring.datasource.password}&quot;)    private String password;    @Value(&quot;${spring.datasource.initialSize}&quot;)    private Integer initialSize;    @Value(&quot;${spring.datasource.maxActive}&quot;)    private Integer maxActive;}</code></pre><p>然后，继续添加方法，将以上读取到的信息用于配置<code>DataSource</code>对象，并将该对象交给框架处理：</p><pre><code class="java">@Beanpublic DataSource dataSource() {    // 当前项目添加依赖时    // 数据库连接池使用的是druid    // 所以，此处创建DruidDataSource的对象    // 如果以后改用其它数据库连接池    // 则创建其它数据库连接池中的对象即可    DruidDataSource ds = new DruidDataSource();    ds.setUrl(url);    ds.setDriverClassName(driverClassName);    ds.setUsername(username);    ds.setPassword(password);    ds.setInitialSize(initialSize);    ds.setMaxActive(maxActive);    return ds;}</code></pre><blockquote><p>注意：使用DataSource时，导包必须导javax.sql包中的接口。</p></blockquote><p>接下来，在<strong>src/test/java</strong>下创建<code>cn.tedu.mybatis</code>包，并在这个包中创建<code>Tests</code>测试类，在类中添加测试方法：</p><pre><code class="java">package cn.tedu.mybatis;import java.sql.Connection;import java.sql.SQLException;import javax.sql.DataSource;import org.junit.Test;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Tests {    // 关于4.x系列单元测试方法的声明：    // 1. 必须添加@Test注解；    // 2. 必须使用public权限；    // 3. 必须使用void作为返回值类型；    // 4. 必须保持空参数列表（不允许有参数）    @Test    public void contextLoads() {        System.out.println(&quot;Tests.contextLoads()&quot;);    }    @Test    public void getConnection() throws SQLException {        AnnotationConfigApplicationContext ac            = new AnnotationConfigApplicationContext(SpringConfig.class);        DataSource dataSource = ac.getBean(&quot;dataSource&quot;, DataSource.class);        Connection conn = dataSource.getConnection();        System.out.println(conn);        ac.close();    }}</code></pre><p>如果以上单元测试可以正常通过，则表示连接数据库的相关配置均正确，后续，框架就可以通过以上配置的对象自动连接到数据库。</p><h2 id="4-创建数据表"><a href="#4-创建数据表" class="headerlink" title="4. 创建数据表"></a>4. 创建数据表</h2><p>在<code>tedu_ums</code>数据库中创建<code>t_user</code>数据表：</p><pre><code class="mysql">CREATE TABLE t_user (    id int AUTO_INCREMENT,    username varchar(20) NOT NULL UNIQUE,    password varchar(20) NOT NULL,    age int,    phone varchar(20),    email varchar(30),    PRIMARY KEY (id)) DEFAULT CHARSET=utf8mb4;</code></pre><h2 id="5-插入数据"><a href="#5-插入数据" class="headerlink" title="5. 插入数据"></a>5. 插入数据</h2><h3 id="5-1-定义抽象方法"><a href="#5-1-定义抽象方法" class="headerlink" title="5.1. 定义抽象方法"></a>5.1. 定义抽象方法</h3><p>当使用MyBatis框架处理增删改查时，抽象方法必须定义在接口中，通常，接口的名称建议使用<code>Mapper</code>作为最后一个单词。</p><p>在<code>cn.tedu.mybatis</code>包中创建<code>UserMapper</code>接口，这个接口就专门用于声明访问“用户”数据表中的数据：</p><pre><code class="java">public interface UserMapper {}</code></pre><p>然后，在接口中声明“插入用户数据”的抽象方法，关于抽象方法的声明：</p><ul><li>【返回值】如果需要执行的数据操作是增、删、改类型的，则使用<code>Integer</code>作为返回值类型，表示受影响的行数，其实，也可以使用<code>void</code>作为返回值类型，表示“不关心受影响的行数”，但是，不建议这么做；如果需要执行的数据操作是查询，则设计为所期望的类型即可，当然，该类型需要能够将查询到的数据封装进去；</li><li>【方法名称】自定义；</li><li>【参数列表】根据需要执行的SQL语句中的参数来决定。</li></ul><p>当需要执行“插入用户数据”操作时，需要执行的SQL语句大致是：</p><pre><code class="mysql">INSERT INTO t_user (username, password, age, phone, email) VALUES (?,?,?,?,?)</code></pre><p>可以将以上SQL语句中的参数全部声明到抽象方法的参数列表中，例如：</p><pre><code class="java">Integer insert(String username, String password, Integer age, String phone, String email);</code></pre><p>或者，也可以将SQL语句中的参数全部声明到某个实体类，然后使用实体类作为抽象方法的参数，例如在<code>cn.tedu.mybatis</code>包下创建<code>User</code>类：</p><pre><code class="java">package cn.tedu.mybatis;public class User {    private Integer id;    private String username;    private String password;    private Integer age;    private String phone;    private String email;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    public String getPhone() {        return phone;    }    public void setPhone(String phone) {        this.phone = phone;    }    public String getEmail() {        return email;    }    public void setEmail(String email) {        this.email = email;    }    @Override    public String toString() {        return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, password=&quot; + password + &quot;, age=&quot; + age + &quot;, phone=&quot;                + phone + &quot;, email=&quot; + email + &quot;]&quot;;    }}</code></pre><p>然后，设计抽象方法为：</p><pre><code class="java">Integer insert(User user);</code></pre><p>目前，MyBatis框架并不知道接口文件的位置，就更加无法使用自定义的抽象方法，必须在配置类的声明之前添加<code>@MapperScan</code>注解，以指定接口文件所在的包！</p><h3 id="5-2-配置SQL语句"><a href="#5-2-配置SQL语句" class="headerlink" title="5.2. 配置SQL语句"></a>5.2. 配置SQL语句</h3><p>在接口的抽象方法的声明之前，根据需要执行的SQL语句的种类，选择使用<code>@Insert</code> / <code>@Delete</code> / <code>@Update</code> / <code>@Select</code>这4个当中的某个注解，当前已经添加的抽象方法<code>Integer insert(User user);</code>需要执行的是<code>INSERT</code>类型的SQL语句，则需要使用<code>@Insert</code>注解！</p><p>然后，在注解中，配置字符串类型的参数，该参数就是需要执行的SQL语句，在SQL语句中，所有的参数都使用<code>#{}</code>格式的占位符，在占位符的大括号内是参数<code>User</code>类的属性名：</p><pre><code class="java">@Insert(&quot;INSERT INTO t_user (username, password, age, phone, email) VALUES (#{username}, #{password}, #{age}, #{phone}, #{email})&quot;)Integer insert(User user);</code></pre><p>最后，还需要在配置类中配置<code>SqlSessionFactoryBean</code>的对象，为该对象设置数据源，使得MyBatis框架能够自动获取数据库连接，并完成数据访问！所以，在<code>SpringConfig</code>类中添加：</p><pre><code class="java">@Beanpublic SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) {    SqlSessionFactoryBean bean = new SqlSessionFactoryBean();    bean.setDataSource(dataSource);    return bean;}</code></pre><p>最后，在<strong>src/test/java</strong>的<code>cn.tedu.mybatis</code>包下创建<code>UserMapperTests</code>测试类，并测试以上方法：</p><pre><code class="java">package cn.tedu.mybatis;import org.junit.Test;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class UserMapperTests {    @Test    public void insert() {        AnnotationConfigApplicationContext ac            = new AnnotationConfigApplicationContext(SpringConfig.class);        UserMapper userMapper             = ac.getBean(&quot;userMapper&quot;, UserMapper.class);        User user = new User();        user.setUsername(&quot;spring&quot;);        user.setPassword(&quot;1234&quot;);        user.setAge(26);        user.setPhone(&quot;1380138000&quot;);        user.setEmail(&quot;root@baidu.com&quot;);        Integer rows = userMapper.insert(user);        System.out.println(&quot;rows=&quot; + rows);        ac.close();    }}</code></pre><h3 id="5-3-获取自动编号的ID值"><a href="#5-3-获取自动编号的ID值" class="headerlink" title="5.3. 获取自动编号的ID值"></a>5.3. 获取自动编号的ID值</h3><p>在抽象方法的上方，补充添加<code>@Options</code>注解并进行配置，使得可以获取自动编号的ID值，例如：</p><pre><code class="java">@Insert(&quot;INSERT INTO t_user (username, password, age, phone, email) VALUES (#{username}, #{password}, #{age}, #{phone}, #{email})&quot;)@Options(useGeneratedKeys=true, keyProperty=&quot;id&quot;)Integer insert(User user);</code></pre><p>以上在<code>@Options</code>注解中，配置的<code>useGeneratedKeys=true</code>表示“需要获取自动生成的值”，<code>keyProperty</code>表示将获取到的ID值放到参数对象的<code>id</code>属性中去！</p><h2 id="6-根据id删除用户数据"><a href="#6-根据id删除用户数据" class="headerlink" title="6. 根据id删除用户数据"></a>6. 根据id删除用户数据</h2><p>需要执行的SQL语句大致是：</p><pre><code class="mysql">DELETE FROM t_user WHERE id=?</code></pre><p>先在<code>UserMapper</code>接口中添加抽象方法：</p><pre><code class="java">Integer deleteById(Integer id);</code></pre><p>然后，在抽象方法的声明之前添加<code>@Delete</code>注解来配置SQL语句：</p><pre><code class="java">@Delete(&quot;DELETE FROM t_user WHERE id=#{id}&quot;)</code></pre><p>最后，编写并执行单元测试：</p><pre><code class="java">@Testpublic void deleteById() {    AnnotationConfigApplicationContext ac        = new AnnotationConfigApplicationContext(SpringConfig.class);    UserMapper userMapper         = ac.getBean(&quot;userMapper&quot;, UserMapper.class);    Integer id = 1;    Integer rows = userMapper.deleteById(id);    System.out.println(&quot;rows=&quot; + rows);    ac.close();}</code></pre><h2 id="7-将所有用户的密码全部改为某个值"><a href="#7-将所有用户的密码全部改为某个值" class="headerlink" title="7. 将所有用户的密码全部改为某个值"></a>7. 将所有用户的密码全部改为某个值</h2><p>需要执行的SQL语句大致是：</p><pre><code class="mysql">UPDATE t_user SET password=?</code></pre><p>先在<code>UserMapper</code>接口中添加抽象方法：</p><pre><code class="java">Integer updatePassword(String password);</code></pre><p>然后，在抽象方法的声明之前添加<code>@Update</code>注解来配置SQL语句：</p><pre><code class="java">@Update(&quot;UPDATE t_user SET password=#{password}&quot;)</code></pre><p>最后，编写并执行单元测试：</p><pre><code class="java">private UserMapper userMapper;private AnnotationConfigApplicationContext ac;@Beforepublic void doBefore() {    ac = new AnnotationConfigApplicationContext(SpringConfig.class);    userMapper = ac.getBean(&quot;userMapper&quot;, UserMapper.class);}@Afterpublic void doAfter() {    ac.close();}@Testpublic void updatePassword() {    String password = &quot;88888888&quot;;    Integer rows = userMapper.updatePassword(password);    System.out.println(&quot;rows=&quot; + rows);}</code></pre><p>注意：当单元测试经过以上调整后，每个测试方法中都不用再执行<code>doBefore()</code>和<code>doAfter()</code>方法中的代码了，在每次执行<code>@Test</code>注解的测试方法之前，都会自动调用<code>@Before</code>注解的方法，并且，在执行<code>@Test</code>注解的测试方法之后，还会自动调用<code>@After</code>注解的方法！</p><h2 id="8-统计当前用户表中用户的数量"><a href="#8-统计当前用户表中用户的数量" class="headerlink" title="8. 统计当前用户表中用户的数量"></a>8. 统计当前用户表中用户的数量</h2><pre><code class="java">@Select(&quot;SELECT COUNT(*) FROM t_user&quot;)Integer count();</code></pre><h2 id="9-根据id查询某用户的详情"><a href="#9-根据id查询某用户的详情" class="headerlink" title="9. 根据id查询某用户的详情"></a>9. 根据id查询某用户的详情</h2><pre><code class="java">@Select(&quot;SELECT * FROM t_user WHERE id=#{id}&quot;)User findById(Integer id);</code></pre><p>注意：当查询某1条数据，且没有匹配的查询结果时，将返回<code>null</code>。</p><h2 id="10-查询所有用户的信息"><a href="#10-查询所有用户的信息" class="headerlink" title="10. 查询所有用户的信息"></a>10. 查询所有用户的信息</h2><pre><code class="java">@Select(&quot;SELECT * FROM t_user ORDER BY id&quot;)List&lt;User&gt; findAll();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exception和Error有什么区别（转）</title>
      <link href="/2020/07/06/2020-07-06-Exception%E5%92%8CError%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
      <url>/2020/07/06/2020-07-06-Exception%E5%92%8CError%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p><p>Exception和Error体现了JAVA这门语言对于异常处理的两种方式。</p><p>Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。</p><p>Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。</p><p>其中的Exception又分为检查性异常和非检查性异常。两个根本的区别在于，检查性异常 必须在编写代码时，使用try catch捕获（比如：IOException异常）。非检查性异常 在代码编写使，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。 切记，Error是Throw不是Exception 。</p><p>其中有一个比较经典的面试题目， 就是 NoClassDefFoundError 和 ClassNotFoundException 有什么区别</p><pre><code>区别一： NoClassDefFoundError它是Error，ClassNotFoundException是Exception。区别二：还有一个区别在于NoClassDefFoundError是JVM运行时通过classpath加载类时，找不到对应的类而抛出的错误。ClassNotFoundException是在编译过程中如果可能出现此异常，在编译过程中必须将ClassNotFoundException异常抛出！NoClassDefFoundError发生场景如下：    1、类依赖的class或者jar不存在 （简单说就是maven生成运行包后被篡改）    2、类文件存在，但是存在不同的域中 （简单说就是引入的类不在对应的包下)    3、大小写问题，javac编译的时候是无视大小的，很有可能你编译出来的class文件就与想要的不一样！这个没有做验证    ClassNotFoundException发生场景如下：    1、调用class的forName方法时，找不到指定的类    2、ClassLoader 中的 findSystemClass() 方法时，找不到指定的类举例说明如下:    Class.forName(&quot;abc&quot;); 比如abc这个类不存项目中，代码编写时，就会提示此异常是检查性异常，比如将此异常抛出。</code></pre><p>第二，理解 Java 语言中操作 Throwable 的元素和实践。掌握最基本的语法是必须的，如 try-catch-finally 块，throw、throws 关键字等。与此同时，也要懂得如何处理典型场景。</p><p>throw是存在于方法的代码块中，而throws是存在于方法外围，一般是在方法名后边 throws XXXException;</p><p>有个重要的点需要记住， 就是try-catch-finally中rerun的执行顺序问题</p><pre><code>try{    retrun 3;}catch{    e.printStackTrace();}finally{    return 4;}//上边情况下，实际返回的是4；try{    int x = 3;    retrun x;}catch{    e.printStackTrace();}finally{    x++;}//上边情况下，实际返回的3；</code></pre><p>这是为什么呢？ 因为finally的业务操作是在try业务操作的return返回调用者者之前执行。按照刚才第一种情况，实际情况是，执行完try中的业务逻辑就，return返回的操作会先存储到一个临时的堆栈中，此时不给调用者返回，随后执行finally中的业务代码。如果finally中有return操作，那么就会把finally中的return值与try中的return值进行替换。随后将最终数据返回给调用者。</p><p><strong>知识扩展</strong></p><p>前面谈的大多是概念性的东西，下面我来谈些实践中的选择，我会结合一些代码用例进行分析。</p><p>先开看第一个吧，下面的代码反映了异常处理中哪些不当之处？</p><pre><code>try {  // 业务代码  // …  Thread.sleep(1000L);} catch (Exception e) {  // Ignore it}</code></pre><blockquote><p>这段代码虽然很短，但是已经违反了异常处理的两个基本原则。</p></blockquote><p>第一，<strong>尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常</strong>，在这里是 Thread.sleep() 抛出的 InterruptedException。</p><p>这是因为在日常的开发和合作中，我们读代码的机会往往超过写代码，软件工程是门协作的艺术，所以我们有义务让自己的代码能够直观地体现出尽量多的信息，而泛泛的 Exception 之类，恰恰隐藏了我们的目的。另外，我们也要保证程序不会捕获到我们不希望捕获的异常。比如，你可能更希望 RuntimeException 被扩散出来，而不是被捕获。</p><p>进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确程序处理 OutOfMemoryError。</p><p>第二，<strong>不要生吞（swallow）异常</strong>。这是异常处理中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况。</p><p>生吞异常，往往是基于假设这段代码可能不会发生，或者感觉忽略异常是无所谓的，但是千万不要在产品代码做这种假设！</p><p>如果我们不把异常抛出来，或者也没有输出到日志（Logger）之类，程序可能在后续代码以不可控的方式结束。没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。</p><p>再来看看第二段代码</p><pre><code>try {   // 业务代码   // …} catch (IOException e) {    e.printStackTrace();}</code></pre><p>这段代码作为一段实验代码，它是没有任何问题的，但是在产品代码中，通常都不允许这样处理。你先思考一下这是为什么呢？</p><blockquote><p>这样的代码在代码规范中是没有问题的，他的问题出在，异常中的异常日志如何输出的问题。按照上边的输出，如果实在复杂的系统中，会判断不出来，异常具体在哪里打印出来的。<br>尤其是对于分布式系统，如果发生异常，但是无法找到堆栈轨迹（stacktrace），这纯属是为诊断设置障碍。所以，最好使用产品日志，详细地输出到日志系统里</p></blockquote><p>  还有一种处理方式，可自定义异常，将业务异常转换为业务术语，但是抛出异常时，必须把异常的cause信息打印出，方便跟踪问题，在最短的时间内，解决问题。但是需要考虑两点</p><p>自定异常时，需要考虑自定义异常是否为检查性异常，因为这种类型设计的初衷更是为了从异常情况恢复，作为异常设计者，我们往往有充足信息进行分类。</p><p>在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。如果我们看 Java 的标准类库，你可能注意到类似 java.net.ConnectException，出错信息是类似“ Connection refused (Connection refused)”，而不包含具体的机器名、IP、端口等，一个重要考量就是信息安全。类似的情况在日志中也有，比如，用户数据一般是不可以输出到日志里面的。</p><blockquote><p>对于异常中的检查性异常，我们简单的说一下。目前检查性异常被业界说是java的一种设计缺陷。有一下几点可以参考一下</p></blockquote><p> Checked Exception 的假设是我们捕获了异常，然后恢复程序。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception 的使用，已经大大偏离了最初的设计目的。<br> 当然，很多人也觉得没有必要矫枉过正，因为确实有一些异常，比如和环境相关的 IO、网络等，其实是存在可恢复性的，而且 Java 已经通过业界的海量实践，证明了其构建高质量软件的能力。</p><blockquote><p>我们从性能角度来审视一下 Java 的异常处理机制，这里有两个可能会相对昂贵的地方：</p></blockquote><ol><li>try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</li><li>java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。</li></ol><p>原文地址</p><p><a href="https://blog.csdn.net/weixin_42124070/article/details/80833629">https://blog.csdn.net/weixin_42124070/article/details/80833629</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Exception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC03</title>
      <link href="/2020/07/06/08_SPRINGMVC_DAY03/"/>
      <url>/2020/07/06/08_SPRINGMVC_DAY03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-关于-RequestMapping注解"><a href="#1-关于-RequestMapping注解" class="headerlink" title="1. 关于@RequestMapping注解"></a>1. 关于@RequestMapping注解</h2><p>在控制器中，在处理请求的方法之前添加<code>@RequestMapping</code>注解，可以配置请求路径与处理请求的方法的映射关系！</p><p>在<code>@RequestMapping</code>注解的源代码中有：</p><pre><code class="java">/** * The primary mapping expressed by this annotation. * &lt;p&gt;This is an alias for {@link #path}. For example, * {@code @RequestMapping(&quot;/foo&quot;)} is equivalent to * {@code @RequestMapping(path=&quot;/foo&quot;)}. * &lt;p&gt;&lt;b&gt;Supported at the type level as well as at the method level!&lt;/b&gt; * When used at the type level, all method-level mappings inherit * this primary mapping, narrowing it for a specific handler method. * &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: A handler method that is not mapped to any path * explicitly is effectively mapped to an empty path. */@AliasFor(&quot;path&quot;)String[] value() default {};</code></pre><p>由于<code>value</code>是默认的属性，所以，平时所使用到的<code>@RequestMapping(&quot;reg.do&quot;)</code>其实配置的就是这个<code>value</code>属性的值！</p><p>它的数据类型是<code>String[]</code>，所以，在配置时，可以同时配置多个路径！例如：</p><pre><code class="java">// 【显示注册页面】@RequestMapping({&quot;reg.do&quot;, &quot;register.do&quot;})public String reg() {    System.out.println(&quot;UserController.reg()&quot;);    return &quot;register&quot;;}</code></pre><p>则通过<code>reg.do</code>和<code>register.do</code>均可使得<code>reg()</code>方法被执行，而方法的代码是不变的，最终的效果就是这2个路径都可以打开同一个页面！</p><p>在源代码中，还有：</p><pre><code class="java">/** * The path mapping URIs (e.g. {@code &quot;/profile&quot;}). * &lt;p&gt;Ant-style path patterns are also supported (e.g. {@code &quot;/profile/**&quot;}). * At the method level, relative paths (e.g. {@code &quot;edit&quot;}) are supported * within the primary mapping expressed at the type level. * Path mapping URIs may contain placeholders (e.g. &lt;code&gt;&quot;/${profile_path}&quot;&lt;/code&gt;). * &lt;p&gt;&lt;b&gt;Supported at the type level as well as at the method level!&lt;/b&gt; * When used at the type level, all method-level mappings inherit * this primary mapping, narrowing it for a specific handler method. * &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: A handler method that is not mapped to any path * explicitly is effectively mapped to an empty path. * @since 4.2 */@AliasFor(&quot;value&quot;)String[] path() default {};</code></pre><p>结合以上2段源代码，可以看到<code>value</code>属性与<code>path</code>属性是完全相同的！如果需要显式的指定属性名称时，使用<code>path</code>可以更好的表现语义，该属性名称是从4.2版本加入的！</p><p>在源代码还有：</p><pre><code class="java">/** * The HTTP request methods to map to, narrowing the primary mapping: * GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE. * &lt;p&gt;&lt;b&gt;Supported at the type level as well as at the method level!&lt;/b&gt; * When used at the type level, all method-level mappings inherit * this HTTP method restriction (i.e. the type-level restriction * gets checked before the handler method is even resolved). */RequestMethod[] method() default {};</code></pre><p>以上源代码说明在使用<code>@RequestMapping</code>时，可以配置名为<code>method</code>的属性，该属性的值的类型是<code>RequestMethod[]</code>类型，默认值是无。</p><p>该属性的作用是“配置所映射的HTTP请求方式”，如果没有配置该属性，表示“可以通过任何请求方式访问该路径”！如果显式的配置了该属性，则只有配置值对应的请求方式才是允许的，而没有被配置值的请求方式将不被允许！</p><p>例如，将请求方式限制为POST类型：</p><pre><code class="java">@RequestMapping(value=&quot;handle_reg.do&quot;, method=RequestMethod.POST)</code></pre><p>如果仍尝试使用GET或其它不被允许的请求方式，将会出现405错误：</p><pre><code>HTTP Status 405 – Method Not Allowed</code></pre><p>并且，还伴随具体的提示信息：</p><pre><code>Request method &#39;GET&#39; not supported</code></pre><p>由于<code>method</code>属性的值类型是<code>RequestMethod[]</code>，所以，可以设置为允许多种请求方式，例如：</p><pre><code class="java">@RequestMapping(path=&quot;login.do&quot;, method={RequestMethod.GET, RequestMethod.POST})</code></pre><p>如果需要将请求方式限制为固定的某1种，还可以使用简化后的注解！例如使用<code>@PostMapping</code>注解，就可以将请求方式限制为<code>POST</code>类型，在使用时，只需要配置请求路径即可，例如：</p><pre><code class="java">// @RequestMapping(value=&quot;handle_reg.do&quot;, method=RequestMethod.POST)@PostMapping(&quot;handle_reg.do&quot;)</code></pre><p>在<code>@PostMapping</code>注解的源代码中，关于该注解的声明是：</p><pre><code class="java">@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documented@RequestMapping(method = RequestMethod.POST)public @interface PostMapping {}</code></pre><p>在该注解的声明之前添加了<code>@RequestMapping(method = RequestMethod.POST)</code>就表示当前<code>@PostMapping</code>注解具有<code>@RequestMapping</code>的作用特点且已经将请求方式限制为<code>POST</code>了！</p><p>除此以外，还有<code>@GetMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>、<code>@PatchMapping</code>，均对应某1种请求方式！</p><p><strong>小结：如果需要将请求方式限制为某1种，则应该使用以上这些简化的注解，如果需要同时允许多种不同的请求方式，应该使用<code>@RequestMapping</code>！</strong></p><p>关于<code>@RequestMapping</code>注解，除了添加在处理请求的方法之前，还可以添加在控制器类的声明之前！例如：</p><pre><code class="java">@Controller@RequestMapping(&quot;user&quot;)public class UserController {}</code></pre><p>当控制器类的声明之前配置了<code>@RequestMapping(&quot;user&quot;)</code>后，当前类中映射的所有请求路径中都需要添加<code>user</code>这个层级，例如，在没有添加该配置之前时，访问路径是：</p><pre><code>http://localhost:8080/springmvc02/reg.dohttp://localhost:8080/springmvc02/login.do</code></pre><p>添加了配置之后，访问路径是：</p><pre><code>http://localhost:8080/springmvc02/user/reg.dohttp://localhost:8080/springmvc02/user/login.do</code></pre><p><strong>通常，推荐为每一个控制器类的声明之前都添加该注解的配置！</strong></p><p>可以看到 ，SpringMVC框架在处理配置的路径时，会把类之前的<code>@RequestMapping</code>配置值与方法之前的配置值拼接起来作为完整的访问路径，但是，开发人员并不需要考虑配置值的左右两侧的<code>/</code>符号，例如以下配置是等效的：</p><table><thead><tr><th>在控制器类之前的配置</th><th>在方法之前的配置</th></tr></thead><tbody><tr><td><strong>user</strong></td><td><strong>reg.do</strong></td></tr><tr><td>user</td><td>/reg.do</td></tr><tr><td>user/</td><td>reg.do</td></tr><tr><td>user/</td><td>/reg.do</td></tr><tr><td>/user</td><td>reg.do</td></tr><tr><td>/user</td><td>/reg.do</td></tr><tr><td>/user/</td><td>reg.do</td></tr><tr><td>/user/</td><td>/reg.do</td></tr></tbody></table><p>在实际使用时，推荐使用第1种即可！如果使用其它的配置风格也是可以的，但是，在同一个项目中，应该只使用1种风格的配置！</p><h2 id="2-拦截器"><a href="#2-拦截器" class="headerlink" title="2. 拦截器"></a>2. 拦截器</h2><p>拦截器（<code>Interceptor</code>）在SpringMVC框架中可以作用于若干个不同的请求，且经过拦截器的处理后，可以选择对这些请求进行阻止（不允许继续向后续的流程中执行），或选择放行！</p><blockquote><p>注意：拦截器的作用并不一定是”拦“下来就不允许执行了，可能某些拦截器的做法就是”拦“下来后全部放行！</p></blockquote><p>当需要要使用拦截器时，首先，需要自定义类，实现<code>HandlerInterceptor</code>接口，并在重写的方法中添加输出语句，以便于观察方法的执行时间点及执行的先后顺序：</p><pre><code class="java">package cn.tedu.spring;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;public class LoginInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception {        System.out.println(&quot;LoginInterceptor.preHandle()&quot;);        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,            ModelAndView modelAndView) throws Exception {        System.out.println(&quot;LoginInterceptor.postHandle()&quot;);    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)            throws Exception {        System.out.println(&quot;LoginInterceptor.afterCompletion()&quot;);    }}</code></pre><p>然后，还需要对拦截器进行配置，关于该配置的写法要求：</p><ul><li>相关的配置需要写在某个类中，这个类需要实现<code>WebMvcConfigurer</code>接口，且在类的声明之前必须添加<code>@Configuration</code>和<code>@EnableWebMvc</code>这2个注解，且这个类的对象必须是初始化类的<code>getServletConfigClasses()</code>方法的返回值；</li><li>在以上类中重写<code>addInterceptors()</code>方法，以配置拦截器。</li></ul><p>例如使用原本存在的<code>SpringMvcConfig</code>为作配置类：</p><pre><code class="java">package cn.tedu.spring;@EnableWebMvc@Configuration@ComponentScan(&quot;cn.tedu.spring&quot;)public class SpringMvcConfig implements WebMvcConfigurer {    private String characterEncoding = &quot;utf-8&quot;;    @Bean    public ViewResolver viewResolver() {        // 省略    }    @Override    public void addInterceptors(InterceptorRegistry registry) {        HandlerInterceptor interceptor = new LoginInterceptor();        // 注意：表示拦截器处理的路径时，各路径必须使用 / 作为第1个字符        registry.addInterceptor(interceptor).addPathPatterns(&quot;/index.do&quot;);    }}</code></pre><p>在一个项目中，允许同时存在若干个拦截器，配置的先后顺序决定了执行顺序，如果某个请求会经过多个拦截器，只有这些拦截器全部都放行，才可以继续向后执行，只要其中任何一个拦截器的处理结果是阻止运行，该请求就不可以向后执行了！</p><p>通过运行效果可以观察到：</p><ul><li>当拦截器中的<code>preHandle()</code>方法返回<code>true</code>时，会行执行拦截器中的<code>preHandle()</code>方法，再执行需要请求的控制器中的方法，再执行拦截器中的<code>postHandle()</code>和<code>afterCompletion()</code>方法；</li><li>当拦截器中的<code>preHandle()</code>方法返回<code>false</code>时，只会执行拦截器中的<code>preHandle()</code>方法，且客户端的浏览器窗口将显示一片空白。</li><li>只有拦截器中的<code>preHandle()</code>方法才是真正意义上的”拦截“方法！</li></ul><p>回到<code>LoginInterceptor</code>类中，重写<code>preHandle()</code>方法以判断阻止或放行：</p><pre><code class="java">@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {    System.out.println(&quot;LoginInterceptor.preHandle()&quot;);    // 如果已经登录，则放行，如果未登录，则阻止且重定向到登录界面    HttpSession session = request.getSession();    if (session.getAttribute(&quot;username&quot;) == null) {        String contextPath = request.getContextPath();        response.sendRedirect(contextPath + &quot;/user/login.do&quot;);        return false;    }    return true;}</code></pre><p>关于拦截器的配置，首先，每个拦截器都可以配置若干个拦截的路径！关于配置拦截路径时调用的<code>addPathPatterns()</code>方法，其源代码是：</p><pre><code class="java">/** * Add URL patterns to which the registered interceptor should apply to. */public InterceptorRegistration addPathPatterns(String... patterns) {    return addPathPatterns(Arrays.asList(patterns));}/** * List-based variant of {@link #addPathPatterns(String...)}. * @since 5.0.3 */public InterceptorRegistration addPathPatterns(List&lt;String&gt; patterns) {    this.includePatterns.addAll(patterns);    return this;}</code></pre><p>实际使用时，可以写成例如：</p><pre><code class="java">registry.addInterceptor(interceptor).addPathPatterns(&quot;/index.do&quot;, &quot;/user/password.do&quot;);</code></pre><p>或者写成：</p><pre><code class="java">List&lt;String&gt; pathPatterns = new ArrayList&lt;&gt;();pathPatterns.add(&quot;/index.do&quot;);pathPatterns.add(&quot;/user/password.do&quot;);registry.addInterceptor(interceptor).addPathPatterns(pathPatterns);</code></pre><p>在配置路径时，还可以使用星号(<code>*</code>)作为通配符，例如，可以将<code>/blog/*</code>配置到拦截路径中，则<code>/blog/delete.do</code>、<code>/blog/edit.do</code>等路径都可以被匹配！</p><p>但是，需要注意的是：1个星号(<code>*</code>)只能表示某层级下的资源，不可以匹配到若干个层级！例如配置为<code>/blog/*</code>时，就无法匹配到<code>/blog/2020/list.do</code>！如果一定匹配若干个层级，必须使用2个连续的星号(<code>**</code>)，例如配置为<code>/blog/**</code>，则可以匹配到<code>/blog/list.do</code>、<code>/blog/2020/list.do</code>、<code>/blog/2020/07/list.do</code>……</p><p>在注册拦截器之后，还可以调用<code>excludePathPatterns()</code>方法添加”排除“的路径，被”排除“的路径将不会被拦截器处理！所以，也可以理解为”例外“或”白名单“，例如：</p><pre><code class="java">List&lt;String&gt; pathPatterns = new ArrayList&lt;&gt;();pathPatterns.add(&quot;/user/reg.do&quot;);pathPatterns.add(&quot;/user/handle_reg.do&quot;);pathPatterns.add(&quot;/user/login.do&quot;);pathPatterns.add(&quot;/user/handle_login.do&quot;);registry.addInterceptor(interceptor)    .addPathPatterns(&quot;/user/**&quot;)    .excludePathPatterns(pathPatterns);</code></pre><p>注意：在调用方法时，必须先调用<code>addPathPatterns()</code>方法然后再调用<code>excludePathPatterns()</code>方法！</p><h2 id="3-拦截器与过滤器的区别"><a href="#3-拦截器与过滤器的区别" class="headerlink" title="3. 拦截器与过滤器的区别"></a>3. 拦截器与过滤器的区别</h2><p><strong>【相同/相似】</strong></p><p>拦截器与过滤器都是可以作用于若干个不同的请求的，在处理请求之前将执行拦截器或过滤器中的代码，并且，都能够实现放行或阻止的效果，并且，都有”链“的概念，在同一个项目中允许存在若干个拦截器或过滤器，同一个请求需要经历多个拦截器或过滤器，只有这些拦截器或过滤器全部放行，才能向后执行！</p><p><strong>【区别】</strong></p><ul><li>过滤器Filter是Java EE中的组件，则任何Java EE项目都可以使用过滤器，而拦截器Interceptor是SpringMVC框架中的组件，只有使用了SpringMVC框架的Java EE项目才可以使用拦截器，并且，只有被SpringMVC框架处理的请求才可能被拦截器处理，例如将SpringMVC框架处理的路径设置为<code>*.do</code>时，直接访问HTML页面、图片等资源将不会被拦截器处理；</li><li>过滤器Filter是执行在所有Servlet组件之前的，而拦截器Interceptor的第1次执行是在<code>DispatcherServlet</code>之后，且在Controller组件之前的（当然，使用过滤器时，也许是通过Servlet来处理请求的，使用拦截器时，是通过Controller来处理请求的，所以，这2者都是在处理请求之前执行，所以，一般情况下，差异并不明显）；</li><li>过滤器Filter只能配置过滤路径（黑名单），而拦截器Interceptor既可以配置拦截路径（黑名单），又可以配置排除路径（例外，白名单），后者的配置更加灵活！</li></ul><p><strong>【小结】</strong></p><p>通过分析以上区别，可以发现：通过过滤器Filter实现的效果，改为使用拦截器Interceptor基本上都可以实现！同时，拦截器还具备”配置更加灵活“的特点，所以，在绝大部分情况下，应该优先使用拦截器！</p><p>当然，过滤器也具有拦截器无法取代的特点，就是”执行时间点“非常早，它是执行在所有Servlet组件之前的，所以，如果某个需要被”拦“下来执行的任务是非常早期就要执行，则必须使用过滤器！</p><p>例如，SpringMVC框架默认使用的编码是<code>ISO-8859-1</code>，是不支持中文的，所以，使用<code>POST</code>提交的请求参数中，只要存在非ASCII码字符，就会出现乱码，如果需要自定义编码，需要在项目的初始化类中重写<code>getServletFilters()</code>方法，并在该方法中返回SpringMVC框架自带的字符编码过滤器，且设置编码，例如：</p><pre><code class="java">@Overrideprotected Filter[] getServletFilters() {    return new Filter[] { new CharacterEncodingFilter(&quot;UTF-8&quot;) };}</code></pre><h2 id="4-SpringMVC阶段小结"><a href="#4-SpringMVC阶段小结" class="headerlink" title="4. SpringMVC阶段小结"></a>4. SpringMVC阶段小结</h2><ul><li>【理解】SpringMVC框架的作用：解决V-C交互的问题；</li><li>【理解】SpringMVC框架的核心执行流程图；</li><li>【掌握】通过SpringMVC框架接收并处理客户端的请求：<ul><li>SpringMVC项目的搭建：添加<code>spring-webmvc</code>依赖，配置不使用<strong>web.xml</strong>，添加Tomcat环境，创建SpringMVC的配置类，创建初始化项目的类并加载SpringMVC的配置类、设置SpringMVC框架所处理的请求路径；</li><li>创建控制器类：自定义名称，必须放在组件扫描的包或其子孙包中，必须添加<code>@Controller</code>注解；</li><li>创建处理请求的方法：使用<code>@RequestMapping</code>系列注解配置请求路径，使用<code>public</code>访问权限，暂定使用<code>String</code>作为返回值类型，方法名称可以自定义，方法的参数列表可以按需设计。</li></ul></li><li>【掌握】通过SpringMVC框架接收客户端提交的请求参数：<ul><li>将请求参数逐一声明为处理请求的方法的参数；</li><li>将多个请求参数封装到自定义对象中，并将自定义的数据类型声明为处理请求的方法的参数。</li></ul></li><li>【掌握】使用SpringMVC封装转发的数据到视图组件，并且在视图组件显示转发的数据；</li><li>【理解】转发与重定向的区别；</li><li>【掌握】Session的使用原则与使用方式；</li><li>【掌握】拦截器的使用与配置；</li><li>【理解】拦截器与过滤器的区别；</li><li>【掌握】解决POST请求中文乱码的问题；</li><li>【掌握】阅读简单的注解源代码，例如<code>@RequestMapping</code>、<code>@RequestParam</code>等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat中配置去掉项目名</title>
      <link href="/2020/07/06/tomcat%E5%8E%BB%E6%8E%89%E9%A1%B9%E7%9B%AE%E5%90%8D/"/>
      <url>/2020/07/06/tomcat%E5%8E%BB%E6%8E%89%E9%A1%B9%E7%9B%AE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>负载均衡中war放在tomcat中时，访问会带有包名。</p><h5 id="打开tomcat-conf-server-xml-把"><a href="#打开tomcat-conf-server-xml-把" class="headerlink" title="打开tomcat/conf/server.xml,把"></a>打开tomcat/conf/server.xml,把</h5><pre><code>&lt;Context path=&quot;/&quot; docBase=&quot;/usr/local/tomcat/tomcat-8102/webapps/blog/&quot; reloadable=&quot;true&quot; /&gt;</code></pre><p>添加到<code>&lt;Host&gt;&lt;/Host&gt;</code>标签中。</p><p>路径最后一定要加<code>/</code>,刚开始没加居然也可以，但后面又不行，又直接访问到🐱页面去了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/04/hello-world/"/>
      <url>/2020/07/04/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC01</title>
      <link href="/2020/07/04/08_SPRINGMVC_DAY01/"/>
      <url>/2020/07/04/08_SPRINGMVC_DAY01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-SpringMVC框架的作用"><a href="#1-SpringMVC框架的作用" class="headerlink" title="1. SpringMVC框架的作用"></a>1. SpringMVC框架的作用</h2><p><strong>MVC</strong> = <strong>M</strong>odel（数据模型） + <strong>V</strong>iew（视图） + <strong>C</strong>ontroller（控制器）</p><p>SpringMVC框架主要解决了接收请求与处理响应的问题，也可以认为是解决了V-C交互的问题，与M其实没有关系。</p><p>在传统的Java EE的开发模式下，可能存在<code>Servlet</code>组件数量太多的问题，会导致项目的管理难度太大，且运行时，会有大量的<code>Servlet</code>对象长期占用内存的问题！</p><p>另外，传统的Java EE开发模式下，数据的处理过程中代码量相对较大，而SpringMVC非常大极度的简化了开发量！</p><h2 id="2-SpringMVC-HelloWorld"><a href="#2-SpringMVC-HelloWorld" class="headerlink" title="2. SpringMVC HelloWorld"></a>2. SpringMVC HelloWorld</h2><h4 id="2-1-案例目标"><a href="#2-1-案例目标" class="headerlink" title="2.1. 案例目标"></a>2.1. 案例目标</h4><p>最终程序运行后，打开浏览器，输入<code>http://localhost:8080/项目名/hello.do</code>即可看到自定义输出的内容。</p><h4 id="2-2-在Eclipse中添加Server"><a href="#2-2-在Eclipse中添加Server" class="headerlink" title="2.2. 在Eclipse中添加Server"></a>2.2. 在Eclipse中添加Server</h4><p>打开Eclipse的<strong>Servers</strong>面板，添加Tomcat，当添加成功后，在Eclipse的项目列表中，会出现<strong>Servers</strong>项目，在需要使用Tomcat时，必须保证该项目是存在且打开的状态。</p><h4 id="2-3-创建项目"><a href="#2-3-创建项目" class="headerlink" title="2.3. 创建项目"></a>2.3. 创建项目</h4><p>创建<strong>Maven Project</strong>，<strong>Group Id</strong>为<code>cn.tedu</code>，<strong>Artifact Id</strong>为<code>springmvc01</code>，<strong>Packaing</strong>必须选择<code>war</code>。</p><p>当项目创建出来后，对项目名称点右键，在项目属性的<strong>Targeted Runtimes</strong>中勾选Tomcat。</p><p>刚刚创建好的项目的<strong>pom.xml</strong>会报错，因为缺少<strong>web.xml</strong>文件，并且<code>&lt;failOnMissingWebXml&gt;</code>节点默认为<code>true</code>，结合指定Java版本的代码，在<strong>pom.xml</strong>中添加：</p><pre><code class="xml">&lt;properties&gt;    &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;/properties&gt;</code></pre><p>然后，还需要在<strong>pom.xml</strong>中添加<code>spring-webmvc</code>的依赖：</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4 id="2-4-创建初始化类"><a href="#2-4-创建初始化类" class="headerlink" title="2.4. 创建初始化类"></a>2.4. 创建初始化类</h4><p>创建<code>cn.tedu.spring</code>包，在这个包中创建<code>SpringMvcConfig</code>配置类，并在这个类上配置组件扫描：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.context.annotation.ComponentScan;/** * SpringMvc的配置类 */@ComponentScan(&quot;cn.tedu.spring&quot;)public class SpringMvcConfig {}</code></pre><p>在这个包中创建<code>SpringMvcInitializer</code>类，作为整个项目的初始化类，该类需要继承自<code>AbstractAnnotationConfigDispatcherServletInitializer</code>类，并重写该类中的抽象方法，在重写的<code>getServletConfigClasses()</code>方法中，返回以上<code>SpringMvcConfig</code>类，在重写的<code>getServletMappings()</code>方法中，返回的字符串数组中配置<code>&quot;*.do&quot;</code>即可：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;/** * 项目的初始化类 */public class SpringMvcInitializer extends    AbstractAnnotationConfigDispatcherServletInitializer {    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() {        return null;    }    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() {        // 当项目初始化时，会加载当前方法的返回值        // 类似于创建了AnnotationConfigApplicationContext的对象，并且把当前方法的返回值作为构造方法参数        return new Class[] { SpringMvcConfig.class };    }    @Override    protected String[] getServletMappings() {        // 所有以 .do 为后缀的请求都由SpringMVC框架处理        // 之所以使用 .do 是因为它不是一个正常的扩展名        // 可以与访问普通的文件区分开来        // 也可以换成其它后缀，例如 .action        return new String[] { &quot;*.do&quot; };    }}</code></pre><blockquote><p>以上2个类都可以不必放在<code>cn.tedu.spring</code>包中，但是，应该为这2个类确定一个合理的包名。</p></blockquote><h4 id="2-5-使用控制器接收并处理请求"><a href="#2-5-使用控制器接收并处理请求" class="headerlink" title="2.5. 使用控制器接收并处理请求"></a>2.5. 使用控制器接收并处理请求</h4><p>在组件扫描的<code>cn.tedu.spring</code>包中创建<code>HelloController</code>类，并在类的声明之前添加<code>@Controller</code>注解：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * 控制器类，SpringMVC框架中的控制器的名称是自定义的，并且，不需要继承自某个类，也不需要实现某个接口 */@Controllerpublic class HelloController {}</code></pre><p>然后，在这个中添加以下代码：</p><pre><code class="java">// @RequestMapping用于配置请求路径// 后续，当项目运行时，按照这个路径来访问// 就会导致接下来的方法被执行// 接下来的方法就相当于Servlet中的service()方法@RequestMapping(&quot;hello.do&quot;)// @ResponseBody表示响应正文// 会导致接下来的方法的返回值会直接响应到客户端去@ResponseBodypublic String hello() {    // 注意：不要返回中文或中文的标点符号，默认不支持    return &quot;Hello, SpringMVC!!!&quot;;}</code></pre><h2 id="3-SpringMVC框架的核心组件"><a href="#3-SpringMVC框架的核心组件" class="headerlink" title="3. SpringMVC框架的核心组件"></a>3. SpringMVC框架的核心组件</h2><ul><li><code>DispatcherServlet</code>：前端控制器，负责接收所配置的所有请求（假设配置为<code>*.do</code>，则它将接收所有以<code>.do</code>为后缀的请求），并负责分发这些请求；</li><li><code>HandlerMapping</code>：记录了请求路径与处理请求的<code>Controller</code>或其方法的对应关系，</li><li><code>Controller</code>：控制器，负责处理具体的请求，每个项目中可能有若干个<code>Controller</code>组件，每个<code>Controller</code>组件中可以有若干个处理请求的方法；</li><li><code>ModelAndView</code>：控制器处理完请求后得到的结果，该结果可以包含数据与视图名称；</li><li><code>ViewResovler</code>：视图解析器，可以根据视图名称来确定具体的视图组件。</li></ul><h2 id="4-显示html模版页面"><a href="#4-显示html模版页面" class="headerlink" title="4. 显示html模版页面"></a>4. 显示html模版页面</h2><p>先在<strong>src/main/resources</strong>下创建<strong>templates</strong>文件夹，然后，在该文件夹创建<strong>register.html</strong>页面，页面的内容可以自行设计。</p><p>然后，在控制器中，将处理请求的方法之前的<code>@ResponseBody</code>注解去掉，并将方法的返回值改为<code>register</code>（HTML文件的名称），例如：</p><pre><code class="java">// 【显示注册页面】@RequestMapping(&quot;reg.do&quot;)public String reg() {    return &quot;register&quot;;}</code></pre><p>最后，在<strong>pom.xml</strong>中添加<code>thymeleaf</code>和<code>thymeleaf-spring4</code>/<code>thymeleaf-spring5</code>的依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt;    &lt;version&gt;3.0.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;    &lt;version&gt;3.0.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>并在<code>SpringMvcConfig</code>中添加关于<code>ViewResolver</code>的配置：</p><pre><code class="java">private String characterEncoding = &quot;utf-8&quot;;@Beanpublic ViewResolver viewResolver() {    ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();    templateResolver.setCharacterEncoding(characterEncoding);    templateResolver.setCacheable(false);    templateResolver.setTemplateMode(&quot;HTML&quot;);    templateResolver.setPrefix(&quot;/templates/&quot;); // 前缀    templateResolver.setSuffix(&quot;.html&quot;); // 后缀    SpringTemplateEngine templateEngine = new SpringTemplateEngine();    templateEngine.setTemplateResolver(templateResolver);    ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();    viewResolver.setCharacterEncoding(characterEncoding);    viewResolver.setTemplateEngine(templateEngine);    return viewResolver;}</code></pre><p>在以上配置中，需要关注的就是配置“前缀”和“后缀”的2条配置！SpringMVC框架在使用以上视图解析器时，会将“前缀”、“控制器方法返回的视图名称”、“后缀”拼接起来，得到具体用于显示的视图组件，以上代码中，拼接起来的值就是<code>/templates/register.html</code>，能够指向所设计的网页文件！当然，也可以采取其它的组件方式，例如“前缀”和“后缀”都配置为空字符串，而方法的返回值直接返回<code>&quot;/templates/register.html&quot;</code>也是可以的！</p><p>另外，以上代码中使用到了<code>ClassLoaderTemplateResolver</code>模版解析器，该模版解析器在工作时，默认会在项目的<strong>src/main/resources</strong>下查找视图组件，所以，视图文件（HTML）文件必须放在这个位置！还可以使用<code>ServletContextTemplateResolver</code>模版解析器，其查找视图组件的位置是在<strong>webapp</strong>下。</p><h2 id="5-接收客户端提交的请求参数"><a href="#5-接收客户端提交的请求参数" class="headerlink" title="5. 接收客户端提交的请求参数"></a>5. 接收客户端提交的请求参数</h2><p>在SpringMVC框架中，将“客户端提交的请求参数”直接声明为“处理请求的方法的参数”即可，甚至，还可以将参数直接声明为所期望的类型，例如：</p><pre><code class="java">// 【处理注册请求】@RequestMapping(&quot;handle_reg.do&quot;)@ResponseBodypublic String handleReg(String username, String password, Integer age, String phone, String email) {    System.out.println(&quot;UserController.handleReg()&quot;);    System.out.println(&quot;username=&quot; + username);    System.out.println(&quot;password=&quot; + password);    System.out.println(&quot;age=&quot; + age);    System.out.println(&quot;phone=&quot; + phone);    System.out.println(&quot;email=&quot; + email);    return &quot;Over&quot;;}</code></pre><h2 id="6-SpringMVC执行流程图"><a href="#6-SpringMVC执行流程图" class="headerlink" title="6.SpringMVC执行流程图"></a>6.SpringMVC执行流程图</h2><p><img src= "/img/loading.gif" data-src="/img/SpringMVC.png" alt="SpringMVC执行流程图"></p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC02</title>
      <link href="/2020/07/04/08_SPRINGMVC_DAY02/"/>
      <url>/2020/07/04/08_SPRINGMVC_DAY02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-接收客户端提交的请求参数"><a href="#1-接收客户端提交的请求参数" class="headerlink" title="1. 接收客户端提交的请求参数"></a>1. 接收客户端提交的请求参数</h2><h3 id="1-1-使用HttpServletRequest接收请求参数"><a href="#1-1-使用HttpServletRequest接收请求参数" class="headerlink" title="1.1. 使用HttpServletRequest接收请求参数"></a>1.1. 使用HttpServletRequest接收请求参数</h3><p>在处理请求的方法的参数列表中，添加<code>HttpServletRequest</code>类型的参数，在处理请求的过程中，调用该参数对象的<code>getParameter()</code>方法即可获取请求参数；</p><h3 id="1-2-将请求参数设计为方法的参数"><a href="#1-2-将请求参数设计为方法的参数" class="headerlink" title="1.2. 将请求参数设计为方法的参数"></a>1.2. 将请求参数设计为方法的参数</h3><p>可以将客户端提交的请求参数直接声明为处理请求的方法的参数，并且，可以直接将参数声明为期望的数据类型，例如：</p><pre><code class="java">// 【处理注册请求】@RequestMapping(&quot;handle_reg.do&quot;)@ResponseBodypublic String handleReg(String username, String password, Integer age, String phone, String email) {    System.out.println(&quot;UserController.handleReg()&quot;);    System.out.println(&quot;username=&quot; + username);    System.out.println(&quot;password=&quot; + password);    System.out.println(&quot;age=&quot; + age);    System.out.println(&quot;phone=&quot; + phone);    System.out.println(&quot;email=&quot; + email);    return &quot;Over&quot;;}</code></pre><p>使用这种做法时，必须保证客户端提交的请求参数与服务器端处理请求的方法的参数的名称是一致的！如果名称不一致，默认情况下，则服务器端处理请求的方法中，对应的参数将是<code>null</code>！</p><p>如果服务器端决定不使用方法的参数名作为客户端应该提交的请求参数名称，还可以在方法的参数之前添加<code>@RequestParam</code>注解，以指定参数名，例如：</p><pre><code class="java">public String handleReg(@RequestParam(&quot;username&quot;) String aaaaa, String password)</code></pre><p>按照以上代码中的注解，则客户端必须按照<code>username</code>和<code>password</code>这2个名称来提交请求参数！</p><h2 id="1-3-使用封装的类型接收请求参数"><a href="#1-3-使用封装的类型接收请求参数" class="headerlink" title="1.3. 使用封装的类型接收请求参数"></a>1.3. 使用封装的类型接收请求参数</h2><p>可以事先自定义类，将需要接收的请求参数都声明为这个类的属性，同时，为这些属性生成Set / Get方法：</p><pre><code class="java">package cn.tedu.spring;public class User {    private String username;    private String password;    private Integer age;    private String phone;    private String email;    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    public String getPhone() {        return phone;    }    public void setPhone(String phone) {        this.phone = phone;    }    public String getEmail() {        return email;    }    public void setEmail(String email) {        this.email = email;    }    @Override    public String toString() {        return &quot;User [username=&quot; + username + &quot;, password=&quot; + password + &quot;, age=&quot; + age + &quot;, phone=&quot; + phone                + &quot;, email=&quot; + email + &quot;]&quot;;    }}</code></pre><p>然后，将自定义的数据类型声明为处理请求的方法的参数即可：</p><pre><code class="java">// 【处理注册请求】@RequestMapping(&quot;handle_reg.do&quot;)@ResponseBodypublic String handleReg(User user) {    System.out.println(&quot;UserController.handleReg()&quot;);    System.out.println(user);    return &quot;Over&quot;;}</code></pre><p>使用这种做法，应该保证客户端提交的请求参数名称与以上<code>User</code>类中的属性名称相同，且<code>User</code>类中的各属性都有规范名称的Set / Get方法！</p><h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4. 小结"></a>1.4. 小结</h2><p>以上3种方式中，<code>1.1</code>是在任何情况下都不推荐使用的！</p><p>通常，当参数数量较少且固定（数量或意义）时，优先使用<code>1.2</code>的做法；</p><p>当参数数量较多或不固定时，优先使用<code>1.3</code>的做法。</p><p>以上各做法可以综合在一起同时使用！</p><h2 id="2-控制器向模版页面转发数据"><a href="#2-控制器向模版页面转发数据" class="headerlink" title="2. 控制器向模版页面转发数据"></a>2. 控制器向模版页面转发数据</h2><h3 id="2-1-通过HttpServletRequest转发数据"><a href="#2-1-通过HttpServletRequest转发数据" class="headerlink" title="2.1. 通过HttpServletRequest转发数据"></a>2.1. 通过HttpServletRequest转发数据</h3><p>在处理请求的方法的参数列表中添加<code>HttpServletRequest</code>类型的参数，当需要将某些数据显示到页面中时，调用该参数对象的<code>setAttribute(String name, Object value)</code>方法将数据封装到<code>HttpServletRequest</code>请求对象中：</p><pre><code class="java">// 【处理登录请求】@RequestMapping(&quot;handle_login.do&quot;)public String handleLogin(String username, String password, HttpServletRequest request) {    System.out.println(&quot;UserController.handleLogin()&quot;);    System.out.println(&quot;username=&quot; + username);    System.out.println(&quot;password=&quot; + password);    // 假设root/1234是正确的用户名/密码    // 判断用户名    if (&quot;root&quot;.equals(username)) {        // 用户名正确，需要判断密码        if (&quot;1234&quot;.equals(password)) {            // 密码也正确，登录成功            // 暂不考虑登录成功后的处理        } else {            // 登录失败，密码错误            String errorMessage = &quot;登录失败，密码错误！&quot;;            request.setAttribute(&quot;msg&quot;, errorMessage);            return &quot;error&quot;;        }    } else {        // 登录失败，用户名错误        String errorMessage = &quot;登录失败，用户名不存在！&quot;;        request.setAttribute(&quot;msg&quot;, errorMessage);        return &quot;error&quot;;    }    return &quot;Over.&quot;;}</code></pre><p>由于当前使用的是<code>Thymeleaf</code>框架，在HTML模版页面中，可以通过<code>Thymeleaf</code>表达式取出在控制器中封装到<code>HttpServletRequest</code>中的参数，例如：</p><pre><code class="html">&lt;h1 style=&quot;color:red&quot;&gt;操作失败！&lt;span th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;！&lt;/h1&gt;</code></pre><h2 id="2-2-通过ModelMap转发数据"><a href="#2-2-通过ModelMap转发数据" class="headerlink" title="2.2. 通过ModelMap转发数据"></a>2.2. 通过ModelMap转发数据</h2><p>使用<code>ModelMap</code>转发数据的做法与使用<code>HttpServletRequest</code>转发数据几乎相同！例如：</p><pre><code class="java">// 【处理登录请求】@RequestMapping(&quot;handle_login.do&quot;)public String handleLogin(String username, String password, ModelMap modelMap) {    System.out.println(&quot;UserController.handleLogin()&quot;);    System.out.println(&quot;username=&quot; + username);    System.out.println(&quot;password=&quot; + password);    // 假设root/1234是正确的用户名/密码    // 判断用户名    if (&quot;root&quot;.equals(username)) {        // 用户名正确，需要判断密码        if (&quot;1234&quot;.equals(password)) {            // 密码也正确，登录成功            // 暂不考虑登录成功后的处理        } else {            // 登录失败，密码错误            String errorMessage = &quot;登录失败，密码错误！！&quot;;            modelMap.addAttribute(&quot;msg&quot;, errorMessage);            return &quot;error&quot;;        }    } else {        // 登录失败，用户名错误        String errorMessage = &quot;登录失败，用户名不存在！！&quot;;        modelMap.addAttribute(&quot;msg&quot;, errorMessage);        return &quot;error&quot;;    }    return &quot;Over.&quot;;}</code></pre><h2 id="2-3-使用ModelAndView转发数据"><a href="#2-3-使用ModelAndView转发数据" class="headerlink" title="2.3. 使用ModelAndView转发数据"></a>2.3. 使用ModelAndView转发数据</h2><p>将处理请求的方法的返回值类型声明为<code>ModelAndView</code>类型，在方法返回<code>ModelAndView</code>对象之前，必须向该对象中封装视图名称与数据，例如：</p><pre><code class="java">// 【处理登录请求】@RequestMapping(&quot;handle_login.do&quot;)public ModelAndView handleLogin(String username, String password) {    System.out.println(&quot;UserController.handleLogin()&quot;);    System.out.println(&quot;username=&quot; + username);    System.out.println(&quot;password=&quot; + password);    // 假设root/1234是正确的用户名/密码    // 判断用户名    if (&quot;root&quot;.equals(username)) {        // 用户名正确，需要判断密码        if (&quot;1234&quot;.equals(password)) {            // 密码也正确，登录成功            // 暂不考虑登录成功后的处理        } else {            // 登录失败，密码错误            String errorMessage = &quot;MAV:登录失败，密码错误！！&quot;;            Map&lt;String, Object&gt; model = new HashMap&lt;String, Object&gt;();            model.put(&quot;msg&quot;, errorMessage);            ModelAndView mav = new ModelAndView(&quot;error&quot;, model);            return mav;        }    } else {        // 登录失败，用户名错误        String errorMessage = &quot;MAV:登录失败，用户名不存在！！&quot;;        Map&lt;String, Object&gt; model = new HashMap&lt;String, Object&gt;();        model.put(&quot;msg&quot;, errorMessage);        ModelAndView mav = new ModelAndView(&quot;error&quot;, model);        return mav;    }    return null;}</code></pre><h2 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3. 重定向"></a>3. 重定向</h2><p>当处理请求的方法的返回值类型是<code>String</code>类型时，返回<code>&quot;redirect:目标路径&quot;</code>即可实现重定向！</p><blockquote><p>当处理请求的方法的返回值类型是<code>String</code>类型时，如果希望执行转发，可以使用<code>&quot;forward:视图名称&quot;</code>的格式，由于转发是默认的行为，所以直接返回<code>&quot;视图名称&quot;</code>即可，不需要显式的添加<code>forward:</code>前缀。</p></blockquote><p><strong>关于转发与重定向的区别</strong></p><ul><li>转发是服务器内部的行为，具体表现为“控制器将请求转发给视图组件（可以有数据，也可以没有数据）”，对于客户端来说，只发出过1次请求，并且，只知道这1次请求的路径，在客户端的浏览器中，地址栏显示的URL也不会发生变化！同时，由于这是服务器内部的行为，所以，控制器可以向视图组件传递任意数据！从编写代码的角度来看，转发时，需要指定的是视图名称！</li><li>重定向的本质是客户端向服务器第1次发出请求后，服务器响应了302响应码，及目标路径，客户端收到这次响应后，由于响应码是<code>302</code>，会自动发出第2次请求，请求路径（目标）就是第1次请求时服务器端响应的目标路径！所以，总的来说，重定向至少发生了2次请求与响应的交互过程，由于是多次请求，并且，后续的请求目标路径对于客户端来说是已知的，所以，在客户端的浏览器中，地址栏显示的URL会发生变化！同时，由于整个过程是多次请求，由服务器端多个不同的控制器类（同一个控制器，但处理请求的方法不同）进行处理的，会导致在默认情况下，多次处理请求的过程中产生的数据无法共享使用或不便于传递！从编写代码的角度来看，重定向时，需要指定的是目标路径！</li></ul><h2 id="4-使用Session"><a href="#4-使用Session" class="headerlink" title="4. 使用Session"></a>4. 使用Session</h2><p>在处理请求的方法的参数列表中，可以直接添加<code>HttpSession</code>类型的参数，用于访问Session中的数据，添加参数后，在当前方法体中，就可以向Session中存入数据，也可以取出Session的数据，当然，只要存入了数据，在Session的有效期内，视图组件也可以直接获取Session中的数据！</p><p><strong>关于Session的消失：</strong></p><ul><li>服务器关机或重启；</li><li>超时；</li><li>关闭浏览器。</li></ul><p><strong>关于存入到Session中的数据：</strong></p><ul><li>用户身份的唯一标识，例如用户的id、用户名等；</li><li>高频率访问的数据，例如用户名、头像等；</li><li>不便于使用其它技术进行传递或共享的数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring03</title>
      <link href="/2020/07/03/07_SPRING_DAY03/"/>
      <url>/2020/07/03/07_SPRING_DAY03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-通过Environment读取-properties配置文件"><a href="#1-通过Environment读取-properties配置文件" class="headerlink" title="1. 通过Environment读取.properties配置文件"></a>1. 通过Environment读取.properties配置文件</h2><p>假设在<strong>src/main/resources</strong>下存在<strong>jdbc.properties</strong>文件，并且，在该文件中存在若干条配置信息，如果需要读取该文件中的配置信息，可以先创建某个类，在类中声明<code>Environment</code>接口类型的对象，通过自动装配的方式为该类型对象注入值：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.PropertySource;import org.springframework.core.env.Environment;import org.springframework.stereotype.Component;@Component@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JdbcConfig {    @Autowired    private Environment environment;    public Environment getEnvironment() {        return environment;    }    public void setEnvironment(Environment environment) {        this.environment = environment;    }}</code></pre><p>后续，需要读取配置文件中的值时，从以上类中获取<code>Environment</code>类型的对象，然后，调用该对象的<code>getProperty()</code>方法即可获取对应的值，例如：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.core.env.Environment;public class Demo {    public static void main(String[] args) {        AnnotationConfigApplicationContext ac            = new AnnotationConfigApplicationContext(SpringConfig.class);        JdbcConfig jdbcConfig = ac.getBean(&quot;jdbcConfig&quot;, JdbcConfig.class);        Environment environment = jdbcConfig.getEnvironment();        System.out.println(environment.getProperty(&quot;db.url&quot;));        System.out.println(environment.getProperty(&quot;db.driver&quot;));        System.out.println(environment.getProperty(&quot;db.username&quot;));        System.out.println(environment.getProperty(&quot;db.password&quot;));        ac.close();    }}</code></pre><h2 id="Spring阶段小结"><a href="#Spring阶段小结" class="headerlink" title="Spring阶段小结"></a>Spring阶段小结</h2><ul><li><p>【理解】Spring框架的主要作用：创建对象，管理对象；</p></li><li><p>【理解】Spring框架深层的作用：解耦；</p></li><li><p>【掌握】通过Spring框架创建对象：</p><ul><li>在某个类中自定义方法，方法的返回值类型就是需要Spring框架创建对象的类型，在方法体中自行返回所需要创建的对象，并且为方法添加<code>@Bean</code>注解，后续，只要Spring框架加载这个类，就会自动调用被添加了<code>@Bean</code>注解的方法，并管理方法所返回的对象。通常，当需要管理的对象所归属的类不是自定义的，必须使用这种做法；</li><li>使得Spring框架执行组件扫描，保证相关的类在组件扫描的包或其子孙包中，并且，类还需要添加<code>@Component</code> / <code>@Controller</code> / <code>@Service</code> / <code>@Repository</code>注解中的某1个。通常，当需要管理的对象所归属的类是自定义的，优先使用这种做法。</li></ul></li><li><p>【掌握】关于组件扫描：可以将组件扫描的包的名称作为字符串参数直接应用于<code>AnnotationConfigApplicationContext</code>类的构造方法中，但是，并不推荐使用这种做法，在实际项目开发时，<code>AnnotationConfigApplicationContext</code>类通常不是开发人员自行创建的，也就没有办法在构造方法中添加包的名称！推荐使用自定义的类作为配置类，并结合<code>@ComponentScan</code>注解来配置组件扫描；</p></li><li><p>【理解】被Spring管理的对象默认是单例的（注意：Spring框架不是设计模式中的单例模式，只是管理对象的方法是这样的），并且，不是懒加载的模式（相当于单例模式中的饿汉式单例的效果）；</p></li><li><p>【了解】使用<code>@Scope</code>和<code>@Lazy</code>调整被Spring管理的对象的作用域；</p></li><li><p>【理解】被Spring管理的对象的生命周期；</p></li><li><p>【了解】配置对象的生命周期：</p><ul><li>如果使用的是添加了<code>@Bean</code>注解的自定义方法返回对象的做法，在<code>@Bean</code>注解中配置<code>initMethod</code>和<code>destroyMethod</code>属性，就可以将类中的方法分别指定为初始化方法和销毁方法；</li><li>如果使用的是组件扫描和组件注解的做法，在类中的初始化方法之前添加<code>@PostConstruct</code>注解，在销毁方法之前添加<code>@PreDestroy</code>方法。</li></ul></li><li><p>【理解】关于Spring框架的DI与IoC：</p><ul><li>DI：Dependency Injection，依赖注入，具体的表现就是“为当前类对象所依赖的某个属性注入值”；</li><li>IoC：Inversion of Control：控制反转，在传统模式下，是由开发人员自行创建对象（例如<code>User user = new User();</code>）且管理对象（例如<code>user.setName(&quot;Jack&quot;);</code>），可以理解为开发人员具有对象的控制权，当使用了Spring框架后，创建对象和管理对象的权力就交给了框架。</li><li>在Spring框架中，DI是一种做法，IoC是最终实现的效果，也就是“Spring框架通过DI这种做法实现了IoC的效果”。</li></ul></li><li><p>【理解】Spring框架自动装配机制的2种装配模式：</p><ul><li><code>byName</code>：根据名称实现自动装配，在这种模式下，要求被装配的属性名称，与被Spring管理的对象的名称（调用<code>getBean()</code>方法给出的参数名）必须相同；</li><li><code>byType</code>：根据类型实现自动装配，在这种模式，要求被装配的属性的类型，在Spring容器中存在匹配类型的对象，当应用这种机制时，必须在Spring容器中保证匹配类型的对象只有1个，否则，将会出现<code>NoUniqueBeanDefinitionException</code>异常；</li></ul></li><li><p>【理解】使用<code>@Autowired</code>和<code>@Resource</code>这2个注解实现自动装配时的区别：</p><ul><li>使用<code>@Autowired</code>尝试自动装配时，Spring框架会先根据<code>byType</code>模式找出所有匹配类型的对象，如果匹配类型的对象的数量为0，也就是没有匹配类型的对象，默认情况下会直接报错（如果明确的配置为<code>@Autowired(required=false)</code>时不会因为装配失败而出错）；如果匹配类型的对象的数量为1，则直接装配；如果匹配类型的对象的数量超过1个（有2个甚至更多个），会尝试<code>byName</code>来装配，如果存在名称匹配的对象，则成功装配，如果名称均不匹配，则装配失败。</li><li>使用<code>@Resource</code>注解尝试自动装配时，其工作原理是先尝试<code>byName</code>装配，如果存在名称匹配的对象，则直接装配，如果没有名称匹配的对象，则尝试<code>byType</code>装配。</li></ul></li><li><p>【掌握】通过Spring框架读取<strong>.properties</strong>配置文件中的信息：</p><ul><li>在组件类的声明之前添加<code>@PropertySource</code>注解，以配置需要读取的<strong>.properties</strong>文件的位置，然后，通过<code>@Value</code>注解将读取到的属性值一一注入到类的属性中，在声明类的属性时，只要该属性的类型是常规类型（例如基本数据类型、<code>String</code>等）或Spring框架自定义的类型，都可以将类的属性直接声明为所期望的类型；</li><li>在组件类的声明之前添加<code>@PropertySource</code>注解，以配置需要读取的<strong>.properties</strong>文件的位置，然后，在类中自定义<code>Environment</code>接口类型的对象，通过<code>@Autowired</code>为该对象自动装配值，后续，调用该对象的<code>getProperty()</code>方法即可获取在<strong>.properties</strong>文件中配置的属性值。</li></ul></li><li><p>【说明】关于Spring AOP会在项目后期再讲。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntellijIDEA快捷使用</title>
      <link href="/2020/07/02/IntellijIDEA%E5%BF%AB%E6%8D%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/02/IntellijIDEA%E5%BF%AB%E6%8D%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Intellij-IDEA快捷使用"><a href="#Intellij-IDEA快捷使用" class="headerlink" title="Intellij IDEA快捷使用"></a>Intellij IDEA快捷使用</h1><h2 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="1. 快捷键"></a>1. 快捷键</h2><h3 id="1-1-按键说明"><a href="#1-1-按键说明" class="headerlink" title="1.1. 按键说明"></a>1.1. 按键说明</h3><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>需要同时按下加号左右两侧的键</td></tr><tr><td>,</td><td>按下逗号左侧的键后，松开，然后按下逗号右侧的键</td></tr><tr><td>Ctrl</td><td>控制键，键盘上标记了<code>Ctrl</code>的键，在Mac键盘上标记为<code>control</code></td></tr><tr><td>Shift</td><td>上档键，键盘上标记了<code>Shift</code>的键</td></tr><tr><td>Alt</td><td>切换键，键盘上标记了<code>Alt</code>的键，在Mac键盘上与<code>Option</code>是同一个键</td></tr><tr><td>Command</td><td>命令键，<strong>Mac键盘独有</strong>，标记了<code>Command</code>的键</td></tr><tr><td>Enter</td><td>回车键，键盘上标记了<code>Enter</code>的键，在Mac键盘上与<code>return</code>是同一个键</td></tr><tr><td>Space</td><td>空格键，键盘上最下方、最大的按键</td></tr><tr><td>Up / Down</td><td>方向上/方向下，通常在键盘上标记了向上/向下的箭头</td></tr></tbody></table><p>某些快捷键可能与操作系统或其它软件的全局快捷键是冲突的，则按下会无效或执行其它命令，可以在Intellij IDEA的设置的<strong>Keymap</strong>中修改为其它按键。</p><p>以下快捷键是Intellij IDEA的默认风格快捷键，如果改成了Eclipse风格或其它风格，请参考所更改的设置。</p><p>标记了<code>[!]</code>是可能存在冲突的快捷键。</p><p>全部快捷键可在Intellij IDEA的设置的<strong>Keymap</strong>中查看，或者查看官方文档：<a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf?_ga=2.5349558.422550521.1580708138-1891300040.1568641704">https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf?_ga=2.5349558.422550521.1580708138-1891300040.1568641704</a></p><p>在各种编辑软件中都会使用到的快捷键可能不会被列举到以下各表中，例如<code>Ctrl</code> + <code>C</code>表示<strong>复制</strong>，在各种编辑软件中都是这样设计的，就不重复列举了。</p><h3 id="1-2-推荐快捷键"><a href="#1-2-推荐快捷键" class="headerlink" title="1.2. 推荐快捷键"></a>1.2. 推荐快捷键</h3><table><thead><tr><th>Windows / Linux</th><th>Mac OS</th><th>说明</th></tr></thead><tbody><tr><td><strong>[!]</strong> Ctrl + Space</td><td>Ctrl + Space</td><td>基本代码提示</td></tr><tr><td>Ctrl + Shift + Space</td><td>Ctrl + Shift + Space</td><td>智能代码提示</td></tr><tr><td>Shift, Shift</td><td>Shift, Shift</td><td>全局查找</td></tr><tr><td>Alt + Enter</td><td>Option + Enter</td><td>代码错误解决方案</td></tr><tr><td>Alt + Insert</td><td>Command + N 或 Ctrl + Enter</td><td>自动生成Bean方法</td></tr><tr><td>Ctrl + P</td><td>Command + P</td><td>在调用方法时，将光标定位在方法的括号中，提示方法的参数列表</td></tr><tr><td>Shift + F6</td><td>Shift + F6</td><td>重命名，适用于：在文件列表中对文件重命名，在文件内部对类名、属性名、方法名等重命名</td></tr></tbody></table><h3 id="1-3-常规"><a href="#1-3-常规" class="headerlink" title="1.3. 常规"></a>1.3. 常规</h3><table><thead><tr><th>Windows / Linux</th><th>Mac OS</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl + Shift + A</td><td>Command + Shift + A</td><td>查找命令（IDE中可执行的命令，例如运行、调试、重命名等）</td></tr></tbody></table><h3 id="1-4-查找与替换"><a href="#1-4-查找与替换" class="headerlink" title="1.4. 查找与替换"></a>1.4. 查找与替换</h3><table><thead><tr><th>Windows / Linux</th><th>Mac OS</th><th>说明</th></tr></thead><tbody><tr><td>Shift, Shift</td><td>Shift, Shift</td><td>全局查找</td></tr><tr><td>Ctrl + F</td><td>Command + F</td><td>在当前源代码中查找</td></tr><tr><td>Ctrl + R</td><td>Command + R</td><td>在当前源代码中替换</td></tr><tr><td>Ctrl + Shift + F</td><td>Command + Shift + F</td><td>在指定路径（例如整个项目）中查找</td></tr><tr><td>Ctrl + Shift + R</td><td>Command + Shift + R</td><td>在指定路径（例如整个项目）中替换</td></tr></tbody></table><h3 id="1-5-代码编辑"><a href="#1-5-代码编辑" class="headerlink" title="1.5. 代码编辑"></a>1.5. 代码编辑</h3><table><thead><tr><th>Windows / Linux</th><th>Mac OS</th><th>说明</th></tr></thead><tbody><tr><td>[!] Ctrl + Space</td><td>Ctrl + Space</td><td>基本代码提示</td></tr><tr><td>Ctrl + Shift + Space</td><td>Ctrl + Shift + Space</td><td>智能代码提示</td></tr><tr><td>Ctrl + P</td><td>Command + P</td><td>在调用方法时，将光标定位在方法的括号中，提示方法的参数列表</td></tr><tr><td>Alt + Insert</td><td>Command + N 或 Ctrl + Enter</td><td>自动生成Bean方法</td></tr><tr><td>Ctrl + O</td><td>Ctrl + O</td><td>重写方法</td></tr><tr><td>Ctrl + Alt + T</td><td>Command + Option +  T</td><td>使用if/try…catch等代码块包裹当前选中代码</td></tr><tr><td>Ctrl + /</td><td>Command + /</td><td>添加/移除行注释</td></tr><tr><td>Ctrl + Alt + L</td><td>Command + Option + L</td><td>格式化源代码</td></tr><tr><td>Ctrl + Alt + O</td><td>[!] Ctrl + Option + O</td><td>整理import语句</td></tr><tr><td>Ctrl + D</td><td>Command + D</td><td>向下复制代码行</td></tr><tr><td>Ctrl + Y</td><td>Command + Delete</td><td>删除代码行</td></tr><tr><td>Shift + Enter</td><td>Shift + Enter</td><td>新增下一行代码，并将光标定位到下一行代码</td></tr><tr><td>Ctrl + Enter</td><td>Command + Enter</td><td>新增下一行代码，光标在原有位置不变</td></tr><tr><td>Ctrl + +/-</td><td>Command + +/-</td><td>展开或收起类的某个成员，例如方法、内部类等</td></tr><tr><td>Ctrl + Shift + +/-</td><td>Command + Shift + +/-</td><td>展开或收起当前类的所有成员</td></tr><tr><td></td><td>Option + Shift + 上/下</td><td>向上/下移动代码</td></tr><tr><td></td><td>Command + Option + V</td><td>将光标所在位置的常量声明为局部变量</td></tr><tr><td>Ctrl + Shift + V</td><td>Command + Shift + V</td><td>从最近复制过的多项中选择某项来粘贴</td></tr></tbody></table><blockquote><p>也有很多开发者使用<code>Ctrl</code> + <code>X</code>作为<strong>删除代码行</strong>的快捷键，其本质是<strong>剪切</strong>了代码，当然，只要不粘贴，其效果也是相同的。</p></blockquote><h3 id="1-6-管理与导航"><a href="#1-6-管理与导航" class="headerlink" title="1.6. 管理与导航"></a>1.6. 管理与导航</h3><table><thead><tr><th>Windows</th><th>Mac OS</th><th>说明</th></tr></thead><tbody><tr><td>Shift + F6</td><td>Shift + F6</td><td>重命名，适用于：在文件列表中对文件重命名，在文件内部对类名、属性名、方法名等重命名</td></tr><tr><td></td><td>Shift + 单击</td><td>在选项卡处单击以关闭文件</td></tr><tr><td>Ctrl  + F12</td><td>Command + F12</td><td>显示当前文档结构</td></tr><tr><td>Ctrl + U</td><td>Command + U</td><td>打开父类方法，打开父类，需先装光标定位到类名，不适用于打开Object类</td></tr><tr><td>F4 / Ctrl + Enter</td><td>Command + 下 / Ctrl + 单击</td><td>打开光标所在位置的类、属性、方法的声明</td></tr></tbody></table><h2 id="2-快捷输入"><a href="#2-快捷输入" class="headerlink" title="2. 快捷输入"></a>2. 快捷输入</h2><h3 id="2-1-操作方式"><a href="#2-1-操作方式" class="headerlink" title="2.1. 操作方式"></a>2.1. 操作方式</h3><p>可以通过快捷输入简单的内容后按下Enter键，快速完成特定的代码内容，这些内容可以在设置的Editor &gt; Live Templates中查看或调整。</p><h3 id="2-2-常规"><a href="#2-2-常规" class="headerlink" title="2.2. 常规"></a>2.2. 常规</h3><table><thead><tr><th>输入内容</th><th>等效代码</th></tr></thead><tbody><tr><td><code>psvm</code></td><td><code>public static void main(String[] args) {}</code></td></tr><tr><td><code>sout</code></td><td><code>System.out.println();</code></td></tr><tr><td><code>serr</code></td><td><code>System.err.println();</code></td></tr><tr><td><code>soutm</code></td><td><code>System.out.println(&quot;类名.方法名&quot;);</code></td></tr><tr><td><code>soutp</code></td><td><code>System.out.println(&quot;参数1 = [值1], 参数2 = [值2], ... , 参数N = [值N]&quot;);</code></td></tr><tr><td><code>soutv</code></td><td><code>System.out.println(&quot;参数名 = 值&quot;);</code></td></tr></tbody></table><h3 id="2-3-声明静态常量"><a href="#2-3-声明静态常量" class="headerlink" title="2.3. 声明静态常量"></a>2.3. 声明静态常量</h3><table><thead><tr><th>输入内容</th><th>等效代码</th></tr></thead><tbody><tr><td><code>psf</code></td><td><code>public static final</code></td></tr><tr><td><code>prsf</code></td><td><code>private static final</code></td></tr><tr><td><code>psfi</code></td><td><code>public static final int</code></td></tr><tr><td><code>psfs</code></td><td><code>public static final String</code></td></tr></tbody></table><h3 id="2-4-判断"><a href="#2-4-判断" class="headerlink" title="2.4. 判断"></a>2.4. 判断</h3><table><thead><tr><th>输入内容</th><th>等效代码</th></tr></thead><tbody><tr><td><code>ifn</code></td><td><code>if (变量 == null) {}</code></td></tr><tr><td><code>inn</code></td><td><code>if (变量 != null) {}</code></td></tr><tr><td><code>inst</code></td><td><code>if (变量 instanceof 类) {}</code></td></tr></tbody></table><h3 id="2-5-循环与遍历"><a href="#2-5-循环与遍历" class="headerlink" title="2.5. 循环与遍历"></a>2.5. 循环与遍历</h3><table><thead><tr><th>输入内容</th><th>等效代码</th></tr></thead><tbody><tr><td><code>fori</code></td><td><code>for (int 循环变量 = 0; 循环变量 &lt; ; i++) {}</code></td></tr><tr><td><code>itar</code></td><td><code>for (int 循环变量 = 0; 循环变量 &lt; 数组.length(); i++) { 类型 数组元素变量名 = 数组[i]}</code></td></tr><tr><td><code>iter</code></td><td><code>for (元素类型 变量名 : 被遍历对象) {}</code></td></tr><tr><td><code>itli</code></td><td><code>for (int 循环变量 = 0; 循环变量 &lt; 集合.size(); i++) { 类型 集合元素变量名 = 集合.get(循环变量); }</code></td></tr></tbody></table><h2 id="3-快捷输入–高级"><a href="#3-快捷输入–高级" class="headerlink" title="3. 快捷输入–高级"></a>3. 快捷输入–高级</h2><h3 id="3-1-遍历数组或集合对象"><a href="#3-1-遍历数组或集合对象" class="headerlink" title="3.1. 遍历数组或集合对象"></a>3.1. 遍历数组或集合对象</h3><p>假设存在名为<code>numbers</code>的<code>int</code>数组或集合，输入<code>numbers.for</code>即可生成增强for循环代码，格式如下：</p><pre><code class="java">for (int number : numbers) {}</code></pre><h3 id="3-2-为值声明变量"><a href="#3-2-为值声明变量" class="headerlink" title="3.2. 为值声明变量"></a>3.2. 为值声明变量</h3><p>假设需要声明<code>int</code>类型的变量，其值为<code>1</code>，输入<code>1.var</code>即可生成对应的声明语句，格式如下：</p><pre><code class="java">int i = 1;</code></pre><p>整型数字默认生成的变量名是<code>i</code>，代码生成后，可以自行调整。</p><p>同理，假设需要声明<code>String</code>类型的变量，其值为<code>&quot;Java&quot;</code>，输入<code>&quot;Java&quot;.var</code>即可，格式如下：</p><pre><code class="java">String java = &quot;Java&quot;;</code></pre><p>字符串类型默认生成的变量名有多种情况，例如字符串内容是简单字母时，默认变量名就是字母，如果字母首字母是大写的，也会自动使用首字母小写作为默认变量名，字符串类型是汉字时，默认变量名就是汉字，字符串中包含不允许组成变量名的字符时，会使用<code>s</code>或<code>s1</code>、<code>s2</code>等作为默认变量名，当然，在代码生成后，都可以自行调整。</p><p>其它数据类型的值也可以使用同样的方法声明出变量，例如输入<code>new Date().var</code>时，就可以生成：</p><pre><code class="java">Date date = new Date();</code></pre><h3 id="3-3-判断对象是否为空"><a href="#3-3-判断对象是否为空" class="headerlink" title="3.3. 判断对象是否为空"></a>3.3. 判断对象是否为空</h3><p>假设存在名为<code>x</code>的变量，需要判断是否为空，输入<code>x.null</code>然后在提示菜单中选择<code>null</code>一栏回车，即可生成：</p><pre><code class="java">if (x == null) {}</code></pre><p>如果需要判断是否非空，则输入<code>x.no</code>后选择<code>notnull</code>一栏并回车，即可生成：</p><pre><code class="java">if (x != null) {}</code></pre><hr><p>未完，某天再续……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring02</title>
      <link href="/2020/07/01/07_SPRING_DAY02/"/>
      <url>/2020/07/01/07_SPRING_DAY02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-组件扫描"><a href="#1-组件扫描" class="headerlink" title="1. 组件扫描"></a>1. 组件扫描</h2><p>首先，必须让Spring扫描组件所在的包，并且，组件类的声明之前必须添加<code>@Component</code>注解！</p><p>其实，除了<code>@Component</code>注解以外，还可以使用以下注解实现同样的效果：</p><ul><li><code>@Controller</code>:推荐添加在<strong>控制器类</strong>之前;</li><li><code>@Service</code>:推荐添加在<strong>业务类</strong>之前;</li><li><code>@Repository</code>:推荐添加在<strong>处理持久层的类</strong>之前.</li></ul><p>以上4个注解在Spring框架的作用领域中，效果是完全相同的，用法也完全相同，只是<strong>语义</strong>不同。</p><p>在使用组件扫描时，还可以自定义某个类，作为配置类，在这个类的声明之前使用<code>@ComponentScan</code>注解来配置组件扫描的包：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.context.annotation.ComponentScan;@ComponentScan(&quot;cn.tedu.spring&quot;)public class SpringConfig {}</code></pre><p>后续,程序运行时,就需要加载这个配置类：</p><pre><code class="java">AnnotationConfigApplicationContext ac     = new AnnotationConfigApplicationContext(SpringConfig.class);</code></pre><p>关于组件扫描的包，严格来说，是配置需要被扫描的“<strong>根包</strong>（base package）”，也就是说，在执行扫描时，会扫描所设置的包及其所有子孙包中的所有组件类！当设置为扫描<code>cn.tedu</code>包时，会把<code>cn.tedu.spring</code>甚至<code>cn.tedu.spring.dao</code>这些包中的组件类都扫描到！</p><h2 id="2-关于注解的使用"><a href="#2-关于注解的使用" class="headerlink" title="2. 关于注解的使用"></a>2. 关于注解的使用</h2><p>以<code>@Bean</code>注解为例，其声明是：</p><pre><code class="java">@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Bean {}</code></pre><p>可以看到，注解都是通过<code>@interface</code>声明的！</p><p>在注解的声明之前，还添加了一系列的注解，例如以上的<code>@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})</code>、<code>@Retention(RetentionPolicy.RUNTIME)</code>、<code>@Documented</code>，则表示当前<code>@Bean</code>注解同时具有以上3个注解的特性。也就是说，<code>@Bean</code>注解相当于以上3个注解的同时，还具有自身的特性！</p><p>在<code>@Bean</code>注解内部，还有：</p><pre><code class="java">/** * Alias for {@link #name}. * &lt;p&gt;Intended to be used when no other attributes are needed, for example: * {@code @Bean(&quot;customBeanName&quot;)}. * @since 4.3.3 * @see #name */@AliasFor(&quot;name&quot;)String[] value() default {};</code></pre><p>以上<code>String[] value() default {};</code>有点像接口中的抽象方法，但是，在注解中，这是声明的注解属性！<code>value</code>是属性名称，所以，在使用当前注解时，可以配置：</p><pre><code class="java">@Bean(value=???)</code></pre><p>以上源代码中的<code>String[]</code>看似是抽象方法的返回值，实则是<code>value</code>属性的值的数值类型！所以，可以配置为：</p><pre><code class="java">@Bean(value={&quot;a&quot;, &quot;b&quot;, &quot;c&quot;})</code></pre><p>以上源代码中的<code>default {}</code>表示该属性的默认值，所以，以下2段配置是完全等效的：</p><pre><code class="java">@Bean</code></pre><pre><code class="java">@Bean(value={})</code></pre><p>在配置注解属性时，如果属性名称是<code>value</code>，它是默认的属性，在配置时，可以不用显式的写出<code>value=</code>部分，也就是说，以下2段配置是完全等效的：</p><pre><code class="java">@Bean(value={&quot;a&quot;, &quot;b&quot;, &quot;c&quot;})</code></pre><pre><code class="java">@Bean({&quot;a&quot;, &quot;b&quot;, &quot;c&quot;})</code></pre><p>在配置注解属性时，如果属性的值的类型是数组类型，但是，当前只需要配置1个值时，可以不用写成数组格式，只需要写成数组元素的格式即可！也就是说，以下2段配置是完全等效的：</p><pre><code class="java">@Bean({&quot;a&quot;})</code></pre><pre><code class="java">@Bean(&quot;a&quot;)</code></pre><p>所以，总的来说，关于<code>@Bean</code>注解的<code>value</code>属性，如果需要配置的值是<code>&quot;user&quot;</code>，则以下4段代码都是完全等效的：</p><pre><code class="java">@Bean(&quot;user&quot;)</code></pre><pre><code class="java">@Bean({&quot;user&quot;})</code></pre><pre><code class="java">@Bean(value=&quot;user&quot;)</code></pre><pre><code class="java">@Bean(value={&quot;user&quot;})</code></pre><p>在以上源代码中，注释中还标明了<code>@since 4.3.3</code>，表示该属性从Spring框架4.3.3版本开始才加入的，如果当前使用的环境改为4.3.3以下的版本，将导致该属性不可用，因为在更低的版本中，根本就没有这个属性，甚至可能连个注解本身都不存在！</p><p>在以上源代码中，在<code>value</code>属性的声明之前还添加了<code>@AliasFor(&quot;name&quot;)</code>注解，表示当前<code>value</code>属性另有<strong>别名</strong>为<code>name</code>，所以，在<code>@Bean</code>注解的源代码中，还有：</p><pre><code class="java">/** * The name of this bean, or if several names, a primary bean name plus aliases. * &lt;p&gt;If left unspecified, the name of the bean is the name of the annotated method. * If specified, the method name is ignored. * &lt;p&gt;The bean name and aliases may also be configured via the {@link #value} * attribute if no other attributes are declared. * @see #value */@AliasFor(&quot;value&quot;)String[] name() default {};</code></pre><p>则在<code>@Bean</code>注解中，<code>name</code>和<code>value</code>这2个注解是完全等效的！</p><p>之所以存在2个完全等效的属性，是因为：</p><ul><li><code>value</code>属性是默认的，在配置时可以不必显式的写出<code>value=</code>部分，配置时更加简单；</li><li><code>name</code>属性表现的语义更好，更易于根据源代码读懂程序的意思，在其它注解中，也可能存在与<code>value</code> 等效的属性。</li></ul><p>需要注意的是：在配置注解中的属性时，如果需要配置的是<code>value</code>属性的值，可以不用显式的写出<code>value=</code>部分，<strong>前提是当前注解只配置<code>value</code>这1个属性</strong>！如果需要配置多个属性，则必须写出每一个属性名，例如：</p><pre><code class="java">@Bean(value=&quot;user&quot;, initMethod=&quot;init&quot;)</code></pre><p>而不能写成：</p><pre><code class="java">@Bean(&quot;user&quot;, initMethod=&quot;init&quot;)    // 错误</code></pre><h2 id="3-使用组件扫描后配置作用域与生命周期"><a href="#3-使用组件扫描后配置作用域与生命周期" class="headerlink" title="3. 使用组件扫描后配置作用域与生命周期"></a>3. 使用组件扫描后配置作用域与生命周期</h2><p>在类的声明之前，添加<code>@Scope(&quot;prototype&quot;)</code>即可将当前类配置为“非单例”的对象！例如：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Repository;@Repository@Scope(&quot;prototype&quot;)public class User {}</code></pre><p>在单例的情况下，在类的声明之前添加<code>@Lazy</code>注解，就可以将对象配置为“懒加载”的模式：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.context.annotation.Lazy;import org.springframework.stereotype.Repository;@Repository@Lazypublic class User {}</code></pre><p>如果需要配置当前类中的生命周期的处理，首先，还是需要在类中自定义2个方法，分别表示“初始化方法”和“销毁方法”，然后，在初始化方法之前添加<code>@PostConstruct</code>注解，在销毁方法之前添加<code>@PreDestroy</code>注解，例如：</p><pre><code class="java">package cn.tedu.spring;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;import org.springframework.context.annotation.Lazy;import org.springframework.stereotype.Repository;@Repository@Lazypublic class User {    public User() {        System.out.println(&quot;User.User()&quot;);    }    @PostConstruct    public void init() {        System.out.println(&quot;User.init()&quot;);    }    @PreDestroy    public void destroy() {        System.out.println(&quot;User.destroy()&quot;);    }}</code></pre><p>注意：以上2个注解并不是Spring的注解，如果JRE环境版本太低，将无法识别以上2个注解，需要调整当前项目的JRE环境！</p><h2 id="4-关于Spring管理对象的小结"><a href="#4-关于Spring管理对象的小结" class="headerlink" title="4. 关于Spring管理对象的小结"></a>4. 关于Spring管理对象的小结</h2><p>如果需要Spring管理某个类的对象，可以：</p><ul><li>自定义方法，将方法的返回值类型设置为期望管理的类型，并在方法中返回匹配类型的对象，最后，在方法的声明之前添加<code>@Bean</code>注解；</li><li>设置组件扫描的包，并在类的声明之前添加<code>@Component</code> / <code>@Controller</code> / <code>@Service</code> / <code>@Repository</code>这4个注解中的某1个。</li></ul><p>在实际使用时，大多采取第2种做法，但是，如果需要Spring管理的类并<strong>不是自定义的类</strong>，就只能采取第1种做法！</p><h2 id="5-关于Spring的解耦"><a href="#5-关于Spring的解耦" class="headerlink" title="5. 关于Spring的解耦"></a>5. 关于Spring的解耦</h2><p>在没有使用Spring框架的情况下，在项目中，各组件之间是存在依赖关系的，例如：</p><pre><code class="java">// 处理用户登录请求的Servlet组件类public class UserLoginServlet {    private UserJdbcDao userDao = new UserJdbcDao();    public void doPost() {        userDao.login();    }}</code></pre><pre><code class="java">// 处理用户数据增删改查的组件public class UserJdbcDao {    public void login() {        // 通过JDBC技术实现数据查询，判断用户名与密码是否正确    }}</code></pre><p>以上代码就体现了类与类之前的<strong>依赖</strong>关系，具体表现就是<code>UserLoginServlet</code>是依赖于<code>UserJdbcDao</code>的！</p><p>如果直接依赖于某个类，将会导致<strong>耦合度过高</strong>的问题！</p><p>假设在<code>UserJdbcDao</code>中，是通过原生的JDBC技术实现数据访问的，后续，需要改为使用MyBatis框架技术来实现，则可能创建<code>UserMybatisDao</code>类，用于取代<code>UserJdbcDao</code>类！</p><p>如果需要替换，则项目中原有的以下代码：</p><pre><code class="java">private UserJdbcDao userDao = new UserJdbcDao();</code></pre><p>全部需要替换为：</p><pre><code class="java">private UserMybatisDao userDao = new UserMybatisDao();</code></pre><p>这种<strong>替换时需要调整大量原有代码</strong>的问题，就是<strong>高耦合</strong>的问题，我们希望的目标是<strong>低耦合</strong>，将原有<strong>高耦合</strong>的项目调整为<strong>低耦合</strong>的状态，就是<strong>解耦</strong>的做法！</p><p>可以将处理用户数据增删改查的相关操作声明在接口中，例如：</p><pre><code class="java">public interface UserDao {    void login();}</code></pre><p>然后，各个处理用户数据增删改查的类都去实现这个接口：</p><pre><code class="java">public class UserJdbcDao implements UserDao {    public void login() {        // 通过JDBC实现处理用户登录    }}</code></pre><pre><code class="java">public class UserMybatisDao implements UserDao {    public void login() {        // 通过MyBatis框架技术实现处理用户登录    }}</code></pre><p>后续，在各个Servlet组件中，就可以声明为接口类型：</p><pre><code class="java">private UserDao userDao = new UserMybatisDao();</code></pre><p>通过以上代码调整，就可以使得Servlet组件<strong>依赖于接口</strong>，而不再是<strong>依赖于类</strong>，从而实现了解耦！</p><p>另外，还可以通过设计模式中的工厂模式来生产对象，例如：</p><pre><code class="java">public class UserDaoFactory {    public static UserDao newInstance() {        return new UserMybatisDao();    }}</code></pre><p>当有了以上工厂后，原本在Servlet组件中声明持久层对象的代码就可以再调整为：</p><pre><code class="java">private UserDao userDao = UserDaoFactory.newInstance();</code></pre><p>至此，在项目中到底是使用<code>UserJdbcDao</code>还是使用<code>UserMybatisDao</code>，在以上代码都不会体现出来了，也就意味着当需要切换/替换时，以上代码是不需要修改的，而是修改<code>UserDaoFactory</code>工厂类的方法的返回值这1处即可！</p><p>所以，通过定义接口和创建工厂类就可以实现解耦，但是，在实际项目开发时，不可能为每一个组件都创建专门的工厂类，而Spring框架就可以当作是一个庞大的工厂，开发人员可以通过Spring框架的使用约定，将某些类的对象交给Spring框架进行管理，后续，在具体使用过程中，就不必自行创建对象，而是<strong>获取</strong>对象即可！</p><h2 id="6-自动装配"><a href="#6-自动装配" class="headerlink" title="6. 自动装配"></a>6. 自动装配</h2><p>在Spring框架的应用中，可以为需要被Spring自动赋值的属性添加<code>@Autowired</code>，则Spring框架会从Spring容器中找出匹配的值，并自动完成赋值！这就是Spring框架的自动装配机制！</p><p>当Spring尝试为某个属性实现自动装配时，采取的模式主要有：</p><ul><li><code>byName</code>：根据名称实现自动装配，在这种模式下，要求被装配的属性名称，与被Spring管理的对象的名称（调用<code>getBean()</code>方法给出的参数名）必须相同；</li><li><code>byType</code>：根据类型实现自动装配，在这种模式，要求被装配的属性的类型，在Spring容器中存在匹配类型的对象，当应用这种机制时，必须在Spring容器中保证匹配类型的对象只有1个，否则，将会出现<code>NoUniqueBeanDefinitionException</code>异常；</li></ul><p>当使用<code>@Autowired</code>尝试自动装配时，Spring框架会先根据<code>byType</code>模式找出所有匹配类型的对象，如果匹配类型的对象的数量为0，也就是没有匹配类型的对象，默认情况下会直接报错，提示信息例如：</p><pre><code>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;cn.tedu.spring.UserDao&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}</code></pre><blockquote><p>如果使用<code>@Autowired</code>时明确的配置为<code>@Autowired(required=false)</code>，当没有匹配类型的对象时，也不会因为装配失败而报错！</p></blockquote><p>如果匹配类型的对象的数量为1，则直接装配；</p><p>如果匹配类型的对象的数量超过1个（有2个甚至更多个），会尝试<code>byName</code>来装配，如果存在名称匹配的对象，则成功装配，如果名称均不匹配，则装配失败，会提示如下错误：</p><pre><code>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;cn.tedu.spring.UserDao&#39; available: expected single matching bean but found 2: userJdbcDao,userMybatisDao</code></pre><p>当需要自动装配时，除了使用<code>@Autowired</code>注解以外，还可以使用<code>@Resource</code>注解！</p><p>当使用<code>@Resource</code>注解尝试自动装配时，其工作原理是先尝试<code>byName</code>装配，如果存在名称匹配的对象，则直接装配，如果没有名称匹配的对象，则尝试<code>byType</code>装配。</p><p>另外，如果某个方法是被Spring调用的，还可以将需要装配的对象设置为方法的参数（不需要添加注解即可正常使用），Spring也可以实现方法参数的自动装配！例如：</p><pre><code class="java">public void test(UserDao userDao) {}</code></pre><h2 id="7-通过Spring框架读取-properties文件"><a href="#7-通过Spring框架读取-properties文件" class="headerlink" title="7. 通过Spring框架读取.properties文件"></a>7. 通过Spring框架读取.properties文件</h2><p>首先，在案例的<strong>src/main/resources</strong>下创建<strong>jdbc.properties</strong>文件，并且，在文件中，添加一些自定义的配置信息：</p><pre><code>url=jdbc:mysql://localhost:3306/db_namedriver=com.mysql.jdbc.Driverusername=rootpassword=1234</code></pre><blockquote><p>本次案例的目标是读取以上文件的信息，并不用于真实的连接某个数据库，所以，各属性的值可以不是真正使用的值！</p></blockquote><p>如果要读取以上信息，可以将这些信息都读取到某个类的各个属性中去，则先创建一个类，并在类中声明4个属性（与以上<strong>jdbc.properties</strong>文件中的配置信息的数量保持一致）：</p><pre><code class="java">package cn.tedu.spring;public class JdbcConfig {    private String url;    private String driver;    private String username;    private String password;}</code></pre><p>然后，在类的声明之前，通过<code>@PropertySource</code>配置需要读取的配置文件：</p><pre><code class="java">@PropertySource(&quot;classpath:jdbc.properties&quot;)</code></pre><p>然后，在各个属性的声明之前，通过<code>@Value</code>注解读取配置信息中的值，并注入到属性中，其基本格式是<code>@Value(&quot;${配置文件中的属性名称}&quot;)</code>，例如：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JdbcConfig {    @Value(&quot;${url}&quot;)    private String url;    @Value(&quot;${driver}&quot;)    private String driver;    @Value(&quot;${username}&quot;)    private String username;    @Value(&quot;${password}&quot;)    private String password;    @Override    public String toString() {        return &quot;JdbcConfig [url=&quot; + url + &quot;, driver=&quot; + driver + &quot;, username=&quot; + username + &quot;, password=&quot; + password                + &quot;]&quot;;    }}</code></pre><p>由于期望的是由Spring读取配置文件，并为以上类的各个属性赋值，所以，以上<code>JdbcConfig</code>应该是被Spring管理的！所以，先使用一个类来配置组件扫描：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.context.annotation.ComponentScan;@ComponentScan(&quot;cn.tedu.spring&quot;)public class SpringConfig {}</code></pre><p>然后，在<code>JdbcConfig</code>类的声明之前添加<code>@Component</code>注解即可！</p><p><strong>注意：在Windows操作系统中，如果配置文件中的属性名是<code>username</code>，则最终注入属性的值将不是配置文件中的值，而是当前登录Windows操作系统的用户名，为了避免出现此类问题，建议在配置文件中，每个属性的名称之前都添加一些自定义的前缀。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring01</title>
      <link href="/2020/07/01/07_SPRING_DAY01/"/>
      <url>/2020/07/01/07_SPRING_DAY01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="2-Spring框架的作用"><a href="#2-Spring框架的作用" class="headerlink" title="2. Spring框架的作用"></a>2. Spring框架的作用</h2><p>Spring框架的主要作用是创建对象和管理对象。</p><p>创建对象：类似于<code>User user = new User();</code></p><p>管理对象：随时可以通过Spring框架获取对象，甚至Spring框架还能够帮我们为对象的属性进行赋值等。</p><h2 id="3-通过Spring框架创建对象，并获取对象"><a href="#3-通过Spring框架创建对象，并获取对象" class="headerlink" title="3. 通过Spring框架创建对象，并获取对象"></a>3. 通过Spring框架创建对象，并获取对象</h2><p>在Eclipse中创建<strong>Maven Project</strong>，在创建过程中勾上<strong>Create a simple project</strong>，<strong>Group Id</strong>填为<code>cn.tedu</code>，<strong>Artifact Id</strong>填为<code>spring01</code>。</p><blockquote><p>如果某个项目不会被其它项目所使用，只需要保证自身能独立运行，其实<strong>Group Id</strong>和<strong>Artifact Id</strong>的值是多少，并不重要。</p></blockquote><p>创建成功后，先在<strong>pom.xml</strong>中添加以上配置：</p><pre><code class="xml">&lt;properties&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;/properties&gt;</code></pre><p>然后，对项目名称点击鼠标右键，选择<strong>Maven</strong> &gt; <strong>Update Project</strong>以更新Maven，则当前环境会使用Java 1.8。</p><p>接下来，需要在<strong>pom.xml</strong>中添加Spring框架所需的<code>spring-context</code>依赖的代码：</p><pre><code class="xml">&lt;dependencies&gt;    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>如果需要Spring管理某个类的对象，可以通过自定义的类进行配置！</p><p>例如存在需求：使得Spring框架管理<code>Date</code>类的对象！</p><p>先在项目的<code>cn.tedu.spring</code>包中创建<code>Beans</code>类，并且，在这个类中自定义方法，方法的返回值类型必须是<code>Date</code>，然后，自行在方法体中创建出<code>Date</code>对象并返回即可：</p><pre><code class="java">package cn.tedu.spring;import java.util.Date;import org.springframework.context.annotation.Bean;public class Beans {    @Bean    public Date aaa() {        return new Date();    }}</code></pre><blockquote><p>以上使用的包名是自定义，并不是强制要求。</p><p>以上使用的类名是自定义，并不是强制要求。</p></blockquote><p>关于以上自定义的方法：</p><ul><li>应该使用<code>public</code>权限；</li><li>返回值类型是需要Spring管理的对象所归属的类型；</li><li>方法名称可以自定义；</li><li>参数列表暂时为空；</li><li>必须添加<code>@Bean</code>注解。</li></ul><p>然后，就可以创建一个用于运行的类，加载以上类，并获取对象：</p><pre><code class="java">package cn.tedu.spring;import java.util.Date;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Demo {    public static void main(String[] args) {        // 1. 加载配置类，获取Spring容器        AnnotationConfigApplicationContext ac            = new AnnotationConfigApplicationContext(Beans.class);        // 2. 从Spring容器中获取对象        Date date = (Date) ac.getBean(&quot;aaa&quot;); // getBean()方法的参数，就是配置对象的方法的名称        // 3. 测试        System.out.println(date);        // 4. 关闭        ac.close();    }}</code></pre><p>运行以上代码，就可以看到输出的对象！</p><p>在以上<code>Beans</code>类中，配置对象的方法名是<code>aaa</code>，在运行的<code>Demo</code>类中，调用<code>getBean()</code>方法的参数也必须是<code>&quot;aaa&quot;</code>，名称必须保持一致！</p><p>通过，获取某个值的方法的名称都应该是<code>getXxx</code>，所以，以上<code>Beans</code>类中的方法应该改为：</p><pre><code class="java">@Beanpublic Date getDate() {    return new Date();}</code></pre><p>但是，一旦将方法名改成了<code>getDate</code>，运行时，调用的<code>getBean()</code>方法的参数也应该改成<code>getDate</code>，例如改成：</p><pre><code class="java">Date date = (Date) ac.getBean(&quot;getDate&quot;);</code></pre><p>很显然，这个<code>getDate</code>表示的是一个<strong>名称</strong>，而名称应该使用名词，而不应该使用动词作为前缀！</p><p>如果要解决这个问题，可以在<code>@Bean</code>注解中配置参数，例如：</p><pre><code class="java">@Bean(&quot;date&quot;)public Date getDate() {    return new Date();}</code></pre><p>后续，在运行时，调用<code>getBean()</code>方法的参数就是<code>@Bean</code>注解中配置的值，例如：</p><pre><code class="java">Date date = (Date) ac.getBean(&quot;date&quot;);</code></pre><p><strong>小结：在运行时，调用的<code>getBean()</code>方法的参数值，默认情况下，是配置对象的方法的名称，如果配置对象的方法的<code>@Bean</code>注解添加了参数，则<code>getBean()</code>方法的参数就是<code>@Bean</code>注解中的参数！</strong></p><p><strong>其实，Spring推荐直接使用名词作为以上配置对象的方法名称，即推荐使用<code>date</code>作为方法名，而不是<code>getDate</code>作为方法名！该名词将用于<code>getBean()</code>方法的参数，毕竟这个方法定义好了以后，是由Spring框架去调用了，开发人员不需要自行调用该方法，为了简化代码的同时还保证<code>getBean()</code>代码的语义，推荐使用名词作为方法名称！</strong></p><h2 id="4-由Spring管理的对象的作用域"><a href="#4-由Spring管理的对象的作用域" class="headerlink" title="4. 由Spring管理的对象的作用域"></a>4. 由Spring管理的对象的作用域</h2><p>由Spring管理的对象，在默认情况下，都是单例的！如果在配置对象的方法之前，补充添加<code>@Scope</code>注解，且注解参数配置为<code>prototype</code>时，就不是单例的了！例如：</p><pre><code class="java">@Bean@Scope(&quot;prototype&quot;)public User user() {    return new User();}</code></pre><blockquote><p>注意：Spring与单例模式是两个不同的概念！</p><p>当需要同时使用多个注解时，各注解不区分先后顺序。</p></blockquote><p>由Spring管理的对象，在单例的情况下，默认是饿汉式的！如果希望调整为懒汉式的，则在配置对象方法的方法之前补充添加<code>@Lazy</code>注解即可：</p><pre><code class="java">@Bean@Lazypublic User user() {    return new User();}</code></pre><h2 id="5-由Spring管理的对象的生命周期"><a href="#5-由Spring管理的对象的生命周期" class="headerlink" title="5. 由Spring管理的对象的生命周期"></a>5. 由Spring管理的对象的生命周期</h2><p>生命周期：某个对象从创建到最终销毁会经历的历程！</p><p>通常，需要讨论生命周期时，对应的数据类型的对象都不是由开发人员自行维护的！</p><p>被容器维护的对象，都是由容器创建对象，并在适当的时候调用其中的某些方法的！而开发人员需要做的就是“确定满足某条件的时候应该执行什么任务”！也就是说，“容器决定什么时候执行，开发人员决定执行时做什么”。</p><p>学习生命周期的意义就是“知道在什么时候需要做什么事情”！</p><p>以<code>Servlet</code>为例，其生命周期中会有几个特殊的方法，在特定的情况下会被调用，这些就称之为生命周期方法：</p><ul><li><code>init()</code>：当<code>Servlet</code>被创建对象后，立即执行，且只执行1次，该方法适合编写一些初始化相关的代码；</li><li><code>service()</code>：当接收到匹配的请求后会被调用，接收到多少次请求，就执行多少次该方法；</li><li><code>destroy()</code>：当<code>Servlet</code>对象即将被销毁之前执行，且只执行1次，该方法适合编写一些与结束相关的代码，例如关闭等等。</li></ul><p>当使用Spring框架后，某些类的对象交给Spring框架来管理了，那么，这些对象在什么时候被创建、什么时候被销毁，及创建过程和销毁过程中需要执行某些代码，对于开发人员来说，一定程度上是不可控的！</p><p>Spring框架允许用户在类中自定义最多2个方法，分别表示“初始化方法”和“销毁方法”，并且，Spring框架会在创建对象之后自动调用初始化方法，会在销毁对象之前调用销毁方法！关于方法的定义：</p><ul><li>访问权限：应该使用<code>public</code>权限；</li><li>返回值类型：使用<code>void</code>；</li><li>方法名称：自定义；</li><li>参数列表：空。</li></ul><p>例如，在<code>User</code>类中自定义2个生命周期方法：</p><pre><code class="java">public void init() {    System.out.println(&quot;User.init()&quot;);}public void destroy() {    System.out.println(&quot;User.destroy()&quot;);}</code></pre><p>然后，在配置对象的方法之前的<code>@Bean</code>注解中配置这2个方法作为生命周期方法：</p><pre><code class="java">@Bean(initMethod=&quot;init&quot;, destroyMethod=&quot;destroy&quot;)public User user() {    return new User();}</code></pre><h2 id="6-通过组件扫描使得Spring管理类的对象"><a href="#6-通过组件扫描使得Spring管理类的对象" class="headerlink" title="6. 通过组件扫描使得Spring管理类的对象"></a>6. 通过组件扫描使得Spring管理类的对象</h2><p>假设存在<code>User</code>类，需要被Spring框架创建并管理对象，则，必须先明确<code>User</code>类所在的包，然后，在用于运行的类<code>Demo</code>中，在<code>AnnotationConfigApplicationContext</code>的构造方法中，将包名作为构造方法的参数，例如：</p><pre><code class="java">AnnotationConfigApplicationContext ac     = new AnnotationConfigApplicationContext(&quot;cn.tedu.spring&quot;);</code></pre><p>以上代码则表示“<strong>组件扫描</strong>”，当执行时，Spring框架会扫描指定的包中所有的内容，并且，自动创建各<strong>组件</strong>的对象并进行管理！</p><p>当然，并不是所有的类都是“<strong>组件</strong>”，如果要标识某个类是“组件”，必须在类的声明之前添加<code>@Component</code>注解！例如：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.stereotype.Component;@Componentpublic class User {}</code></pre><p>后续，从Spring容器中获取对象时，默认情况下，将类名的首字母改为小写，作为Bean的名称，用于调用<code>getBean()</code>方法的参数，例如：</p><pre><code class="java">User user = ac.getBean(&quot;user&quot;, User.class);</code></pre><blockquote><p>关于Bean的名称，如果类名<strong>首字母是大写，且第2个字母是小写</strong>，例如<code>User</code>或<code>Student</code>，则Bean的名称就是将首字母改为小写即可，也就是<code>user</code>或<code>student</code>！如果不满足该条件，例如类名是<code>teacher</code>或<code>IUserDao</code>，则Bean的名称就是类的名称！</p></blockquote><p>当然，Spring框架也允许自定义Bean的名称，只要将自定义的名称配置在<code>@Component</code>注解参数中即可，例如：</p><pre><code class="java">package cn.tedu.spring;import org.springframework.stereotype.Component;@Component(&quot;stu&quot;)public class Student {}</code></pre><p>则以上类的对象被Spring管理时，Bean的名称就是<code>&quot;stu&quot;</code>，后续，调用<code>getBean()</code>方法获取对象时，也必须使用这个名称来获取对象：</p><pre><code class="java">Student stu = ac.getBean(&quot;stu&quot;, Student.class);</code></pre><hr><h2 id="【附】1-单例模式"><a href="#【附】1-单例模式" class="headerlink" title="【附】1. 单例模式"></a>【附】1. 单例模式</h2><p>单例模式，是设计模式中的一种。</p><p>单例模式，其特点是：被设计为单例的类型，在同一时间内，该类型的对象只会存在1个！</p><p>假设存在<code>King</code>类：</p><pre><code class="java">public class King {}</code></pre><p>作为一个普通的类，是可以在类的外部随意创建对象的，例如：</p><pre><code class="java">King k1 = new King();King k2 = new King();King k3 = new King();</code></pre><p>因为在<code>King</code>类中，没有声明构造方法，则编译器会自动的添加默认构造方法，也就是公有的、无参数的构造方法，所以，在类的外部才可以随意创建对象！以上代码中就创建了3个<code>King</code>类型的对象！</p><p>如果要实现单例，首先，就不能允许随意创建对象，可以显式的添加构造方法，并将其私有化，避免外部随意访问，例如：</p><pre><code class="java">public class King {    private King() {}}</code></pre><p>一旦显式的添加了构造方法，编译器就不会再自动添加构造方法了，则在类的外部，将不可以再执行<code>King k1 = new King();</code>这类的代码了！</p><p>使用了私有的构造方法，并不影响在类的内部使用该构造方法，为了保证在类的外部依然可以获取类的对象，则可以：</p><pre><code class="java">public class King {    private King() {}    public King getInstance() {        return new King();    }}</code></pre><p>同时，为了保证“多次获取时，获取到的都是同一个对象”，则不能反复在方法中<strong>创建</strong>对象，而是改为：</p><pre><code class="java">public class King {    private King king = new King();    private King() {}    public King getInstance() {        return king;    }}</code></pre><p>改为这样以后，无论执行多少次<code>getInstance()</code>方法，该方法返回的都是同一个<code>king</code>变量，而该变量的值只是在类被加载时赋值了1次而已，就实现了单例的效果！</p><p>当然，以上代码是矛盾的！因为，如果要调用<code>getInstance()</code>方法，必须先有<code>King</code>类型的对象，而得到<code>King</code>类型对象的唯一途径就是调用<code>getInstance()</code>方法！也就是说：不调用<code>getInstance()</code>方法就无法得到对象，但是，调用方法之前又必须有对象！</p><p>为了解决这个问题，可以为<code>getInstance()</code>方法添加<code>static</code>修饰符，则通过<code>类名.方法名()</code>的格式就可以调用方法了，不需要事先获取对象！同时，基于“被<code>static</code>修饰的成员不可以直接访问没被<code>static</code>修饰的成员”的原则，所以，全局的<code>private King king = new King();</code>也需要添加<code>static</code>修饰符：</p><pre><code class="java">public class King {    private static King king = new King();    private King() {}    public static King getInstance() {        return king;    }}</code></pre><p>至此，简单的单例模式代码就完成了，后续，需要获取<code>King</code>类型的对象时，只能通过<code>King.getInstance()</code>得到对象，而该方法每次返回的都是同一个对象！</p><p>严格来说，以上单例模式的设计是“饿汉式”的，可以看到，在类被加载时，就直接创建了<code>King</code>类的对象，此时，也许并不需要获取对象，但是，也创建好了 ，后续，当需要对象时，直接获取即可！另外，还有“懒汉式”的单例模式，其特点就是“不到逼不得已，不创建对象”！其基础代码例如：</p><pre><code class="java">public class King {    private static King king;    private King() {}    public static King getInstance() {        if (king == null) {            king = new King();        }        return king;    }}</code></pre><p>以上代码是多线程不安全的！为了解决这个问题，可以将以上代码块添加互斥锁，例如：</p><pre><code class="java">public class King {    private static King king;    private King() {}    public static King getInstance() {        synchronized(&quot;java&quot;) {            if (king == null) {                king = new King();            }        }        return king;    }}</code></pre><p>一旦添加了锁，就会导致每次调用<code>getInstance()</code>方法时都会先锁定代码再执行，效率偏低，为了解决该问题，还可以：</p><pre><code class="java">public class King {    private static King king;    private King() {}    public static King getInstance() {        if (king == null) { // 判断是否有必须加锁，如果没有该判断，则效率可能偏低            synchronized(&quot;java&quot;) {                if (king == null) { // 判断是否有必须创建对象，如果没有该判断，则可能创建多个对象                    king = new King();                }            }        }        return king;    }}</code></pre><p>以上，就是完整的懒汉式的单例模式！</p><p><strong>小结：单例模式的特点就是“单一实例”，表现为“同一时间内，某个类的对象只有1个”！单例模式分为“饿汉式”和“懒汉式”这2种，前者是“早早的创建出对象，随时可以获取”，后者是“不到逼不得已不会创建对象”！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 达内笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis命令</title>
      <link href="/2020/06/24/redis%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/24/redis%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>开启redis命令</strong></p><p>systemctl start pedis.service</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux防火墙常用命令</title>
      <link href="/2020/06/24/linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/24/linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h5 id="开启防火墙端口"><a href="#开启防火墙端口" class="headerlink" title="开启防火墙端口"></a>开启防火墙端口</h5><p>​    firewall-cmd –zone=public –add-port=80/tcp –permanent</p><h5 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h5><p>systemctl restart firewalld.service</p><h5 id="查看已经开放的端口"><a href="#查看已经开放的端口" class="headerlink" title="查看已经开放的端口"></a><strong>查看已经开放的端口</strong></h5><p>firewall-cmd –list-ports</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java十万个为什么</title>
      <link href="/2020/03/30/Java%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
      <url>/2020/03/30/Java%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="什么是Java？"><a href="#什么是Java？" class="headerlink" title="什么是Java？"></a>什么是Java？</h4><h4 id="什么是面向对象（OOP）"><a href="#什么是面向对象（OOP）" class="headerlink" title="什么是面向对象（OOP）?"></a>什么是面向对象（OOP）?</h4><p>一切事物皆对象,将现实的事物抽象出来.</p><p>自己做饭就是面向过程，点外卖就是面向对象。你不需要知道饭是怎么做出来的，降低了耦合性，提高了可维护性。</p><p><strong>面向对象三大基本特征:封装、继承、多态</strong></p><h4 id="什么是封装？"><a href="#什么是封装？" class="headerlink" title="什么是封装？"></a><strong>什么是封装？</strong></h4><p>我们把「数据」和「能力」组合成一个对象的过程就叫做「封装」。</p><p>例：把一个人的，身高、体重 看作是属性，打篮球等技能看作是技能、能力，把他们封装在一起。封装的结果就是可以有一个类，通过这个类我们可以获得一个对象。然后我们就可以通过给这个对象下命令，让他执行自己的「能力」。</p><h4 id="什么是继承？"><a href="#什么是继承？" class="headerlink" title="什么是继承？"></a><strong>什么是继承？</strong></h4><p>在面向对象编程中，当两个类具有相同的特征（属性）和行为（方法）时，可以将相同的部分抽取出来放到一个类中作为父类，其它两个类「继承」这个父类。继承后子类自动拥有了父类的部分属性和方法。</p><h4 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a><strong>什么是多态？</strong></h4><p>同一操作，作用于不同的对象，可以产生不同的结果，这就是「多态」。通常说的多态都是指运行期的多态，也叫动态绑定。</p><p>向上造型就是多态的一种。</p><h4 id="什么是向上造型？"><a href="#什么是向上造型？" class="headerlink" title="什么是向上造型？"></a>什么是向上造型？</h4><p>子类的对象可以向上造型为父类的类型。即父类引用子类对象，这种方式被称为向上造型。</p><h4 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a><strong>什么是类？</strong></h4><p>不能将所谓的一个事物描述成一类事物，如一只鸟不能称为鸟类。</p><p>类就是<strong>同一类事物</strong>的统称，如果将现实世界中的一个事物抽象成对象，类就是这类对象的统称，如鸟类、家禽类、人类等。</p><p>类是封装对象的属性和行为的载体，反过来说具有<strong>相同属性</strong>和<strong>行为</strong>的一类实体被称为类。</p><h4 id="什么是重定向？"><a href="#什么是重定向？" class="headerlink" title="什么是重定向？"></a>什么是重定向？</h4><p> 重定向就是通过各种方法将各种网络请求重新定个方向转到其它位置</p><h4 id="什么是SpringBoot？"><a href="#什么是SpringBoot？" class="headerlink" title="什么是SpringBoot？"></a>什么是SpringBoot？</h4><p>其设计目的是用来简化Spring应用的创建、运行、调试、部署等。</p><p>它更像是一个SpringMVC框架，但是，它极大程度的简化了相关的配置，它推荐使用“约定大于配置”的思想，框架本身已经完成了大量的基础配置，开发人员只需要知道“应该怎么做”就行，并不需要手动做相关的配置！</p><h4 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型?"></a>什么是泛型?</h4><p>泛型字面意思就是广泛的类型，在设计初并不确定用会传入什么类型的参数，使用时才会传入确定的参数。</p><h4 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h4><p>进程是系统中正在运行的一个程序，程序一旦运行就是进程。</p><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>一个线程则是进程中的执行流程，，每个线程也可以得到一小段程序的执行时间， 是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
