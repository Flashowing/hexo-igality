<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试题笔记 | 二号线的猪猪</title><meta name="description" content="JVMJVM的工作原理JVM是JRE的一部分，Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。(怎么跨平台的：jvm它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统) 一、JVM内存分为堆、方法区、虚拟机栈、本地方法栈、程序计数器五个部分。 二、堆和方"><meta name="keywords" content="面试题"><meta name="author" content="Flashowing"><meta name="copyright" content="Flashowing"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.igality.com/2020/07/24/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="HSJEYp9WF2"/><meta property="og:type" content="article"><meta property="og:title" content="面试题笔记"><meta property="og:url" content="http://www.igality.com/2020/07/24/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="二号线的猪猪"><meta property="og:description" content="JVMJVM的工作原理JVM是JRE的一部分，Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。(怎么跨平台的：jvm它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统) 一、JVM内存分为堆、方法区、虚拟机栈、本地方法栈、程序计数器五个部分。 二、堆和方"><meta property="og:image" content="https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/img-2.jpg"><meta property="article:published_time" content="2020-07-24T09:17:54.000Z"><meta property="article:modified_time" content="2020-08-25T15:22:29.574Z"><meta name="twitter:card" content="summary"><link rel="manifest" href="manifest.json"/><meta name="theme-color" content="#fff"/><meta name="msapplication-TileColor" content="#fff"/><link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/images/icons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/images/icons/favicon-16x16.png"/><link rel="mask-icon" href="/images/icons/safari-pinned-tab.svg" color="#5bbad5"/><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'true'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="面试题" href="http://www.igality.com/2020/07/24/%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="next" title="面试内容" href="http://www.igality.com/2020/07/23/%E9%9D%A2%E8%AF%95%E5%86%85%E5%AE%B9/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c299b1a439c996632c8ca606466a03e2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"简","msgToSimplifiedChinese":"繁"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="baidu-site-verification" content="lSW7QNsTj7" /><style type="text/css">.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/img_4829.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">37</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 拓展</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/reprint/"><i class="fa-fw fa fa-share-square"></i><span> 转载</span></a></li><li><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">1.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM的工作原理"><span class="toc-number">1.1.</span> <span class="toc-text">JVM的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM的生命周期"><span class="toc-number">1.2.</span> <span class="toc-text">JVM的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆与栈"><span class="toc-number">1.3.</span> <span class="toc-text">堆与栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-的类加载过程"><span class="toc-number">1.4.</span> <span class="toc-text">Java 的类加载过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#和equals"><span class="toc-number">2.</span> <span class="toc-text">&#x3D;&#x3D;和equals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#散列表"><span class="toc-number">3.</span> <span class="toc-text">散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解决哈希冲突的办法"><span class="toc-number">3.1.</span> <span class="toc-text">解决哈希冲突的办法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务"><span class="toc-number">4.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#业务层"><span class="toc-number">5.</span> <span class="toc-text">业务层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#POJO"><span class="toc-number">5.1.</span> <span class="toc-text">POJO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-number">6.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring框架的好处，为什么要用Spring"><span class="toc-number">6.1.</span> <span class="toc-text">Spring框架的好处，为什么要用Spring?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">6.2.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-bean的作用域"><span class="toc-number">6.3.</span> <span class="toc-text">Spring bean的作用域*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bean的注入属性有几种方式"><span class="toc-number">6.4.</span> <span class="toc-text">bean的注入属性有几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式"><span class="toc-number">6.5.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装配"><span class="toc-number">6.6.</span> <span class="toc-text">自动装配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC"><span class="toc-number">7.</span> <span class="toc-text">Spring MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC框架的作用"><span class="toc-number">7.1.</span> <span class="toc-text">SpringMVC框架的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC的流程"><span class="toc-number">7.2.</span> <span class="toc-text">SpringMVC的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC能否从请求url中截取参数？"><span class="toc-number">7.3.</span> <span class="toc-text">SpringMVC能否从请求url中截取参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC框架的核心组件"><span class="toc-number">7.4.</span> <span class="toc-text">SpringMVC框架的核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-关于-RequestMapping注解"><span class="toc-number">7.5.</span> <span class="toc-text">1. 关于@RequestMapping注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC怎么使用中文？"><span class="toc-number">7.6.</span> <span class="toc-text">SpringMVC怎么使用中文？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转发与重定向的区别"><span class="toc-number">7.7.</span> <span class="toc-text">转发与重定向的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#能否共享request对象"><span class="toc-number">7.7.1.</span> <span class="toc-text">能否共享request对象?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySql"><span class="toc-number">8.</span> <span class="toc-text">MySql</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是索引"><span class="toc-number">9.</span> <span class="toc-text">什么是索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用索引："><span class="toc-number">9.1.</span> <span class="toc-text">为什么使用索引：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql-索引是怎么实现的？"><span class="toc-number">9.2.</span> <span class="toc-text">mysql 索引是怎么实现的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是Serializable接口"><span class="toc-number">10.</span> <span class="toc-text">什么是Serializable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是序列化？"><span class="toc-number">10.1.</span> <span class="toc-text">什么是序列化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要序列化对象"><span class="toc-number">10.2.</span> <span class="toc-text">为什么要序列化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么情况下需要序列化？"><span class="toc-number">10.3.</span> <span class="toc-text">什么情况下需要序列化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于Session"><span class="toc-number">10.4.</span> <span class="toc-text">关于Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie和Session"><span class="toc-number">10.5.</span> <span class="toc-text">Cookie和Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-拦截器-Interceptor"><span class="toc-number">10.6.</span> <span class="toc-text">4. 拦截器(Interceptor)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#附1：关于拦截器-Interceptor-和过滤器-Filter"><span class="toc-number">10.7.</span> <span class="toc-text">附1：关于拦截器(Interceptor)和过滤器(Filter)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis框架的作用"><span class="toc-number">11.</span> <span class="toc-text">MyBatis框架的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-number">12.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-无序-唯一"><span class="toc-number">12.1.</span> <span class="toc-text">Set 无序,唯一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-有序-可重复"><span class="toc-number">12.2.</span> <span class="toc-text">List 有序,可重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">12.3.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet和TreeMap的区别"><span class="toc-number">12.3.1.</span> <span class="toc-text">TreeSet和TreeMap的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合树状图"><span class="toc-number">12.4.</span> <span class="toc-text">集合树状图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组和集合有什么区别"><span class="toc-number">13.</span> <span class="toc-text">数组和集合有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">14.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer和StringBuilder的区别"><span class="toc-number">14.1.</span> <span class="toc-text">StringBuffer和StringBuilder的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object"><span class="toc-number">15.</span> <span class="toc-text">Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-number">16.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-和-Exception的区别"><span class="toc-number">16.1.</span> <span class="toc-text">Error 和 Exception的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exception"><span class="toc-number">16.2.</span> <span class="toc-text">Exception</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error"><span class="toc-number">16.3.</span> <span class="toc-text">Error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#受检异常和非受检异常"><span class="toc-number">16.4.</span> <span class="toc-text">受检异常和非受检异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw和throws的区别"><span class="toc-number">16.5.</span> <span class="toc-text">throw和throws的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是Java-EE"><span class="toc-number">17.</span> <span class="toc-text">什么是Java EE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaEE-与-JavaSE-的区别与联系"><span class="toc-number">17.1.</span> <span class="toc-text">JavaEE 与 JavaSE 的区别与联系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaEE主要技术"><span class="toc-number">18.</span> <span class="toc-text">JavaEE主要技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射"><span class="toc-number">19.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何通过反射创建对象"><span class="toc-number">19.1.</span> <span class="toc-text">如何通过反射创建对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC执行步骤"><span class="toc-number">20.</span> <span class="toc-text">JDBC执行步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是JDBC，在什么时候会用到它？"><span class="toc-number">21.</span> <span class="toc-text">什么是JDBC，在什么时候会用到它？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array和arrayList有什么区别"><span class="toc-number">22.</span> <span class="toc-text">array和arrayList有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue"><span class="toc-number">23.</span> <span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue-中-poll-和-remove-有什么区别"><span class="toc-number">24.</span> <span class="toc-text">Queue 中 poll()和 remove()有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring用了哪些模式"><span class="toc-number">25.</span> <span class="toc-text">Spring用了哪些模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理模式是什么"><span class="toc-number">26.</span> <span class="toc-text">代理模式是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要用代理模式？"><span class="toc-number">26.1.</span> <span class="toc-text">为什么要用代理模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种代理模式"><span class="toc-number">26.2.</span> <span class="toc-text">三种代理模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式是什么"><span class="toc-number">27.</span> <span class="toc-text">单例模式是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式的作用："><span class="toc-number">27.1.</span> <span class="toc-text">单例模式的作用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是工厂模式"><span class="toc-number">28.</span> <span class="toc-text">什么是工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory-和ApplicationContent的区别"><span class="toc-number">29.</span> <span class="toc-text">BeanFactory 和ApplicationContent的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库中有哪些约束"><span class="toc-number">30.</span> <span class="toc-text">数据库中有哪些约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么设置约束"><span class="toc-number">30.1.</span> <span class="toc-text">怎么设置约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet的执行流程"><span class="toc-number">31.</span> <span class="toc-text">Servlet的执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet的生命周期"><span class="toc-number">32.</span> <span class="toc-text">Servlet的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关系型数据库和非关系型数据库有什么区别"><span class="toc-number">33.</span> <span class="toc-text">关系型数据库和非关系型数据库有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置SpringBean的几种方式"><span class="toc-number">34.</span> <span class="toc-text">配置SpringBean的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Seralizable"><span class="toc-number">35.</span> <span class="toc-text">Seralizable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get和post的区别"><span class="toc-number">36.</span> <span class="toc-text">get和post的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring中的bean是线程安全的吗"><span class="toc-number">37.</span> <span class="toc-text">Spring中的bean是线程安全的吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中参数传递的规则只有一种"><span class="toc-number">38.</span> <span class="toc-text">Java中参数传递的规则只有一种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口和抽象类"><span class="toc-number">39.</span> <span class="toc-text">接口和抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSP"><span class="toc-number">40.</span> <span class="toc-text">JSP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jsp中九个内置对象"><span class="toc-number">40.1.</span> <span class="toc-text">jsp中九个内置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP四大作用域"><span class="toc-number">40.2.</span> <span class="toc-text">JSP四大作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java版本的区别"><span class="toc-number">41.</span> <span class="toc-text">Java版本的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库引擎"><span class="toc-number">42.</span> <span class="toc-text">数据库引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库的三范式是什么？有什么作用？"><span class="toc-number">43.</span> <span class="toc-text">数据库的三范式是什么？有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Bean-是什么"><span class="toc-number">44.</span> <span class="toc-text">Java Bean 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-bean是什么"><span class="toc-number">45.</span> <span class="toc-text">Spring bean是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依赖注入有哪几种方式，有什么区别"><span class="toc-number">46.</span> <span class="toc-text">依赖注入有哪几种方式，有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候需要定义构造方法"><span class="toc-number">46.1.</span> <span class="toc-text">什么时候需要定义构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator"><span class="toc-number">47.</span> <span class="toc-text">Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获得一个类的类对象有哪些方式"><span class="toc-number">48.</span> <span class="toc-text">获得一个类的类对象有哪些方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何通过反射创建对象-1"><span class="toc-number">49.</span> <span class="toc-text">如何通过反射创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC的执行流程"><span class="toc-number">50.</span> <span class="toc-text">GC的执行流程</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/img-2.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">二号线的猪猪</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 拓展</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/reprint/"><i class="fa-fw fa fa-share-square"></i><span> 转载</span></a></li><li><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">面试题笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-24 17:17:54"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-25 23:22:29"><i class="fas fa-history fa-fw"></i> 更新于 2020-08-25</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">9.7k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 29 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM的工作原理"><a href="#JVM的工作原理" class="headerlink" title="JVM的工作原理"></a>JVM的工作原理</h3><pre><code>JVM是JRE的一部分，Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。(怎么跨平台的：jvm它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统) </code></pre><p>一、JVM内存分为堆、方法区、虚拟机栈、本地方法栈、程序计数器五个部分。</p>
<p>二、堆和方法区是线程共享的，虚拟机栈、本地方法栈和程序计数器是线程隔离的。</p>
<p>三、1.堆主要是存放对象实例的也包括数组，是垃圾管理的主要作用区。</p>
<h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a><strong>JVM的生命周期</strong></h3><p>（1）JVM实例的诞生：当启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点。<br>（2）JVM实例的运行 main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程。<br>（3）JVM实例的消亡：当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。</p>
<h3 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h3><p>栈是运行时的单位，而堆是存储的单位。<br>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。<br>在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同因此需要一个独立的线程栈。而<strong>堆则是所有线程共享的。</strong>栈因为是运行单位，因此里面存储的信息都是跟当线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。<br><strong>堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。</strong><br>堆和栈中，栈是程序运行最根本的东西。程序运行可以没有堆，但是不能没有栈。</p>
<h3 id="Java-的类加载过程"><a href="#Java-的类加载过程" class="headerlink" title="Java 的类加载过程"></a>Java 的类加载过程</h3><p> 一般来说，我们把 Java 的类加载过程分为三个主要步骤：加载，连接，初始化，具体行为在 Java 虚拟机规范里有非常详细的定义。</p>
<p>​        首先是加载过程（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，比如 jar 文件，class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p>
<p>​        第二阶段是连接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转入 JVM 运行的过程中。这里可进一步细分成三个步骤：1，验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。2，准备（Pereparation），创建类或者接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显示初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。3，解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在 Java 虚拟机规范中，详细介绍了类，接口，方法和字段等各方面的解析。</p>
<p>​        最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。再来谈谈双亲委派模型，简单说就是当加载器（Class-Loader）试图加载某个类型的时候，除非父类加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p>
<h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h2><p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。</p>
<p><strong>== 的作用：</strong><br>　　基本类型：比较的就是值是否相同<br>　　引用类型：比较的就是地址值是否相同<br><strong>equals 的作用:</strong><br>　　引用类型：默认情况下，比较的是地址值。<br>注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>①哈希表是基于数组的一种存储方式.它主要由哈希函数和数组构成。当要存储一个数据的时候，首先用一个函数计算数据的地址，然后再将数据存进指定地址位置的数组里面。这个函数就是哈希函数，而这个数组就是哈希表。<br>②哈希冲突是指哈希函数算出来的地址被别的元素占用了，也就是，这个位置有人了。好的哈希函数会尽量避免哈希冲突。</p>
<p>1.什么是散列表?</p>
<p>依据关键码值(key)直接获取表中对应纪录的一种数据结构。<br>其中，将关键码值映射到表中的位置的函数叫散列函数(hash函数),<br>存放记录的数组称之为散列表。</p>
<p>2.散列表的工作原理:<br>    首先我们使用散列函数将给定键转化为一个“数组的索引”，(key如果相同就是碰撞)<br>    得到了索引后，我们就可以像访问数组一样，通过这个索引访问到相应的键值对。<br>3.散列表常见的一些实现类。</p>
<p>Hashtable: 线程安全，但是性能低,不建议使用。<br>HashMap:线程不安全，性能高。<br>    注：<br>        可以调用Collections.synchronizedMap来将hashMap<br>    转换成一个线程安全的map。</p>
<p>ConcurrentHashMap: 线程安全，并且性能良好。</p>
<h3 id="解决哈希冲突的办法"><a href="#解决哈希冲突的办法" class="headerlink" title="解决哈希冲突的办法"></a>解决哈希冲突的办法</h3><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>(1)什么是事务?
事务(Transaction)：是数据库领域中，一种能保证多项增删改操作能够全部执行成功，或全部执行失败的机制！

(2)事务的特点(ACID)
    A.原子性（atomicity):
            事务所涉及的各个操作要么全部成功，要么全部失败。
    C.一致性（consistency):
            事务完成之后，不允许非法的数据保存到数据库。一个事务在执行之前和执行之后，数据的完整性都必须处于一致性状态。
    I.隔离性（isolation）：
            多个事务可以同时执行，彼此不所影响。
            事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
    D.持久性（durability）：
            事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</code></pre><h2 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h2><p><strong>什么是业务：业务(Service)，对于普通用户来说，就是一个“功能”，但是，它可能是由多项数据操作组成的，例如“用户注册”就是一个业务，它至少由“根据用户名查询数据”和“插入数据”组成，在编写代码时，业务层主要完成业务流程和业务逻辑的控制，业务流程指的是先做什么、后做什么，业务逻辑指的是什么情况下能做什么、不能做什么，最终，业务层的目标是保障数据的完整性、安全性。</strong></p>
<h3 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h3><p>POJO是各种实体类的统称，常用的实体类包括DO/DTO/BO/VO。</p>
<ol>
<li>DO：与数据库表相对应的实体类，属性与表中字段相对应</li>
<li>DTO：业务层传输数据时使用的实体类</li>
<li>BO：业务层对外提供远程调用时使用的实体类</li>
<li>VO：供视图层使用的实体类</li>
</ol>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>什么是Spring：<br>    简单来说，<strong>Spring是一个轻量级的控制反转（IoC)和面向切面（AOP)的容器框架。</strong></p>
<h3 id="Spring框架的好处，为什么要用Spring"><a href="#Spring框架的好处，为什么要用Spring" class="headerlink" title="Spring框架的好处，为什么要用Spring?"></a>Spring框架的好处，为什么要用Spring?</h3><p>1.方便解耦，便于开发（Spring就是一个大工厂，可以将所有对象的创建和依赖关系维护都交给spring管理）</p>
<p>2.spring支持aop编程（spring提供面向切面编程，可以很方便的实现对程序进行权限拦截和运行监控等功能）</p>
<p>3.声明式事务的支持（通过配置就完成对事务的支持，不需要手动编程）</p>
<p>4.方便程序的测试，spring 对junit4支持，可以通过注解方便的测试spring 程序</p>
<p>5.方便集成各种优秀的框架（）</p>
<p>6.降低javaEE API的使用难度（Spring 对javaEE开发中非常难用的一些API 例如JDBC,javaMail,远程调用等，都提供了封装，是这些API应用难度大大降低）</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>什么是AOP：<br>    简单地说，<strong>就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低 模块间的耦合度，并有利于未来的可操作性和可维护性。</strong><br>    核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横 切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。<br>    Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<h3 id="Spring-bean的作用域"><a href="#Spring-bean的作用域" class="headerlink" title="Spring bean的作用域*"></a>Spring bean的作用域*</h3><p>Spring默认是单例的，当一个bean的作用域为singleton时，那么Spring容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义的相匹配，则只会返回bean的同一实例。</p>
<p>prototype作用域的bean会导致在每次对该bean请求时都会创建一个新的bean实例。</p>
<h3 id="bean的注入属性有几种方式"><a href="#bean的注入属性有几种方式" class="headerlink" title="bean的注入属性有几种方式"></a>bean的注入属性有几种方式</h3><ol>
<li>构造器注入</li>
<li>set注入</li>
<li>接口注入</li>
</ol>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><pre><code class="java">public class King {
    private static King king = new King();

    private King() {}

    public static King getInstance() {
        return king;
    }
}</code></pre>
<p>以上是饿汉式单例模式</p>
<pre><code class="java">public class King {
    private static King king;

    private King() {}

    public static King getInstance() {
        if (king == null) { // 判断是否有必须加锁，如果没有该判断，则效率可能偏低
            synchronized(&quot;java&quot;) {
                if (king == null) { // 判断是否有必须创建对象，如果没有该判断，则可能创建多个对象
                    king = new King();
                }
            }
        }
        return king;
    }
}</code></pre>
<p>以上，就是完整的懒汉式的单例模式！</p>
<p><strong>小结：单例模式的特点就是“单一实例”，表现为“同一时间内，某个类的对象只有1个”！单例模式分为“饿汉式”和“懒汉式”这2种，前者是“早早的创建出对象，随时可以获取”，后者是“不到逼不得已不会创建对象”！</strong></p>
<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p><code>byName</code>：要求被装配的属性名称，与被Spring管理的对象的名称（调用<code>getBean()</code>方法给出的参数名）必须相同；</p>
<p><code>byType</code>：要求被装配的属性的类型，在Spring容器中存在匹配类型的对象，当应用这种机制时，必须在Spring容器中保证匹配类型的对象只有1个，否则，将会出现<code>NoUniqueBeanDefinitionException</code>异常；</p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="SpringMVC框架的作用"><a href="#SpringMVC框架的作用" class="headerlink" title="SpringMVC框架的作用"></a>SpringMVC框架的作用</h3><p>SpringMVC框架主要解决了接收请求与处理响应的问题，也可以认为是解决了V-C交互的问题，与M其实没有关系。</p>
<p>在传统的Java EE的开发模式下，可能存在<code>Servlet</code>组件数量太多的问题，会导致项目的管理难度太大，且运行时，会有大量的<code>Servlet</code>对象长期占用内存的问题！</p>
<p>另外，传统的Java EE开发模式下，数据的处理过程中代码量相对较大，而SpringMVC非常大极度的简化了开发量！</p>
<h3 id="SpringMVC的流程"><a href="#SpringMVC的流程" class="headerlink" title="SpringMVC的流程"></a>SpringMVC的流程</h3><p>发送请求-接收请求-记录请求与控制器的对应关系-委托请求到控制器-处理后得到的数据及视图名称-根据视图名称确定具体的视图组件-产生响应</p>
<h3 id="SpringMVC能否从请求url中截取参数？"><a href="#SpringMVC能否从请求url中截取参数？" class="headerlink" title="SpringMVC能否从请求url中截取参数？"></a>SpringMVC能否从请求url中截取参数？</h3><p>可以利用@PathVariable实现。在Controller方法上添加的<code>@RequestMapping</code>注解中，使用<code>{变量名}</code>的方式，将url中指定位置的值作为变量。在对应方法的参数中，声明一个接收该变量值的参数，前面使用<code>@PathVariable(&quot;变量名&quot;)</code>标注。</p>
<h3 id="SpringMVC框架的核心组件"><a href="#SpringMVC框架的核心组件" class="headerlink" title="SpringMVC框架的核心组件"></a>SpringMVC框架的核心组件</h3><p>-<code>DispatcherServlet</code>：前端控制器，用于接收所有请求，并组织分发；</p>
<p>-<code>HandlerMapping</code>：记录请求路径与控制器的对应关系；</p>
<p>-<code>Controller</code>：自定义的处理请求的控制器组件；</p>
<p>-<code>ModelAndView</code>：控制器组件处理完请求之后得到的结果，包含数据与视图名称；</p>
<p>-<code>ViewResolver</code>：视图解析器，可以根据视图名称，确定具体的视图组件。</p>
<h3 id="1-关于-RequestMapping注解"><a href="#1-关于-RequestMapping注解" class="headerlink" title="1. 关于@RequestMapping注解"></a>1. 关于@RequestMapping注解</h3><p>在处理请求的方法之前添加<code>@RequestMapping</code>注解，可以配置请求路径与处理请求的方法的映射关系！</p>
<h3 id="SpringMVC怎么使用中文？"><a href="#SpringMVC怎么使用中文？" class="headerlink" title="SpringMVC怎么使用中文？"></a>SpringMVC怎么使用中文？</h3><pre><code class="java">@Override
protected Filter[] getServletFilters() {
    //注册过滤器: 注册Spring MVC提供的编码过滤器,解决POST请求乱码问题
    return new Filter[] {new CharacterEncodingFilter(&quot;UTF-8&quot;)};
}</code></pre>
<p>重写getServletFilters方法，返回CharacterEncodingFilter类，设置字符编码为uft-8，或在web.xml中配置CharacterEncodingFilter过滤器，设置字符编码为utf-8。</p>
<h3 id="转发与重定向的区别"><a href="#转发与重定向的区别" class="headerlink" title="转发与重定向的区别"></a>转发与重定向的区别</h3><h4 id="能否共享request对象"><a href="#能否共享request对象" class="headerlink" title="能否共享request对象?"></a>能否共享request对象?</h4><p>转发可以，而重定向不行。<br>注：<br>    因为request和response这两个对象的生存时间是在一次请求与响应<br>期间存在。<br>    转发是服务器内部的行为，具体表现为“控制器将请求转发给视图组件（可以有数据，也可以没有数据）”，对于客户端来说，只发出过1次请求，并且，只知道这1次请求的路径，在客户端的浏览器中，地址栏显示的URL也不会发生变化！同时，由于这是服务器内部的行为，所以，控制器可以向视图组件传递任意数据！从编写代码的角度来看，转发时，需要指定的是视图名称！</p>
<h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><pre><code>索引是数据库中提高查询效率的技术，数据量越大索引效果越明显，索引类似于目录
索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，</code></pre><h3 id="为什么使用索引："><a href="#为什么使用索引：" class="headerlink" title="为什么使用索引："></a>为什么使用索引：</h3><pre><code>数据会零散的保存在磁盘中的每个磁盘块中，如果不使用索引，查找数据只能挨个遍历每一个磁盘块进行查找，如果使用了索引后，磁盘块会以树桩结构进行保存，查找数据时大大降低了磁盘块的访问量，从而达到了提高查询效率的目的</code></pre><h3 id="mysql-索引是怎么实现的？"><a href="#mysql-索引是怎么实现的？" class="headerlink" title="mysql 索引是怎么实现的？"></a>mysql 索引是怎么实现的？</h3><pre><code>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，
可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</code></pre><h2 id="什么是Serializable接口"><a href="#什么是Serializable接口" class="headerlink" title="什么是Serializable接口"></a>什么是Serializable接口</h2><pre><code>一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才能被序列化。</code></pre><h3 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h3><pre><code>序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</code></pre><h3 id="为什么要序列化对象"><a href="#为什么要序列化对象" class="headerlink" title="为什么要序列化对象"></a>为什么要序列化对象</h3><pre><code>把对象转换为字节序列的过程称为对象的序列化
把字节序列恢复为对象的过程称为对象的反序列化</code></pre><h3 id="什么情况下需要序列化？"><a href="#什么情况下需要序列化？" class="headerlink" title="什么情况下需要序列化？"></a>什么情况下需要序列化？</h3><pre><code>当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，以便将来使用时都需要把对象进行序列化</code></pre><h3 id="关于Session"><a href="#关于Session" class="headerlink" title="关于Session"></a>关于Session</h3><p>因为HTTP协议是无状态协议，所以，同一个客户端的多次请求，服务器是无法区分这是来自同一个客户端的，如果需要保存用户的某些数据或状态，就需要使用Session。</p>
<h3 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h3><ul>
<li><p>为什么使用Cookie和Session?</p>
<p>浏览器和服务器之间数据传输遵循的是HTTP数据传输协议,此协议属于无状态协议(一次请求对应一次响应,服务器无法跟踪客户端的请求),通过Cookie服务器可以给客户端设置一个标识,设置完之后客户端之后的请求都会带着这个标识,从而识别客户端. 但是Cookie由于是明文保存在客户端的数据,可以被客户端伪造造成安全隐患, 这时Session的产生解决了此问题,Session基于Cookie实现,但是数据保存在了服务器端,这样保存的数据就不能被伪造从而提高了安全性</p>
</li>
<li><p>作用: Cookie和Session都是为了实现多个Servlet之间共享数据而存在的 </p>
</li>
<li><p>Cookie:数据保存在客户端,类似于打孔式的会员卡, </p>
<ul>
<li>保存时间: 默认保存在内存中浏览器关闭时就会被删除,如果设置了保存时间,数据会保存到磁盘中,时间到了后再销毁</li>
<li>保存数据大小: cookie保存的数据不能超过4k</li>
<li>只能保存字符串数据 </li>
<li>应用场景: 长时间保存的数据</li>
</ul>
</li>
<li><p>Session:数据保存在服务器,类似于银行卡</p>
<ul>
<li>Session保存时间为半个小时, 这个时间可以修改但不建议,因为Session对象保存在服务器中会占用资源,Session不建议数据存储时间太久,而且Session的工作原理基于Cookie,在Cookie中保存了sessionId,并且是在内存中保存,浏览器关闭时sessionId就删除.</li>
<li>保存数据大小:没有限制</li>
<li>可以保存任意对象</li>
<li>应用场景: 记录登录状态 </li>
</ul>
</li>
</ul>
<h3 id="4-拦截器-Interceptor"><a href="#4-拦截器-Interceptor" class="headerlink" title="4. 拦截器(Interceptor)"></a>4. 拦截器(Interceptor)</h3><p>拦截器：是一种可以使得若干种请求都会自动的执行其中的代码组件！该组件对所处理的请求可以选择放行，或选择阻止继续执行！</p>
<p>在SpringMVC项目中，如果需要使用拦截器，首先，需要自定义类，<strong>实现<code>HandlerInterceptor</code>拦截器接口</strong>：</p>
<h3 id="附1：关于拦截器-Interceptor-和过滤器-Filter"><a href="#附1：关于拦截器-Interceptor-和过滤器-Filter" class="headerlink" title="附1：关于拦截器(Interceptor)和过滤器(Filter)"></a>附1：关于拦截器(Interceptor)和过滤器(Filter)</h3><p>过滤器(Filter)是Java EE中的组件，而拦截器(Interceptor)是SpringMVC中的组件！</p>
<p>过滤器(Filter)是执行在所有的<code>Servlet</code>之前的组件，而SpringMVC中的拦截器的第1次执行是在<code>DispatcherServlet</code>之后，且在<code>Controller</code>之前执行的！(对应SpringMVC核心执行流程图，过滤器是1号位置执行，而拦截器第1次执行是在4号位置)</p>
<h2 id="MyBatis框架的作用"><a href="#MyBatis框架的作用" class="headerlink" title="MyBatis框架的作用"></a>MyBatis框架的作用</h2><p>MyBatis框架最直接的作用就是简化持久层开发！</p>
<blockquote>
<p>持久层：处理数据持久化的组件；</p>
</blockquote>
<blockquote>
<p>持久化：将数据永久的存储下来；</p>
</blockquote>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Set-无序-唯一"><a href="#Set-无序-唯一" class="headerlink" title="Set 无序,唯一"></a>Set 无序,唯一</h3><p>HashSet如何保证元素的唯一性</p>
<p><strong>依赖两个方法：hashCode()和equals()</strong></p>
<p>TreeSet底层数据结构是红黑树</p>
<ol>
<li><p>如何保证元素排序的呢?</p>
<p>自然排序、比较器排序</p>
</li>
<li><p>如何保证元素唯一性的呢?<br>根据比较的返回值是否是0来决定</p>
</li>
</ol>
<h3 id="List-有序-可重复"><a href="#List-有序-可重复" class="headerlink" title="List 有序,可重复"></a>List 有序,可重复</h3><p>ArrayList和Vector底层数据结构是数组</p>
<p>linkedList底层数据结构是链表</p>
<p>只有Vector是线程安全的</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>TreeMap是有序的，HashMap和HashTable是无序的。</li>
<li>Hashtable的方法是同步的，HashMap的方法不是同步的。这是两者最主要的区别。</li>
<li>Hashtable是线程安全的，HashMap不是线程安全的。</li>
</ul>
<p><strong>TreeMap底层实现是红黑树</strong></p>
<h4 id="TreeSet和TreeMap的区别"><a href="#TreeSet和TreeMap的区别" class="headerlink" title="TreeSet和TreeMap的区别"></a>TreeSet和TreeMap的区别</h4><p>其中 TreeMap 是 Map 接口的常用实现类，而 TreeSet 是 Set 接口的常用实现类。虽然 TreeMap 和TreeSet 实现的接口规范不同，<strong>但 TreeSet 底层是通过 TreeMap 来实现的</strong>（如同HashSet底层是是通过HashMap来实现的一样），因此二者的实现方式完全一样。而 TreeMap 的实现就是红黑树算法。</p>
<p><strong>相同点：</strong></p>
<ul>
<li>TreeMap和TreeSet都是非同步集合，因此他们不能在多线程之间共享，不过可以使用方法Collections.synchroinzedMap()来实现同步</li>
<li>运行速度都要比Hash集合慢，他们内部对元素的操作时间复杂度为O(logN)，而HashMap/HashSet则为O(1)。</li>
<li>TreeMap和TreeSet都是有序的集合，也就是说他们存储的值都是拍好序的。</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>最主要的区别就是TreeSet和TreeMap分别实现Set和Map接口</li>
<li>TreeSet只存储一个对象，而TreeMap存储两个对象Key和Value（仅仅key对象有序）</li>
<li>TreeSet中不能有重复对象，而TreeMap中可以存在</li>
<li>TreeMap的底层采用红黑树的实现，完成数据有序的插入，排序。</li>
</ul>
<p><strong>红黑树的特点：</strong></p>
<ul>
<li>性质 1：每个节点要么是红色，要么是黑色。</li>
<li>性质 2：根节点永远是黑色的。</li>
<li>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。</li>
<li>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</li>
<li>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</li>
</ul>
<h3 id="集合树状图"><a href="#集合树状图" class="headerlink" title="集合树状图"></a>集合树状图</h3><p><img src= "/img/loading.gif" data-src="/Users/fupeijun/Downloads/collection.png" alt="collection"></p>
<p><img src= "/img/loading.gif" data-src="/Users/fupeijun/Downloads/map.png" alt="map"></p>
<h2 id="数组和集合有什么区别"><a href="#数组和集合有什么区别" class="headerlink" title="数组和集合有什么区别"></a>数组和集合有什么区别</h2><ol>
<li>数组声明了它容纳的元素的类型，而集合不声明。</li>
<li>数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小，集合提供更多的成员方法，能满足更多的需求。</li>
<li>数组的存放的类型只能是一种（基本类型/引用类型）,集合存放的类型可以不是一种(不加泛型时添加的类型是Object)。</li>
<li>数组是java语言中内置的数据类型,是线性排列的,执行效率或者类型检查都是最快的。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">数组</th>
<th align="center">集合</th>
</tr>
</thead>
<tbody><tr>
<td align="center">静态的 ,有固定的大小</td>
<td align="center">动态的,大小不固定</td>
</tr>
<tr>
<td align="center">存放类型只能是一种</td>
<td align="center">存放类型不只是一种</td>
</tr>
<tr>
<td align="center">线性排列,速度快</td>
<td align="center">多种排列方式,速度不一</td>
</tr>
</tbody></table>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="StringBuffer和StringBuilder的区别"><a href="#StringBuffer和StringBuilder的区别" class="headerlink" title="StringBuffer和StringBuilder的区别"></a>StringBuffer和StringBuilder的区别</h3><p>在改变字符串时，都不会创建新的对象。</p>
<p>不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>在Object类中主要包括clone()、finalize()、equals()、toString()等方法，其中常用的两个方法为equals()和toString()方法。</p>
<p><strong>Object类中的getClass()、notify()、notifyAll()、wait()等方法不能被重写，因为这些方法被定义为final类型。</strong></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Error-和-Exception的区别"><a href="#Error-和-Exception的区别" class="headerlink" title="Error 和 Exception的区别"></a>Error 和 Exception的区别</h3><pre><code>Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。

Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。</code></pre><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><pre><code>其中的Exception又分为检查性异常和非检查性异常。两个根本的区别在于，检查性异常 必须在编写代码时，使用try catch捕获（比如：IOException异常）。非检查性异常 在代码编写使，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。 </code></pre><p><strong>它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。</strong></p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><pre><code>表示系统级的错误和程序不必处理的异常，如：OutOfMemoryError、NoClassDefFoundError等。</code></pre><h3 id="受检异常和非受检异常"><a href="#受检异常和非受检异常" class="headerlink" title="受检异常和非受检异常"></a>受检异常和非受检异常</h3><p><strong>非受检异常指的是java.lang.RuntimeException和java.lang.Error类及其子类，所有其他的异常类都称为受检异常。</strong></p>
<p>以下是RuntimeException 非受检异常</p>
<p><code>Java.lang.ClassCastException</code></p>
<p><code>Java.lang.IllegalArgumentException</code></p>
<p><code>Java.lang.IndexOutOfBoundsException</code></p>
<p><code>Java.lang.ArrayIndexOutOfBoundsException</code></p>
<p><code>Java.lang.NullPointerException</code></p>
<h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><p>1、throw代表动作，表示抛出一个异常的动作；throws代表一种状态，代表方法可能有异常抛出<br>2、throw用在方法实现中，而throws用在方法声明中<br>3、throw只能用于抛出一种异常，而throws可以抛出多个异常</p>
<h2 id="什么是Java-EE"><a href="#什么是Java-EE" class="headerlink" title="什么是Java EE"></a>什么是Java EE</h2><p>Java 平台企业版</p>
<h3 id="JavaEE-与-JavaSE-的区别与联系"><a href="#JavaEE-与-JavaSE-的区别与联系" class="headerlink" title="JavaEE 与 JavaSE 的区别与联系"></a>JavaEE 与 JavaSE 的区别与联系</h3><p>JavaEE 是在 JavaSE 的基础上构建的，是对 JavaSE 的扩展，增加了一些更加便捷的应用框架。</p>
<h2 id="JavaEE主要技术"><a href="#JavaEE主要技术" class="headerlink" title="JavaEE主要技术"></a>JavaEE主要技术</h2><p><strong>JDBC</strong>  <strong>Servlet</strong>  <strong>jsp</strong>  <strong>XML</strong></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
<h3 id="如何通过反射创建对象"><a href="#如何通过反射创建对象" class="headerlink" title="如何通过反射创建对象"></a>如何通过反射创建对象</h3><p>通过类对象调用newInstance()方法</p>
<p>通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象</p>
<h2 id="JDBC执行步骤"><a href="#JDBC执行步骤" class="headerlink" title="JDBC执行步骤"></a>JDBC执行步骤</h2><ol>
<li>注册驱动</li>
<li>建立连接</li>
<li>创建statement语句对象</li>
<li>执行sql语句</li>
<li>处理返回的结果</li>
<li>关闭连接</li>
</ol>
<h2 id="什么是JDBC，在什么时候会用到它？"><a href="#什么是JDBC，在什么时候会用到它？" class="headerlink" title="什么是JDBC，在什么时候会用到它？"></a><strong>什么是JDBC，在什么时候会用到它？</strong></h2><p>JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包 里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。</p>
<p>JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p>
<h2 id="array和arrayList有什么区别"><a href="#array和arrayList有什么区别" class="headerlink" title="array和arrayList有什么区别"></a>array和arrayList有什么区别</h2><p>ArrayList可以算是Array的加强版，（对array有所取舍的加强）。</p>
<p>array长度固定，arrayList长度可变；</p>
<p>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>在处理元素前用于保存元素的 collection。除了基本的 <a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Collection.html"><code>Collection</code></a> 操作外，队列还提供其他的插入、提取和检查操作。每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（<code>null</code> 或 <code>false</code>，具体取决于操作）。插入操作的后一种形式是用于专门为有容量限制的 <code>Queue</code> 实现设计的；在大多数实现中，插入操作不会失败。</p>
<h2 id="Queue-中-poll-和-remove-有什么区别"><a href="#Queue-中-poll-和-remove-有什么区别" class="headerlink" title="Queue 中 poll()和 remove()有什么区别"></a>Queue 中 poll()和 remove()有什么区别</h2><p>poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。</p>
<table>
<thead>
<tr>
<th></th>
<th><em>抛出异常</em></th>
<th><em>返回特殊值</em></th>
</tr>
</thead>
<tbody><tr>
<td><strong>插入</strong></td>
<td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#add(E)"><code>add(e)</code></a></td>
<td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#offer(E)"><code>offer(e)</code></a></td>
</tr>
<tr>
<td><strong>移除</strong></td>
<td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#remove()"><code>remove()</code></a></td>
<td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#poll()"><code>poll()</code></a></td>
</tr>
<tr>
<td><strong>检查</strong></td>
<td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#element()"><code>element()</code></a></td>
<td><a href="http://doc.canglaoshi.org/jdk6-docs/java/util/Queue.html#peek()"><code>peek()</code></a></td>
</tr>
</tbody></table>
<h2 id="Spring用了哪些模式"><a href="#Spring用了哪些模式" class="headerlink" title="Spring用了哪些模式"></a>Spring用了哪些模式</h2><ol>
<li>工厂模式</li>
<li>单例模式</li>
<li>策略模式</li>
<li>代理模式</li>
<li>模版模式</li>
<li>适配器模式</li>
<li>观察者模式</li>
</ol>
<h2 id="代理模式是什么"><a href="#代理模式是什么" class="headerlink" title="代理模式是什么"></a>代理模式是什么</h2><p>为被代理对象提供一个代理对象，并由代理对象控制被代理对象的引用。</p>
<h3 id="为什么要用代理模式？"><a href="#为什么要用代理模式？" class="headerlink" title="为什么要用代理模式？"></a>为什么要用代理模式？</h3><p>中介隔离作用：<br>在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到<strong>中介的作用</strong>，其特征是代理类和委托类实现相同的接口。</p>
<h3 id="三种代理模式"><a href="#三种代理模式" class="headerlink" title="三种代理模式"></a>三种代理模式</h3><ol>
<li>静态代理</li>
<li>jdk动态代理</li>
<li>cblib动态代理</li>
</ol>
<h2 id="单例模式是什么"><a href="#单例模式是什么" class="headerlink" title="单例模式是什么"></a>单例模式是什么</h2><p><strong>单例模式（Singleton Pattern</strong>）是一种常用的软件设计模式，该模式的主要目的是确保<strong>某一个类只有一个实例存在</strong>。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。</p>
<h3 id="单例模式的作用："><a href="#单例模式的作用：" class="headerlink" title="单例模式的作用："></a>单例模式的作用：</h3><p>一是，解决多线程并发访问的问题。二是节约系统内存，提交系统运行的效率，提高系统性能。</p>
<h2 id="什么是工厂模式"><a href="#什么是工厂模式" class="headerlink" title="什么是工厂模式"></a>什么是工厂模式</h2><p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<h2 id="BeanFactory-和ApplicationContent的区别"><a href="#BeanFactory-和ApplicationContent的区别" class="headerlink" title="BeanFactory 和ApplicationContent的区别"></a>BeanFactory 和ApplicationContent的区别</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<ul>
<li><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。</p>
</li>
<li><p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p><strong>ApplicationContext：</strong></p>
<p>应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能；</p>
<p>1) 国际化（MessageSource）</p>
<p>2) 访问资源，如URL和文件（ResourceLoader）</p>
<p>3) 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层  </p>
<p>4) 消息发送、响应机制（ApplicationEventPublisher）</p>
<p>5) AOP（拦截器）</p>
</li>
</ul>
<h2 id="数据库中有哪些约束"><a href="#数据库中有哪些约束" class="headerlink" title="数据库中有哪些约束"></a>数据库中有哪些约束</h2><ol>
<li><strong>主键约束</strong>（Primay Key Coustraint） 唯一性，非空性</li>
<li><strong>唯一约束</strong> （Unique Counstraint）唯一性，可以空，但只能有一个</li>
<li><strong>外键约束</strong> （Foreign Key Counstraint）需要建立两表间的关系并引用主表的列</li>
<li><strong>检查约束</strong> （Check Counstraint）对该列数据的范围、格式的限制（如：年龄、性别等）</li>
<li><strong>默认约束</strong> （Default Counstraint）该数据的默认值</li>
</ol>
<h3 id="怎么设置约束"><a href="#怎么设置约束" class="headerlink" title="怎么设置约束"></a>怎么设置约束</h3><h2 id="Servlet的执行流程"><a href="#Servlet的执行流程" class="headerlink" title="Servlet的执行流程"></a>Servlet的执行流程</h2><ol>
<li>客户端发送请求给服务器。</li>
<li>服务器开始接受，先判断该请求的servlet实例是否存在，如果不存在先装载一个servlet类并创建实例，调用init方法进行初始化。如果存在则直接调用该servlet的service方法，之后进行判断是调用doGet方法还是doPost方法。</li>
<li>最后判断服务是否关闭，如果关闭则调用destroy方法。</li>
</ol>
<h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p><code>init()</code> <code>service()</code> <code>destroy()</code></p>
<h2 id="关系型数据库和非关系型数据库有什么区别"><a href="#关系型数据库和非关系型数据库有什么区别" class="headerlink" title="关系型数据库和非关系型数据库有什么区别"></a>关系型数据库和非关系型数据库有什么区别</h2><p><strong>关系型数据库 有</strong><code>MySQL</code> <code>SQLServer</code> <code>MariaDB</code> <code>oracle</code> <code>SQLite</code></p>
<p>关系型和非关系型数据库的主要差异是数据存储的方式。关系型数据天然就是表格式的，因此存储在数据表的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。</p>
<p><strong>优点：</strong><br>1、<strong>易于维护</strong>：都是使用表结构，<strong>格式一致</strong>；<br>2、<strong>使用方便</strong>：<strong>SQL语言通用</strong>，可用于复杂查询；<br>3、<strong>复杂操作</strong>：<strong>支持SQL</strong>，可用于一个表以及多个表之间非常复杂的查询。<br><strong>缺点：</strong><br>1、<strong>读写性能比较差</strong>，尤其是海量数据的高效率读写；<br>2、固定的表结构，<strong>灵活度稍欠</strong>；<br>3、高并发读写需求，传统关系型数据库来说，<strong>硬盘I/O是一个很大的瓶颈</strong>。</p>
<p><strong>非关系型数据库 有</strong> <code>Redis</code> <code>MongoDB</code> </p>
<p><strong>优点：</strong><br>1、<strong>格式灵活</strong>：存储数据的格式<strong>可以是key,value形式、文档形式、图片形式等等</strong>，文档形式、图片形式等等，使用灵活，应用场景广泛，<strong>而关系型数据库则只支持基础类型</strong>。<br>2、<strong>速度快</strong>：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>3、高扩展性；<br>4、<strong>成本低</strong>：nosql数据库<strong>部署简单</strong>，<strong>基本都是开源软件</strong>。</p>
<p><strong>缺点：</strong><br>1、不提供sql支持，<strong>学习和使用成本较高</strong>；<br>2、<strong>无事务处理</strong>；<br>3、<strong>数据结构相对复杂</strong>，复杂查询方面稍欠。</p>
<h2 id="配置SpringBean的几种方式"><a href="#配置SpringBean的几种方式" class="headerlink" title="配置SpringBean的几种方式"></a>配置SpringBean的几种方式</h2><p>有三种方式</p>
<ol>
<li>传统的XML配置方式</li>
<li>基于Java注解的配置</li>
<li>基于类的Java Config</li>
</ol>
<h2 id="Seralizable"><a href="#Seralizable" class="headerlink" title="Seralizable"></a>Seralizable</h2><p>Serializable是一个标识性接口，Java编译器在编译实现序列号接口的类的时候，会自动插入三个方法，这三个方法会自动完成对象的序列号与反序列化，在序列化时，Java的对象输入输出流，会自动调用这三个方法</p>
<h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><p>GET参数通过URL传递，POST放在Request body中。</p>
<p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p>
<p>GET请求只能进行url编码，而POST支持多种编码方式。</p>
<p>GET请求在URL中传送的参数是有长度限制的，而POST没有。</p>
<h2 id="Spring中的bean是线程安全的吗"><a href="#Spring中的bean是线程安全的吗" class="headerlink" title="Spring中的bean是线程安全的吗"></a>Spring中的bean是线程安全的吗</h2><p>Spring容器本身并没有提供Bean的线程安全策略，因此可以说<strong>Spring容器中的Bean本身不具备线程安全的特性</strong></p>
<p>如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p>
<p>对于有状态的bean，Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法，<strong>因为ThreadLocal为每个线程保存线程私有的数据。</strong></p>
<h2 id="Java中参数传递的规则只有一种"><a href="#Java中参数传递的规则只有一种" class="headerlink" title="Java中参数传递的规则只有一种"></a>Java中参数传递的规则只有一种</h2><p><strong>值传递</strong></p>
<p>传递的是自身在栈中的值的拷贝，而不是自身在栈中的值的引用，既然是拷贝，那么不管怎么修改，都不会影响。</p>
<h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约，<strong>更像是一种规范</strong>。而抽象类在代码实现方面发挥作用，可以实现代码的重用。</p>
<p>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</p>
<p>面向接口编程就是增强了代码的拓展性，而接口就是体现的一种规范，也是体现的一种拓展思想。</p>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="jsp中九个内置对象"><a href="#jsp中九个内置对象" class="headerlink" title="jsp中九个内置对象"></a>jsp中九个内置对象</h3><p>request，response，session，application，out，pagecontext，config，page，exception</p>
<h3 id="JSP四大作用域"><a href="#JSP四大作用域" class="headerlink" title="JSP四大作用域"></a>JSP四大作用域</h3><p>page(只在当前页面有效)， request(在当前请求中有效) ，session(在当前会话中有效)， application(在所有的应用程序中都有效)</p>
<h2 id="Java版本的区别"><a href="#Java版本的区别" class="headerlink" title="Java版本的区别"></a>Java版本的区别</h2><h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h2><p><strong>InnoDB</strong></p>
<ul>
<li>默认事务型引擎，被广泛使用的存储引擎</li>
<li>支持行级锁</li>
<li>支持外键</li>
<li>主键查询的性能高于其他类型的存储引擎</li>
<li>数据存储在共享表空间，即多个表和索引都存储在一个表空间中，可通过配置文件修改</li>
<li>内部做了很多优化，如：从磁盘读取数据时会自动构建hash索引，插入数据时自动构建插入缓冲区</li>
<li>通过一些机制和工具支持真正的热备份</li>
<li>支持崩溃后的安全恢复</li>
</ul>
<p><strong>MyISAM</strong></p>
<ul>
<li>拥有全文索引、压缩、空间函数</li>
<li>不支持事务和行级锁、不支持崩溃后的安全恢复</li>
<li>表存储在两个文件：MYD 和 MYI</li>
<li>设计简单，某些场景下性能很好，例如获取整个表有多少条数据，性能很高</li>
</ul>
<h2 id="数据库的三范式是什么？有什么作用？"><a href="#数据库的三范式是什么？有什么作用？" class="headerlink" title="数据库的三范式是什么？有什么作用？"></a>数据库的三范式是什么？有什么作用？</h2><ul>
<li>列不可分，确保表的每一列都是不可分割的原子数据项。作用：方便字段的维护、查询效率高、易于统计。</li>
<li>确保表中的每列都和主键相关，<strong>也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</strong>（限制多对多的关系，建立一个关联表，通过外键和联合主键来关联两张表）</li>
<li><strong>每一列数据都和主键直接相关，而不能间接相关</strong>，（限制一对多的关系，在从表中建立一个外键，通过外键来引用主表的信息）</li>
</ul>
<h2 id="Java-Bean-是什么"><a href="#Java-Bean-是什么" class="headerlink" title="Java Bean 是什么"></a>Java Bean 是什么</h2><p>1、所有属性为private<br>2、提供默认构造方法<br>3、提供getter和setter<br>4、实现serializable接口</p>
<h2 id="Spring-bean是什么"><a href="#Spring-bean是什么" class="headerlink" title="Spring bean是什么"></a>Spring bean是什么</h2><p>在 Spring 中，构成应用程序<strong>主干</strong>并由<strong>Spring IoC容器</strong>管理的<strong>对象</strong>称为<strong>bean</strong>。bean是一个由Spring IoC容器实例化、组装和管理的对象。</p>
<h2 id="依赖注入有哪几种方式，有什么区别"><a href="#依赖注入有哪几种方式，有什么区别" class="headerlink" title="依赖注入有哪几种方式，有什么区别"></a>依赖注入有哪几种方式，有什么区别</h2><p>三种依赖方式：构造方法注入、Setter方法注入与接口注入。</p>
<p><a href="https://blog.csdn.net/YYZZHC999/article/details/79583943?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-2-79583943.nonecase">优缺点</a></p>
<h3 id="什么时候需要定义构造方法"><a href="#什么时候需要定义构造方法" class="headerlink" title="什么时候需要定义构造方法"></a>什么时候需要定义构造方法</h3><p>通常，如果需要自定义构造方法，可能是因为：</p>
<ol>
<li><p>创建对象的同时，快速的为属性赋值；</p>
</li>
<li><p>限制对象的创建过程，例如在单例模式的设计中，将构造方法声明为私有权限；</p>
</li>
<li><p>强制要求传入某些数据。</p>
</li>
</ol>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><h2 id="获得一个类的类对象有哪些方式"><a href="#获得一个类的类对象有哪些方式" class="headerlink" title="获得一个类的类对象有哪些方式"></a>获得一个类的类对象有哪些方式</h2><p>类型.class</p>
<p>对象.getClass()</p>
<p>Class.forName()</p>
<h2 id="如何通过反射创建对象-1"><a href="#如何通过反射创建对象-1" class="headerlink" title="如何通过反射创建对象"></a>如何通过反射创建对象</h2><p>使用Class对象的newInstance()方法来创建对象</p>
<p>通过Constructor类的newInstance()方法获取</p>
<h2 id="GC的执行流程"><a href="#GC的执行流程" class="headerlink" title="GC的执行流程"></a>GC的执行流程</h2></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Flashowing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.igality.com/2020/07/24/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/">http://www.igality.com/2020/07/24/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.igality.com" target="_blank">二号线的猪猪</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/Samoyed.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/24/%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="prev-cover" data-src="https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/Samoyed.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试题</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/23/%E9%9D%A2%E8%AF%95%E5%86%85%E5%AE%B9/"><img class="next-cover" data-src="https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/Samoyed.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试内容</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/07/AOP/" title="AOP"><img class="relatedPosts_cover" data-src="https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/Samoyed.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-07</div><div class="relatedPosts_title">AOP</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/22/Java十万个为什么(2)/" title="java十万个为什么(2)"><img class="relatedPosts_cover" data-src="https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/Samoyed.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-22</div><div class="relatedPosts_title">java十万个为什么(2)</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/03/JVM部分面试题/" title="JVM部分面试题"><img class="relatedPosts_cover" data-src="https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/img-2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-03</div><div class="relatedPosts_title">JVM部分面试题</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/30/Java十万个为什么/" title="Java十万个为什么"><img class="relatedPosts_cover" data-src="https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/Samoyed.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-30</div><div class="relatedPosts_title">Java十万个为什么</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/03/Java基础/" title="Java基础部分面试题"><img class="relatedPosts_cover" data-src="https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/img-2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-03</div><div class="relatedPosts_title">Java基础部分面试题</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/03/Nginx部分面试题/" title="Nginx部分面试题"><img class="relatedPosts_cover" data-src="https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/img-2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-03</div><div class="relatedPosts_title">Nginx部分面试题</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'昵称,邮箱,网站链接')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: '9mJMvEmD3hy65lYYEAVbe0UG-MdYXbMMI',
  appKey: '7xoXKvHKfdcL45EJa5urtpew',
  placeholder: '记得留下你的昵称和邮箱....可以快速收到回复',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://hexo-1301474191.cos.ap-chongqing.myqcloud.com/img-2.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Flashowing</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn"><span>渝ICP备20002043号-5</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div class="app-refresh" id="app-refresh"> <div class="app-refresh-wrap"> <label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" onclick="location.reload()">点击刷新</a> </div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"点击刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>